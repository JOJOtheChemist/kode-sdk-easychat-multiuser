# 前端连接实现详解 - SSE 和工具调用机制

## 架构概览

前端通过 **Server-Sent Events (SSE)** 与后端 KODE SDK 建立实时连接，实现了工具调用和多轮会话功能。

### 核心组件关系
```
Frontend (localhost:8080) 
    ↓ SSE Connection
Backend API (localhost:3000)
    ↓ KODE SDK
Agent Runtime + Tools
```

## 1. 后端 API 实现 - Next.js API 路由

### 关键文件：`kode-sdk/examples/nextjs-api-route.ts`

#### 核心功能设计：

**1.1 Resume-or-Create 模式**
```typescript
async function resumeOrCreate(agentId: string, overrides?: Partial<AgentConfig>): Promise<Agent> {
  const exists = await deps.store.exists(agentId);
  if (exists) {
    return Agent.resumeFromStore(agentId, deps, { overrides });
  }
  
  const baseConfig: AgentConfig = {
    agentId,
    templateId: 'repo-assistant',
    sandbox: { kind: 'local', workDir: './workspace', enforceBoundary: true },
  };
  
  return Agent.create({ ...baseConfig, ...overrides }, deps);
}
```

**1.2 工具注册和模板配置**
```typescript
const deps = createRuntime(({ templates, registerBuiltin }) => {
  registerBuiltin('fs', 'todo');  // 注册文件系统和Todo工具
  
  templates.register({
    id: 'repo-assistant',
    systemPrompt: 'You are the repo teammate. Always cite filenames.',
    tools: ['fs_read', 'fs_glob', 'todo_read', 'todo_write'],  // 指定可用工具
    model: modelId,
    runtime: { todo: { enabled: true, reminderOnStart: true, remindIntervalSteps: 12 } },
  });
});
```

**1.3 SSE 事件流实现**
```typescript
if (req.method === 'GET') {
  res.setHeader('Content-Type', 'text/event-stream');
  res.setHeader('Cache-Control', 'no-cache');
  res.flushHeaders?.();

  const since = req.query.since
    ? { seq: Number(req.query.since), timestamp: Date.now() }
    : undefined;

  const iterator = agent.subscribe(['progress', 'monitor'], { since })[Symbol.asyncIterator]();

  (async () => {
    try {
      for await (const envelope of { [Symbol.asyncIterator]: () => iterator }) {
        res.write(`data: ${JSON.stringify(envelope)}\n\n`);  // SSE 格式输出
      }
    } catch (error) {
      console.error('SSE stream error', error);
    } finally {
      res.end();
    }
  })();

  req.on('close', () => {
    iterator.return?.();  // 清理资源
  });
}
```

**1.4 消息发送接口**
```typescript
if (req.method === 'POST') {
  const { prompt } = req.body;
  await agent.send(prompt);  // 发送消息到Agent
  res.status(202).json({ status: 'queued' });
  return;
}
```

## 2. 前端 SSE 连接实现

### 关键文件：`kode-frontend-chat/public/debug-sse.html`

#### 2.1 SSE 连接建立
```javascript
function connectSSE() {
  if (eventSource) {
    eventSource.close();
  }

  eventSource = new EventSource(`http://localhost:3000/api/conversations/${conversationId}/events`);
  
  eventSource.onopen = () => {
    updateStatus('SSE连接成功', 'success');
    addEvent('CONNECTION_OPEN', { status: 'connected' });
  };
  
  eventSource.onerror = (error) => {
    updateStatus(`SSE错误: ${error.message || '连接失败'}`, 'error');
    addEvent('CONNECTION_ERROR', { error: error.message });
  };
}
```

#### 2.2 事件类型监听
```javascript
// 监听特定事件类型
['text_chunk_start', 'text_chunk', 'text_chunk_end', 'tool:start', 'tool:end', 'done'].forEach(eventType => {
  eventSource.addEventListener(eventType, (event) => {
    try {
      const data = JSON.parse(event.data);
      addEvent(eventType.toUpperCase(), data);
      
      // 处理工具调用事件
      if (eventType === 'tool:start') {
        console.log('工具开始执行:', data.call.name);
      }
      if (eventType === 'tool:end') {
        console.log('工具执行完成:', data.call.name, '耗时:', data.call.durationMs);
      }
    } catch (error) {
      addEvent(eventType.toUpperCase() + '_ERROR', { error: error.message });
    }
  });
});
```

#### 2.3 消息发送实现
```javascript
async function testSendMessage() {
  updateStatus('发送测试消息...', 'info');
  try {
    const response = await fetch(`http://localhost:3000/api/conversations/${conversationId}/messages`, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        content: '这是一个调试消息，请回复并继续对话。现在时间是：' + new Date().toLocaleString(),
        kind: 'user'
      })
    });
    
    const data = await response.json();
    if (response.ok) {
      updateStatus('消息发送成功', 'success');
      addEvent('SEND_MESSAGE_SUCCESS', data);
    } else {
      throw new Error(data.error || '发送失败');
    }
  } catch (error) {
    updateStatus(`发送失败: ${error.message}`, 'error');
    addEvent('SEND_MESSAGE_ERROR', { error: error.message });
  }
}
```

## 3. 前端代理配置

### 关键文件：`kode-frontend-chat/vite.config.ts`

```typescript
server: {
  port: 8080,
  host: true,
  cors: true,
  proxy: {
    '/api': {
      target: 'http://localhost:3000',  // 代理到后端API
      changeOrigin: true,
      secure: false,
    },
  },
},
```

## 4. 工具调用和多轮对话机制

### 4.1 工具调用流程
```
1. 用户发送消息 → POST /api/conversations/{id}/messages
2. Agent 接收消息 → 分析是否需要工具调用
3. 工具开始执行 → tool:start 事件 (SSE推送到前端)
4. 工具执行完成 → tool:end 事件 (SSE推送结果)
5. 继续对话 → text_chunk 流式输出
```

### 4.2 事件流示例
```javascript
// 工具开始事件
{
  "type": "tool:start",
  "data": {
    "call": {
      "name": "todo_write",
      "input": { "content": "创建HTML文件任务" },
      "timestamp": 1694678400000
    }
  }
}

// 工具结束事件
{
  "type": "tool:end", 
  "data": {
    "call": {
      "name": "todo_write",
      "durationMs": 45,
      "result": { "success": true }
    }
  }
}

// 文本流事件
{
  "type": "text_chunk",
  "data": {
    "delta": "我已经创建了两个HTML文件，"
  }
}
```

### 4.3 多轮对话状态管理
- **会话持久化**：通过 `agentId` 标识不同会话
- **Resume机制**：服务重启后可恢复历史会话
- **事件序列**：使用 `seq` 和 `timestamp` 保证事件顺序
- **断线重连**：前端自动重连机制

## 5. 关键技术要点

### 5.1 SSE vs WebSocket
- **SSE优势**：单向流、简单可靠、自动重连
- **适用场景**：服务端向客户端推送实时数据
- **实现简单**：浏览器原生支持，无需额外库

### 5.2 事件驱动架构
```typescript
// 后端：三通道事件订阅
const iterator = agent.subscribe(['progress', 'monitor'], { since });

// 前端：分类处理事件
eventSource.addEventListener('tool:start', handleToolStart);
eventSource.addEventListener('text_chunk', handleTextChunk);
```

### 5.3 错误处理和资源清理
```typescript
// 后端错误处理
req.on('close', () => {
  iterator.return?.();  // 清理异步迭代器
});

// 前端错误处理
eventSource.onerror = (error) => {
  console.error('SSE连接错误:', error);
  // 自动重连逻辑
};
```

## 6. 运行和部署

### 6.1 启动后端服务
```bash
cd kode-sdk
export ZHIPU_API_KEY=your_api_key
npm run example:nextjs  # 启动在 localhost:3000
```

### 6.2 启动前端服务
```bash
cd kode-frontend-chat
npm run dev  # 启动在 localhost:8080
```

### 6.3 访问调试页面
```
http://localhost:8080/debug-sse.html
```

## 7. 成功验证的功能

✅ **工具调用**：fs_read、fs_write、todo_read、todo_write  
✅ **多轮对话**：基于会话ID的连续对话  
✅ **实时事件**：SSE推送工具生命周期和文本流  
✅ **状态持久化**：resume-or-create模式  
✅ **错误处理**：连接断开自动重连  

---

*分析时间：2025-10-14*  
*状态：已完成前端连接机制分析*