# 整体方案

## 背景
- **后端**：`Kode-sdk` 采用 `Agent` + `MessageQueue` + `Progress/Control/Monitor` 三通道模型（见 `Kode-sdk/src/docs/events.md`、`Kode-sdk/src/core/types.ts`）。消息主体为 `{ role: 'user' | 'assistant' | 'system'; content: ContentBlock[] }`，配合 `MessageQueue` 负责排队与持久化。
- **前端**：`chatkit-js` 将聊天界面封装成 `<openai-chatkit>` Web Component，并通过 `useChatKit` 向外暴露 `sendUserMessage`、`fetchUpdates`、`setThreadId` 等方法（见 `chatkit-js/packages/chatkit-react/src/useChatKit.ts` 和 `chatkit-js/packages/chatkit/src/index.ts`）。若配置 `api.url`，ChatKit 会把所有线程、消息、响应操作 POST 到该入口并期待符合 OpenAI Responses/Assistants 流式事件协议的回应。

## 对接目标
- 让 ChatKit 的线程/消息/响应管理由 Kode Agent 驱动，确保用户消息、助手回复、工具调用能在前端按组件规范正确渲染。
- 复用 Kode 的消息存储、工具系统、断点恢复能力，同时保证 ChatKit 能继续使用其历史面板、启动页、线程切换等内建 UI。
- 封装为一个“前后端桥接层”（HTTP + SSE/Chunked Response），便于扩展认证、安全策略、观察指标。

## 架构总览
```text
┌──────────────────────┐        ┌────────────────────────────┐        ┌─────────────────────┐
│ ChatKit Web Component│  HTTP  │   ChatKit ⇆ Kode Adapter   │  SDK   │      Kode Agent      │
│  & React Hook        │◀──────▶│  (Node/Express/Koa or Nest)│◀──────▶│  (MessageQueue &     │
│ (sendUserMessage etc.)│        │  • 解析 ChatKit 指令        │        │   Persistent Store)   │
└──────────────────────┘        │  • 映射线程 ↔ Agent        │        │  • Progress 事件流化 │
                                │  • 生成 SSE / JSON 回包    │        │  • Tool 调度 / Hook  │
                                └────────────────────────────┘        └─────────────────────┘
```

核心思路：
1. **线程到 Agent 的映射**：将 ChatKit 线程 ID 与 `Agent`/`agentId` 映射存入数据库或内存缓存，初始化时调用 `Agent.create`/`resume`。
2. **消息入队**：收到 `response.create` / `thread.message.create` 指令时，使用 `MessageQueue.send` 将用户消息写入 Kode，并立即触发 `agent.subscribe(['progress'])` 开始消费。
3. **事件翻译**：把 `progress.*`、`monitor.tool_*` 等事件转换为 ChatKit 期待的 `thread.message.delta`、`thread.message.completed`、`thread.run.step.*`、`error` 等 SSE 事件，维持组件状态机。
4. **历史同步**：当 ChatKit 请求线程历史（`thread.retrieve`/`thread.list`）时，读取 `Store.loadMessages`，组装成 ChatKit 线程列表与消息列表格式。
5. **工具与 Widget**：当 Kode 产生 `tool_use`/`tool_result` `ContentBlock` 时，映射到 ChatKit 的 tool run step；若要渲染 Widget，可借助 ChatKit 的 `widgets` 协议，将 Kode 中的结构化结果转换为 `WidgetRoot`。

## 关键职责划分
- **Adapter 服务**（本次新增）
  - 解析 ChatKit 请求（type、threadId、payload）。
  - 调用/初始化 Kode Agent，协调消息与工具调度。
  - 以 SSE 或分块 JSON 推送符合 ChatKit 协议的 `AssistantStreamEvent`。
  - 封装认证、租户隔离、速率控制、日志。
- **Kode Agent 层**
  - 维持消息历史、工具调用、审批流程。
  - 通过 `hooks.messagesChanged`、`progress` 通道对外抛出事件供 Adapter 转换。
- **ChatKit 前端**
  - 保持默认配置，仅将 `api.url` 指向 Adapter。
  - 按事件更新界面（消息列表、工具卡片、Streaming 文案等）。

## 流程摘要
1. **前端初始化**：`useChatKit({ api: { url, domainKey } })` → ChatKit 初始化时向 `POST /chatkit` 发送 `thread.list`、`thread.retrieve` 等指令用于填充历史。
2. **用户发消息**：`sendUserMessage` → Adapter 收到 `thread.message.create` + `response.create`，调用 `MessageQueue.send` 写入，并立即返回 SSE 流。
3. **SSE 推送**：
   - `progress.text_chunk_start` → `thread.message.delta`（`delta.content[].text.value`）。
   - `progress.tool:start` → `thread.run.step.created`（type=`tool_calls`，状态 `in_progress`）。
   - `progress.tool:end` → `thread.run.step.completed`，附带 `tool_result` 内容。
   - `progress.done` → `thread.message.completed` + `thread.run.completed`。
4. **错误处理**：Kode 抛出异常时，Adapter 发送 `error` 事件并同步 `thread.run.failed`，前端自动出现错误提示。
5. **线程切换**：ChatKit 调用 `setThreadId` → Adapter 根据映射找到已有 Agent（`Agent.resume`），若无则拉起新实例并回显历史。

后续文件会细化接口协议与字段映射。
