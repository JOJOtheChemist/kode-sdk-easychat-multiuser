# 消息映射与事件流

## 数据模型对照

| ChatKit / Responses | Kode 定义 | 备注 |
| --- | --- | --- |
| `thread` (`id`, `title`, `metadata`) | `Agent` + `Store` 学习到的上下文 | 每个线程绑定一个 `agentId`，`metadata` 可映射 Kode 模板、权限等。 |
| `thread.message` (`role`, `content[]`) | `Message`（`Kode-sdk/src/core/types.ts:10`） | `content` 直接使用 `ContentBlock`；`tool_use`/`tool_result` 保持结构化。 |
| `thread.run` (`status`, `last_error`) | Kode 会话内的一次模型调用 | `run_id` 可由 Adapter 生成 `run-{timestamp}`，与 `progress` 轮次对应。 |
| `thread.run.step` (type=`message_creation`/`tool_calls`) | Progress 事件 + `ToolCallRecord` (`Kode-sdk/src/core/agent.ts`, `core/template.ts`) | 以工具调用为粒度，对应 `tool:start`/`tool:end`。 |
| `thread.message.delta` (`delta.content[].text.value`) | `progress.text_chunk` 事件 (`docs/events.md`) | 同步 Kode 文本增量，按 `index` 累加。 |
| `thread.message.completed` | `progress.text_chunk_end` + `progress.done` | 结束时推送，带完整 `Message`。 |

### Message → ThreadItem
- **User 消息**：将 ChatKit `thread.message` 转换为 `MessageQueue.send` 的文本内容；Adapter 需要把 ChatKit 请求中的 `attachments` 拆分为 `ContentBlock` (`type = 'tool_use' | 'text'`)。
- **Assistant 消息**：Kode 在回复时生成 `Message`，Adapter 在 `thread.message.completed` 中返回 `content`（保持 `ContentBlock` 结构），ChatKit 会自动渲染文本、工具输出、Widget。

示例（Assistant 文本增量）：

```json
{
  "event": "thread.message.delta",
  "data": {
    "id": "msg_01HZX...",
    "delta": {
      "content": [
        {
          "type": "text",
          "index": 0,
          "text": { "value": "好的，我们先检查仓库结构..." }
        }
      ]
    }
  }
}
```

## 事件映射

| Kode Progress 事件 | ChatKit / Responses 事件 | 转换规则 |
| --- | --- | --- |
| `think_chunk_start` | *(可选)* `thread.run.step.created`（type=`message_creation`, status=`in_progress`） | 如需展示“思考中”状态，可将 `exposeThinking` 打开。 |
| `think_chunk` | *(可选)* 自定义 `chatkit.log` | Kode 默认不开启，除非需要显式思考展示。 |
| `text_chunk_start` | `thread.message.created` + `thread.message.delta`（空字符串以开场） | 先声明消息，再推送 delta。 |
| `text_chunk` | `thread.message.delta` | `value` 为增量文本；保持 `index` 固定（通常 0）。 |
| `text_chunk_end` | `thread.message.completed` | 把合并后的 `Message` 内容作为 `data`。 |
| `tool:start` | `thread.run.step.created`（step_details=`tool_calls`） | 生成 `tool_call_id`，填充 `input_json` 或 `arguments`。 |
| `tool:end` (成功) | `thread.run.step.completed` + `thread.run.step.delta`（可选） | `output` 放入 `tool_result`，并在最终 `thread.message.delta` 中引用。 |
| `tool:error` | `thread.run.step.failed` | 将 `ToolCallRecord.error` 写入 `last_error.message`。 |
| `done` | `thread.run.completed` | 同时推送 `response.completed`/`response.output_text.delta`（可选）。 |

### 错误通道
- 捕获 Kode 抛出的异常（例如模型失败、工具执行错误），同步：
  - `thread.run.failed`（含 `last_error`）
  - `chatkit.error`（`detail.error = new Error(message)`）
  - 根据情况将 `thread.message.incomplete` 或 `thread.message.delta`（含 `refusal`）推送至前端。

### 控制与审批
- 当 `permission_required`（Kode Monitor 通道）触发时，Adapter 需要：
  1. 推送 `thread.run.requires_action`，其中 `required_action.submit_tool_outputs` 可引出审批 UI。
  2. ChatKit 前端无法直接审批，需提供额外 API 以在人机界面完成审批，再调用 `agent.decide`。

## Tool / Widget 映射
- `tool_use` ContentBlock → `thread.run.step.created` + `tool_call` 条目；必要时补充 `input_json`，以便 ChatKit 在 UI 中展示“工具正在执行”。
- `tool_result` ContentBlock → `thread.run.step.delta`（当工具流式输出时）或 `thread.run.step.completed`（一次性返回）。
- 需要渲染 Widget 时，可把 Kode 侧结构化 JSON 转换为 ChatKit 的 `WidgetRoot` 结构（参见 `chatkit-js/packages/chatkit/types/widgets.d.ts`），通过 `thread.message.completed.data.content` 回传。

## 历史同步
- `thread.list`：调用 `Store.loadThreads`（自建封装，持久化 `threadId` ↔ `agentId`）返回分页结果。
- `thread.retrieve`：加载 Agent 的消息历史 `Store.loadMessages(agentId)`，组装为 `thread.message` 数组（时间升序）。
- `thread.messages.list`：与 `retrieve` 一致，可复用同一实现。

## 令牌/统计
- Kode `ContextManager.analyze` 可产出 `usage`（输入、输出 token），在 `thread.message.completed.data.usage` 或 `thread.run.completed.data.usage` 中回填，供 ChatKit 显示字数统计。

## 注意事项
- ChatKit 期望事件严格按时间顺序送达；Adapter 应在单线程或队列中串行化一个线程内的事件。
- 若启用并发工具调用，需要为每个 `ToolCallRecord.id` 维持独立的 run step，并在 `thread.run.step.delta` 中区分 `call_id`。
- SSE 需保持 `Content-Type: text/event-stream`，确保事件之间以 `\n\n` 分隔，字段名分别为 `event:`、`data:`。
