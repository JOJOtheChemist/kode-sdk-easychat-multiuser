# 事件和消息映射对照表

本文档提供 **Kode-SDK 事件** 与 **Frontend 组件** 之间的详细映射关系，供开发时快速查阅。

## 1. 核心映射关系总表

| Kode-SDK | Frontend | 映射复杂度 | 优先级 |
|----------|----------|-----------|-------|
| `Message` | `OpenHandsAction/Observation` | ⭐ 简单 | 🔴 高 |
| `ContentBlock` | `content` 字段 | ⭐ 简单 | 🔴 高 |
| `text_chunk` | `UserAssistantEventMessage` | ⭐⭐ 中等 | 🔴 高 |
| `tool:start` | `ObservationPairEventMessage` | ⭐⭐⭐ 复杂 | 🔴 高 |
| `tool:end` | `McpEventMessage` | ⭐⭐⭐ 复杂 | 🔴 高 |
| `permission_required` | 审批 UI (需新增) | ⭐⭐⭐ 复杂 | 🟡 中 |
| `done` | 对话完成状态 | ⭐ 简单 | 🔴 高 |

## 2. 消息格式映射

### 2.1 用户消息

#### Kode-SDK 格式

```typescript
{
  role: 'user',
  content: [
    { type: 'text', text: '帮我读取 README.md' }
  ]
}
```

#### Frontend 格式

```typescript
{
  action: 'message',
  source: 'user',
  args: {
    content: '帮我读取 README.md'
  }
}
```

#### 转换函数

```typescript
function convertUserMessage(kodeMessage: Message) {
  const textContent = kodeMessage.content
    .filter(b => b.type === 'text')
    .map(b => b.text)
    .join('');
    
  return {
    action: 'message',
    source: 'user',
    args: { content: textContent }
  };
}
```

### 2.2 助手消息（纯文本）

#### Kode-SDK 格式

```typescript
{
  role: 'assistant',
  content: [
    { type: 'text', text: '好的，我来帮你读取文件。' }
  ]
}
```

#### Frontend 格式

```typescript
{
  action: 'message',
  source: 'agent',
  args: {
    content: '好的，我来帮你读取文件。'
  }
}
```

#### 对应组件

```typescript
<UserAssistantEventMessage 
  event={{
    action: 'message',
    source: 'agent',
    args: { content: '...' }
  }}
/>
  ↓ 渲染为
<ChatMessage 
  type="agent" 
  message="好的，我来帮你读取文件。" 
/>
```

### 2.3 助手消息（含工具调用）

#### Kode-SDK 格式

```typescript
{
  role: 'assistant',
  content: [
    { type: 'text', text: '我来读取文件' },
    { 
      type: 'tool_use', 
      id: 'toolu_01ABC', 
      name: 'fs_read', 
      input: { path: 'README.md' } 
    }
  ]
}
```

#### Frontend 格式（拆分为两个事件）

```typescript
// 事件 1: 文本消息
{
  action: 'message',
  source: 'agent',
  args: { content: '我来读取文件' }
}

// 事件 2: 工具调用
{
  action: 'call_tool_mcp',
  source: 'agent',
  id: 'toolu_01ABC',
  args: {
    name: 'fs_read',
    arguments: { path: 'README.md' }
  }
}
```

#### 对应组件

```typescript
// 文本部分
<UserAssistantEventMessage event={textEvent} />

// 工具调用部分
<ObservationPairEventMessage event={toolEvent} />
```

## 3. 工具调用映射

### 3.1 工具调用开始 (tool:start)

#### Kode-SDK Progress 事件

```typescript
{
  type: 'tool:start',
  channel: 'progress',
  call: {
    id: 'tool_abc123',
    name: 'fs_read',
    state: 'EXECUTING',
    inputPreview: { path: 'README.md' },
    startedAt: 1234567890
  }
}
```

#### 转换为 Frontend Action

```typescript
{
  action: 'call_tool_mcp',  // 或根据工具类型映射
  source: 'agent',
  id: 'tool_abc123',
  args: {
    name: 'fs_read',
    arguments: { path: 'README.md' },
    thought: ''  // 可选
  }
}
```

#### 前端组件渲染

```typescript
<ObservationPairEventMessage 
  event={toolAction}
  hasObservationPair={true}
/>
  ↓
<MicroagentStatusWrapper>
  显示"正在执行 fs_read..."
</MicroagentStatusWrapper>
```

### 3.2 工具调用完成 (tool:end)

#### Kode-SDK Progress 事件

```typescript
{
  type: 'tool:end',
  channel: 'progress',
  call: {
    id: 'tool_abc123',
    name: 'fs_read',
    state: 'COMPLETED',
    result: '# My Project\n\nThis is a demo project...',
    durationMs: 15,
    completedAt: 1234567905
  }
}
```

#### 转换为 Frontend Observation

```typescript
{
  observation: 'mcp',
  source: 'agent',
  content: '# My Project\n\nThis is a demo project...',
  extras: {
    name: 'fs_read',
    arguments: { path: 'README.md' },
    duration: 15,
    success: true
  }
}
```

#### 前端组件渲染

```typescript
<McpEventMessage 
  event={observation}
/>
  ↓
<GenericEventMessage
  title="CALL_TOOL_MCP: fs_read"
  details={<MCPObservationContent event={observation} />}
  success="success"
/>
  ↓
<MCPObservationContent>
  <div>
    <h3>Arguments</h3>
    <ReactJsonView src={{ path: 'README.md' }} />
    
    <h3>Output</h3>
    <pre># My Project...</pre>
  </div>
</MCPObservationContent>
```

### 3.3 工具调用失败

#### Kode-SDK 事件

```typescript
{
  type: 'tool:error',
  channel: 'progress',
  call: {
    id: 'tool_xyz',
    name: 'fs_read',
    state: 'FAILED',
    error: 'File not found: /nonexistent.txt',
    isError: true
  }
}

// 或 tool:end with error
{
  type: 'tool:end',
  call: {
    id: 'tool_xyz',
    state: 'FAILED',
    error: 'File not found',
    isError: true
  }
}
```

#### Frontend Observation

```typescript
{
  observation: 'error',
  source: 'agent',
  content: 'File not found: /nonexistent.txt',
  extras: {
    name: 'fs_read',
    arguments: { path: '/nonexistent.txt' }
  }
}
```

#### 前端组件

```typescript
<ErrorEventMessage 
  event={errorEvent}
/>
  ↓
<GenericEventMessage
  title="ERROR: fs_read"
  details={errorMessage}
  success="error"
/>
```

## 4. 流式事件映射

### 4.1 文本流式输出

#### Kode-SDK 事件序列

```typescript
// 1. 开始
{ type: 'text_chunk_start', step: 1 }

// 2. 增量文本
{ type: 'text_chunk', step: 1, delta: '我' }
{ type: 'text_chunk', step: 1, delta: '来' }
{ type: 'text_chunk', step: 1, delta: '帮' }
{ type: 'text_chunk', step: 1, delta: '你' }

// 3. 结束
{ type: 'text_chunk_end', step: 1, text: '我来帮你' }
```

#### Frontend 处理流程

```typescript
// 1. 收到 text_chunk_start
ui.createMessageBubble({ role: 'assistant' });

// 2. 累加每个 text_chunk
let accumulated = '';
onTextChunk((delta) => {
  accumulated += delta;
  ui.updateMessage(accumulated);  // 实时更新
});

// 3. 收到 text_chunk_end
ui.finalizeMessage(event.text);
addToHistory({
  action: 'message',
  source: 'agent',
  args: { content: event.text }
});
```

### 4.2 思考过程流式输出（可选）

#### Kode-SDK 事件

```typescript
// 需开启 exposeThinking: true

{ type: 'think_chunk_start', step: 1 }
{ type: 'think_chunk', step: 1, delta: '用户想要...' }
{ type: 'think_chunk', step: 1, delta: '我应该先...' }
{ type: 'think_chunk_end', step: 1 }
```

#### Frontend 显示

```typescript
// 可以添加"思考中"的 UI
<div className="thinking-indicator">
  <span>AI 思考中...</span>
  <div className="thinking-text">{thinkingText}</div>
</div>
```

## 5. 特殊场景映射

### 5.1 并发工具调用

#### Kode-SDK 事件

```typescript
// 同时发起 3 个工具调用
{ type: 'tool:start', call: { id: 'tool_1', name: 'fs_read' } }
{ type: 'tool:start', call: { id: 'tool_2', name: 'fs_glob' } }
{ type: 'tool:start', call: { id: 'tool_3', name: 'bash_run' } }

// 按完成顺序返回
{ type: 'tool:end', call: { id: 'tool_2', result: [...] } }
{ type: 'tool:end', call: { id: 'tool_1', result: '...' } }
{ type: 'tool:end', call: { id: 'tool_3', result: {...} } }
```

#### Frontend 处理

```typescript
// 使用 Map 跟踪多个工具调用
const toolCalls = new Map<string, ToolCallUI>();

onToolStart((call) => {
  toolCalls.set(call.id, {
    id: call.id,
    name: call.name,
    status: 'executing',
    startedAt: Date.now()
  });
  ui.renderToolCard(call.id);
});

onToolEnd((call) => {
  const toolUI = toolCalls.get(call.id);
  if (toolUI) {
    toolUI.status = 'completed';
    toolUI.result = call.result;
    ui.updateToolCard(call.id, toolUI);
  }
});
```

#### 前端渲染

```typescript
// 显示多个工具执行卡片
<div className="tool-calls-container">
  <ObservationPairEventMessage event={tool1} />
  <ObservationPairEventMessage event={tool2} />
  <ObservationPairEventMessage event={tool3} />
</div>
```

### 5.2 审批流程

#### Kode-SDK Control 事件

```typescript
{
  type: 'permission_required',
  channel: 'control',
  call: {
    id: 'tool_dangerous',
    name: 'bash_run',
    state: 'APPROVAL_REQUIRED',
    inputPreview: { command: 'rm -rf /tmp/*' },
    approval: {
      required: true,
      meta: { risk: 'high' }
    }
  },
  respond: async (decision, opts) => { ... }
}
```

#### Frontend UI 流程

```typescript
// 1. 接收审批请求
socket.on('approval_required', ({ callId, toolName, input, meta }) => {
  showApprovalDialog({
    callId,
    title: `Approve ${toolName}?`,
    input: input,
    risk: meta.risk,
    onApprove: (note) => {
      socket.emit('approve', { callId, decision: 'allow', note });
      closeDialog();
    },
    onDeny: (note) => {
      socket.emit('approve', { callId, decision: 'deny', note });
      closeDialog();
    }
  });
});

// 2. 显示审批状态
<div className="approval-status">
  <span className="risk-badge risk-high">High Risk</span>
  <div>Tool: bash_run</div>
  <div>Command: rm -rf /tmp/*</div>
  <button onClick={handleApprove}>Approve</button>
  <button onClick={handleDeny}>Deny</button>
</div>
```

#### 审批结果事件

```typescript
// Kode-SDK
{
  type: 'permission_decided',
  channel: 'control',
  callId: 'tool_dangerous',
  decision: 'allow',
  decidedBy: 'user123',
  note: 'Reviewed and approved'
}

// Frontend 显示
<div className="approval-result">
  ✅ Approved by user123
  <span>Note: Reviewed and approved</span>
</div>
```

## 3. 工具类型映射

### 3.1 文件系统工具

| Kode Tool | Frontend Action | Frontend Observation | 特殊处理 |
|-----------|----------------|---------------------|---------|
| `fs_read` | `call_tool_mcp` | `mcp` | 大文件截断 |
| `fs_write` | `call_tool_mcp` | `mcp` | 显示写入路径 |
| `fs_edit` | `call_tool_mcp` | `edit` | 显示 diff |
| `fs_glob` | `call_tool_mcp` | `mcp` | 列表渲染 |
| `fs_grep` | `call_tool_mcp` | `mcp` | 高亮匹配 |

#### fs_read 示例

```typescript
// Kode-SDK
{
  type: 'tool:end',
  call: {
    name: 'fs_read',
    result: '# README\n\nContent...',
    durationMs: 10
  }
}

// Frontend
{
  observation: 'read',
  content: '```\n# README\n\nContent...\n```',
  extras: {
    path: 'README.md'
  }
}

// 渲染为
<GenericEventMessage
  title={<Trans i18nKey="OBSERVATION_MESSAGE$READ" values={{ path: 'README.md' }} />}
  details={'```\n# README\n\nContent...\n```'}
  success="success"
/>
```

#### fs_edit 示例

```typescript
// Kode-SDK
{
  type: 'tool:end',
  call: {
    name: 'fs_edit',
    result: {
      success: true,
      diff: '--- a/file.ts\n+++ b/file.ts\n...'
    }
  }
}

// Frontend
{
  observation: 'edit',
  content: 'Edit completed',
  extras: {
    path: 'file.ts',
    diff: '--- a/file.ts\n+++ b/file.ts\n...'
  }
}

// 渲染
<GenericEventMessage
  title="EDIT: file.ts"
  details={'```diff\n' + diff + '\n```'}
  success="success"
/>
```

### 3.2 命令执行工具

| Kode Tool | Frontend Action | Frontend Observation |
|-----------|----------------|---------------------|
| `bash_run` | `call_tool_mcp` / `run` | `run` / `mcp` |
| `bash_logs` | `call_tool_mcp` | `mcp` |
| `bash_kill` | `call_tool_mcp` | `mcp` |

#### bash_run 示例

```typescript
// Kode-SDK
{
  type: 'tool:end',
  call: {
    name: 'bash_run',
    result: {
      stdout: 'Hello World\n',
      stderr: '',
      exitCode: 0
    },
    durationMs: 250
  }
}

// Frontend
{
  observation: 'run',
  content: 'Hello World\n',
  extras: {
    command: 'echo "Hello World"',
    exitCode: 0,
    duration: 250
  }
}

// 渲染
<GenericEventMessage
  title={<Trans i18nKey="OBSERVATION_MESSAGE$RUN" values={{ command: 'echo ...' }} />}
  details={'Output:\n```sh\nHello World\n```'}
  success="success"
/>
```

### 3.3 Todo 工具

| Kode Tool | Frontend 处理 |
|-----------|--------------|
| `todo_read` | 特殊：显示 Todo 列表 |
| `todo_write` | 特殊：更新 Todo 列表 |

#### todo_read 示例

```typescript
// Kode-SDK
{
  type: 'tool:end',
  call: {
    name: 'todo_read',
    result: [
      { id: '1', title: '实现登录', status: 'done' },
      { id: '2', title: '优化性能', status: 'in_progress' }
    ]
  }
}

// Frontend 可以渲染为特殊的 Todo 列表组件
<TodoListDisplay todos={result} />
```

## 4. 错误处理映射

### 4.1 工具执行错误

#### Kode-SDK

```typescript
{
  type: 'tool:error',
  call: {
    id: 'tool_err',
    name: 'fs_read',
    state: 'FAILED',
    error: 'ENOENT: no such file or directory',
    isError: true
  }
}
```

#### Frontend

```typescript
{
  observation: 'error',
  content: 'ENOENT: no such file or directory',
  extras: {
    name: 'fs_read',
    arguments: { path: '/nonexistent' }
  }
}

// 渲染
<ErrorEventMessage event={errorEvent} />
  ↓
<div className="error-message">
  ❌ Error: fs_read failed
  <div>ENOENT: no such file or directory</div>
</div>
```

### 4.2 模型错误

#### Kode-SDK Monitor 事件

```typescript
{
  type: 'error',
  channel: 'monitor',
  severity: 'error',
  phase: 'model',
  message: 'API rate limit exceeded',
  detail: { status: 429, retryAfter: 60 }
}
```

#### Frontend 处理

```typescript
// 使用 ErrorMessageBanner
useErrorMessageStore.getState().setErrorMessage({
  message: 'API rate limit exceeded. Please try again in 1 minute.',
  detail: event.detail
});

// 渲染
<ErrorMessageBanner message={errorMessage} />
```

## 5. 状态映射

### 5.1 Agent 状态

| Kode State | Frontend UI | 说明 |
|-----------|------------|------|
| `READY` | 待机状态 | 可以发送消息 |
| `WORKING` | 加载中 | 显示 TypingIndicator |
| `PAUSED` | 暂停 | 显示"已暂停" |

#### Monitor 事件

```typescript
{
  type: 'state_changed',
  channel: 'monitor',
  state: 'WORKING'
}
```

#### Frontend 更新

```typescript
<div className="agent-status">
  {state === 'WORKING' && <TypingIndicator />}
  {state === 'PAUSED' && <div>⏸️ Paused</div>}
  {state === 'READY' && <div>✅ Ready</div>}
</div>
```

### 5.2 工具状态

| Kode ToolCallState | Frontend 显示 |
|-------------------|--------------|
| `PENDING` | ⏳ 等待执行 |
| `EXECUTING` | 🔄 执行中... |
| `COMPLETED` | ✅ 完成 |
| `FAILED` | ❌ 失败 |
| `APPROVAL_REQUIRED` | ⚠️ 需要审批 |
| `DENIED` | 🚫 已拒绝 |

## 6. 组件对应关系

### 6.1 Frontend 组件 → Kode 事件

| Frontend 组件 | 处理的 Kode 事件 | 说明 |
|--------------|-----------------|------|
| `ChatInterface` | `done`, `state_changed` | 主界面控制 |
| `Messages` | 所有 Progress 事件 | 消息列表渲染 |
| `EventMessage` | 所有事件 | 事件分发器 |
| `UserAssistantEventMessage` | `text_chunk_end` | 文本消息 |
| `ObservationPairEventMessage` | `tool:start` | 工具调用（Action） |
| `McpEventMessage` | `tool:end` | MCP 工具结果 |
| `GenericEventMessage` | 其他所有事件 | 通用事件显示 |
| `MCPObservationContent` | `tool:end` (MCP) | 工具参数和结果 |
| `TypingIndicator` | `text_chunk_start` | 输入中指示器 |
| `ErrorMessageBanner` | `error` | 错误提示 |

### 6.2 事件到组件的决策树

```
收到 Kode 事件
  ↓
是 text_chunk?
  → 是 → TextAccumulator → UserAssistantEventMessage
  ↓
是 tool:start?
  → 是 → ObservationPairEventMessage
  ↓
是 tool:end?
  → 是 → 工具类型?
      → MCP → McpEventMessage
      → 其他 → GenericEventMessage
  ↓
是 error?
  → 是 → ErrorEventMessage
  ↓
是 done?
  → 是 → 更新对话状态
  ↓
其他
  → GenericEventMessage (兜底)
```

## 7. 实现检查清单

### 7.1 后端实现

- [ ] Agent 创建和管理
- [ ] MessageQueue 集成
- [ ] Progress 事件订阅
- [ ] Control 事件监听（审批）
- [ ] Monitor 事件监听（日志）
- [ ] SSE/WebSocket 实现
- [ ] 事件格式转换
- [ ] 消息持久化
- [ ] 断点续播支持

### 7.2 前端实现

- [ ] SSE/WebSocket 客户端
- [ ] 事件 Store 集成
- [ ] TextAccumulator 实现
- [ ] 工具调用 UI
- [ ] 审批对话框
- [ ] 错误处理
- [ ] 历史消息加载
- [ ] 断点恢复

### 7.3 测试验证

- [ ] 纯文本对话
- [ ] 单个工具调用
- [ ] 并发工具调用
- [ ] 工具执行失败
- [ ] 人工审批流程
- [ ] 断线重连
- [ ] 历史消息加载
- [ ] 多用户隔离

## 8. 转换函数参考实现

### 8.1 后端转换器

```typescript
// adapters/kode-to-frontend.ts

export class KodeToFrontendAdapter {
  
  convertProgressEvent(envelope: AgentEventEnvelope<ProgressEvent>) {
    const { event } = envelope;
    
    switch (event.type) {
      case 'text_chunk':
        return {
          type: 'assistant_message_delta',
          data: {
            delta: event.delta,
            step: event.step
          }
        };
        
      case 'text_chunk_end':
        return {
          type: 'assistant_message_completed',
          data: {
            content: event.text,
            step: event.step
          }
        };
        
      case 'tool:start':
        return {
          type: 'tool_call_started',
          data: {
            id: event.call.id,
            name: event.call.name,
            input: event.call.inputPreview,
            state: event.call.state
          }
        };
        
      case 'tool:end':
        return {
          type: 'tool_call_completed',
          data: {
            id: event.call.id,
            name: event.call.name,
            result: event.call.result,
            error: event.call.error,
            isError: event.call.isError,
            duration: event.call.durationMs
          }
        };
        
      case 'done':
        return {
          type: 'conversation_completed',
          data: {
            step: event.step,
            reason: event.reason,
            bookmark: envelope.bookmark
          }
        };
        
      default:
        return null;
    }
  }
  
  convertMessage(kodeMessage: Message) {
    const events: any[] = [];
    
    kodeMessage.content.forEach(block => {
      if (block.type === 'text') {
        events.push({
          action: 'message',
          source: kodeMessage.role === 'user' ? 'user' : 'agent',
          args: { content: block.text }
        });
      }
      
      if (block.type === 'tool_use') {
        events.push({
          action: 'call_tool_mcp',
          source: 'agent',
          id: block.id,
          args: {
            name: block.name,
            arguments: block.input
          }
        });
      }
      
      if (block.type === 'tool_result') {
        events.push({
          observation: 'mcp',
          source: 'agent',
          content: typeof block.content === 'string' 
            ? block.content 
            : JSON.stringify(block.content),
          extras: {
            tool_use_id: block.tool_use_id,
            is_error: block.is_error
          }
        });
      }
    });
    
    return events;
  }
}
```

### 8.2 前端转换器

```typescript
// utils/event-converter.ts

export class FrontendEventConverter {
  
  private textAccumulator = new Map<number, string>();
  
  handleKodeEvent(envelope: any, eventStore: any) {
    const { event } = envelope;
    
    switch (event.type) {
      case 'text_chunk_start':
        this.textAccumulator.set(event.step, '');
        eventStore.startMessage({ role: 'assistant' });
        break;
        
      case 'text_chunk':
        const current = this.textAccumulator.get(event.step) || '';
        this.textAccumulator.set(event.step, current + event.delta);
        eventStore.updateCurrentMessage({
          content: this.textAccumulator.get(event.step)
        });
        break;
        
      case 'text_chunk_end':
        eventStore.finalizeMessage({
          action: 'message',
          source: 'agent',
          args: { content: event.text }
        });
        this.textAccumulator.delete(event.step);
        break;
        
      case 'tool:start':
        eventStore.addEvent({
          action: 'call_tool_mcp',
          source: 'agent',
          id: event.call.id,
          args: {
            name: event.call.name,
            arguments: event.call.inputPreview
          }
        });
        break;
        
      case 'tool:end':
        eventStore.addEvent({
          observation: 'mcp',
          source: 'agent',
          content: JSON.stringify(event.call.result),
          extras: {
            name: event.call.name,
            arguments: event.call.inputPreview,
            duration: event.call.durationMs
          }
        });
        break;
        
      case 'done':
        eventStore.setLastBookmark(envelope.bookmark.seq);
        eventStore.markConversationComplete();
        break;
    }
  }
}
```

## 9. 完整示例：端到端流程

### 9.1 用户发送 "读取 README.md"

```typescript
// 1. 前端发送
handleSendMessage('读取 README.md');
  ↓
POST /api/conversations/conv_1/messages
  { content: '读取 README.md' }

// 2. 后端处理
await agent.send('读取 README.md');
  ↓
MessageQueue.send('读取 README.md', { kind: 'user' })
  ↓
Agent.processLoop()

// 3. 模型响应
Model returns:
{
  role: 'assistant',
  content: [
    { type: 'text', text: '好的，我来读取文件' },
    { type: 'tool_use', id: 'tool_1', name: 'fs_read', input: { path: 'README.md' } }
  ]
}

// 4. 事件流
[text_chunk_start]
[text_chunk] "好"
[text_chunk] "的"
[text_chunk] "，"
[text_chunk] "我"
[text_chunk] "来"
[text_chunk] "读"
[text_chunk] "取"
[text_chunk] "文"
[text_chunk] "件"
[text_chunk_end] "好的，我来读取文件"
[tool:start] { call: { name: 'fs_read', ... } }
[tool:end] { call: { result: '# README...', ... } }
[text_chunk_start]
[text_chunk] "文"
[text_chunk] "件"
[text_chunk] "内"
[text_chunk] "容"
[text_chunk] "如"
[text_chunk] "下"
[text_chunk] "："
[text_chunk_end] "文件内容如下："
[done]

// 5. 前端接收和渲染
EventSource receives events
  ↓
TextAccumulator accumulates text
  ↓
UI updates in real-time:
  - "好的，我来读取文件" (UserAssistantEventMessage)
  - [Tool Executing: fs_read] (ObservationPairEventMessage)
  - [Tool Result: # README...] (McpEventMessage)
  - "文件内容如下：" (UserAssistantEventMessage)
  ↓
Conversation marked complete
```

## 总结

本对照表提供了所有关键映射关系的快速参考：

✅ **消息格式**: Kode Message ↔ Frontend Event  
✅ **事件类型**: Progress/Control/Monitor ↔ UI 组件  
✅ **工具调用**: tool:start/end ↔ ObservationPair/Mcp  
✅ **错误处理**: error 事件 ↔ ErrorMessage 组件  
✅ **状态同步**: Agent state ↔ UI state  

**开发建议**: 将本文档作为实现时的速查手册，配合详细文档深入理解。

