# Kode-SDK 事件流系统详解

## 1. 三通道设计理念

Kode-SDK 采用"默认只推必要事件，其余一律走回调"的设计理念，将所有交互拆分为三个独立通道：

```
┌─────────────────────────────────────────────────────┐
│              Progress Channel（进度通道）             │
│  → UI 渲染、文本流、工具执行状态                       │
│  → 前端订阅，实时更新界面                             │
└─────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────┐
│              Control Channel（控制通道）              │
│  → 人工审批、权限决策                                 │
│  → 后端监听，处理审批逻辑                             │
└─────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────┐
│              Monitor Channel（监控通道）              │
│  → 系统监控、审计、告警                               │
│  → 运维系统订阅，记录日志和指标                       │
└─────────────────────────────────────────────────────┘
```

## 2. Progress 通道（数据面）

### 2.1 事件类型清单

**位置**: `Kode-sdk/src/core/types.ts` (84-169行)

| 事件类型 | 触发时机 | 数据结构 | 用途 |
|---------|---------|---------|------|
| `think_chunk_start` | 思考阶段开始 | `{ step: number }` | 可选，需开启 `exposeThinking` |
| `think_chunk` | 思考内容流式输出 | `{ step, delta: string }` | 展示 AI 思考过程 |
| `think_chunk_end` | 思考阶段结束 | `{ step }` | 标记思考完成 |
| `text_chunk_start` | 文本输出开始 | `{ step }` | 准备接收文本流 |
| `text_chunk` | 文本增量输出 | `{ step, delta: string }` | **核心**：流式文本 |
| `text_chunk_end` | 文本输出完成 | `{ step, text: string }` | 完整文本内容 |
| `tool:start` | 工具开始执行 | `{ call: ToolCallSnapshot }` | **核心**：显示工具调用 |
| `tool:end` | 工具执行完成 | `{ call: ToolCallSnapshot }` | **核心**：显示工具结果 |
| `tool:error` | 工具执行失败 | `{ call, error: string }` | 显示错误信息 |
| `done` | 本轮对话完成 | `{ step, reason, bookmark }` | **核心**：结束标记 |

### 2.2 ToolCallSnapshot 结构

```typescript
export type ToolCallSnapshot = Pick<
  ToolCallRecord,
  'id' | 'name' | 'state' | 'approval' | 'result' | 'error' | 
  'isError' | 'durationMs' | 'startedAt' | 'completedAt'
> & {
  inputPreview?: any;        // 输入参数预览
  auditTrail?: ToolCallAuditEntry[];  // 审计轨迹
};

// 状态枚举
type ToolCallState = 
  | 'PENDING'         // 等待执行
  | 'APPROVAL_REQUIRED' // 需要审批
  | 'APPROVED'        // 已批准
  | 'EXECUTING'       // 执行中
  | 'COMPLETED'       // 已完成
  | 'FAILED'          // 失败
  | 'DENIED'          // 被拒绝
  | 'SEALED';         // 已封口（Resume 时处理）
```

### 2.3 典型事件流序列

#### 场景1: 纯文本对话

```
用户: "你好"
  ↓
[text_chunk_start] { step: 1 }
[text_chunk] { step: 1, delta: "你" }
[text_chunk] { step: 1, delta: "好" }
[text_chunk] { step: 1, delta: "！" }
[text_chunk] { step: 1, delta: "我是" }
[text_chunk] { step: 1, delta: "AI助手" }
[text_chunk_end] { step: 1, text: "你好！我是AI助手" }
[done] { step: 1, reason: "completed", bookmark: { seq: 15, timestamp: ... } }
```

#### 场景2: 包含工具调用

```
用户: "读取 README.md 文件"
  ↓
[text_chunk_start] { step: 2 }
[text_chunk] { step: 2, delta: "好的" }
[text_chunk] { step: 2, delta: "，我来" }
[text_chunk] { step: 2, delta: "读取文件" }
[text_chunk_end] { step: 2, text: "好的，我来读取文件" }
  ↓
[tool:start] { 
  call: {
    id: "tool_abc123",
    name: "fs_read",
    state: "EXECUTING",
    inputPreview: { path: "README.md" }
  }
}
  ↓
[tool:end] { 
  call: {
    id: "tool_abc123",
    name: "fs_read",
    state: "COMPLETED",
    result: "# My Project\n...",
    durationMs: 15
  }
}
  ↓
[text_chunk_start] { step: 2 }
[text_chunk] { step: 2, delta: "文件内容如下" }
[text_chunk] { step: 2, delta: "：\n\n" }
[text_chunk] { step: 2, delta: "# My Project..." }
[text_chunk_end] { step: 2, text: "文件内容如下：\n\n# My Project..." }
  ↓
[done] { step: 2, reason: "completed", bookmark: { seq: 28, timestamp: ... } }
```

#### 场景3: 并发工具调用

```
[tool:start] { call: { id: "tool_1", name: "fs_read", ... } }
[tool:start] { call: { id: "tool_2", name: "fs_glob", ... } }
[tool:start] { call: { id: "tool_3", name: "bash_run", ... } }
  ↓ (并发执行，完成顺序不定)
[tool:end] { call: { id: "tool_2", state: "COMPLETED", ... } }
[tool:end] { call: { id: "tool_1", state: "COMPLETED", ... } }
[tool:end] { call: { id: "tool_3", state: "COMPLETED", ... } }
```

### 2.4 前端订阅示例

```typescript
// 订阅 Progress 事件
for await (const envelope of agent.subscribe(['progress'])) {
  const { event, cursor, bookmark } = envelope;
  
  switch (event.type) {
    case 'text_chunk_start':
      // 创建新的消息 bubble
      ui.createMessageBubble({ role: 'assistant' });
      break;
      
    case 'text_chunk':
      // 追加文本增量
      ui.appendText(event.delta);
      break;
      
    case 'text_chunk_end':
      // 标记文本完成
      ui.finalizeText(event.text);
      break;
      
    case 'tool:start':
      // 显示工具执行中的 UI
      ui.showToolExecution({
        id: event.call.id,
        name: event.call.name,
        input: event.call.inputPreview,
        status: 'executing'
      });
      break;
      
    case 'tool:end':
      // 更新工具结果
      ui.updateToolExecution({
        id: event.call.id,
        result: event.call.result,
        error: event.call.error,
        isError: event.call.isError,
        duration: event.call.durationMs,
        status: event.call.state === 'COMPLETED' ? 'success' : 'failed'
      });
      break;
      
    case 'done':
      // 保存 bookmark 用于断点续播
      localStorage.setItem('lastBookmark', JSON.stringify(bookmark));
      ui.markConversationComplete();
      break;
  }
}
```

## 3. Control 通道（审批面）

### 3.1 事件类型

| 事件类型 | 数据结构 | 说明 |
|---------|---------|------|
| `permission_required` | `{ call: ToolCallSnapshot, respond: Function }` | 需要人工审批 |
| `permission_decided` | `{ callId, decision, decidedBy, note }` | 审批结果广播 |

### 3.2 权限审批流程

```typescript
// 1. 监听审批请求
agent.on('permission_required', async (event: ControlPermissionRequiredEvent) => {
  const { call, respond } = event;
  
  // 选项1: 立即决策（基于规则）
  if (isLowRiskTool(call.name)) {
    await respond('allow', { note: 'Auto-approved: low risk' });
    return;
  }
  
  // 选项2: 保存到审批队列，等待用户决策
  const ticketId = await approvalStore.create({
    agentId: agent.agentId,
    callId: call.id,
    toolName: call.name,
    toolInput: call.inputPreview,
    requestedAt: Date.now()
  });
  
  console.log(`Approval pending: ${ticketId}`);
  // 暂不调用 respond，等待用户通过 UI 决策
});

// 2. 用户在 UI 中审批后
async function handleUserApproval(ticketId: string, decision: 'allow' | 'deny') {
  const ticket = await approvalStore.get(ticketId);
  
  // 调用 Agent 的 decide 方法
  await agent.decide(ticket.callId, decision, { 
    note: `User ${userId} ${decision === 'allow' ? 'approved' : 'denied'}` 
  });
}

// 3. 监听审批结果广播
agent.on('permission_decided', (event: ControlPermissionDecidedEvent) => {
  console.log(`Tool ${event.callId} ${event.decision} by ${event.decidedBy}`);
  
  // 记录审计日志
  auditLog.record({
    action: 'tool_permission',
    callId: event.callId,
    decision: event.decision,
    decidedBy: event.decidedBy,
    note: event.note,
    timestamp: Date.now()
  });
});
```

### 3.3 权限配置模式

```typescript
// 在 Template 中配置
{
  id: 'my-assistant',
  permission: {
    mode: 'ask',  // 'auto' | 'ask' | 'deny' | 'custom'
    requireApprovalTools: ['bash_run', 'fs_write', 'fs_edit'],
    autoAllowTools: ['fs_read', 'fs_glob'],
  }
}

// 或在 Hook 中自定义
{
  hooks: {
    async preToolUse(call, agent) {
      // 自定义审批逻辑
      if (call.name === 'bash_run' && call.input.command.includes('rm -rf')) {
        return { decision: 'ask', meta: { risk: 'high' } };
      }
      return; // 继续默认流程
    }
  }
}
```

## 4. Monitor 通道（治理面）

### 4.1 事件类型清单

| 事件类型 | 触发时机 | 用途 |
|---------|---------|------|
| `state_changed` | Agent 状态切换 | 监控 Agent 生命周期 |
| `step_complete` | 每轮对话完成 | 性能统计 |
| `error` | 发生错误 | 告警和调试 |
| `token_usage` | 模型调用后 | Token 消耗统计 |
| `tool_executed` | 工具执行完成 | 审计和性能分析 |
| `agent_resumed` | Resume 完成 | 断点恢复监控 |
| `breakpoint_changed` | 断点状态变化 | 调试 Agent 卡顿 |
| `todo_changed` | Todo 列表变化 | 任务追踪 |
| `file_changed` | 文件系统变化 | 自动触发任务 |
| `context_compression` | 上下文压缩 | 性能优化监控 |
| `tool_manual_updated` | 工具说明书更新 | 动态能力变更 |
| `tool_custom_event` | 工具自定义事件 | 工具内部状态通知 |

### 4.2 错误事件结构

```typescript
export interface MonitorErrorEvent {
  channel: 'monitor';
  type: 'error';
  severity: 'info' | 'warn' | 'error';  // 严重等级
  phase: 'model' | 'tool' | 'system' | 'lifecycle';  // 错误阶段
  message: string;
  detail?: any;  // 详细错误信息
  bookmark?: Bookmark;
}
```

### 4.3 监控实践示例

```typescript
// 1. 性能监控
agent.on('tool_executed', (event: MonitorToolExecutedEvent) => {
  metrics.recordToolExecution({
    agentId: agent.agentId,
    toolName: event.call.name,
    durationMs: event.call.durationMs,
    success: event.call.state === 'COMPLETED',
    timestamp: Date.now()
  });
  
  // 慢查询告警
  if (event.call.durationMs > 5000) {
    alerting.warn(`Slow tool execution: ${event.call.name} took ${event.call.durationMs}ms`);
  }
});

// 2. 错误告警
agent.on('error', (event: MonitorErrorEvent) => {
  const logLevel = {
    'info': 'log',
    'warn': 'warn',
    'error': 'error'
  }[event.severity];
  
  console[logLevel](`[${event.phase}] ${event.message}`, event.detail);
  
  if (event.severity === 'error') {
    alerting.error({
      title: `Agent ${agent.agentId} Error`,
      phase: event.phase,
      message: event.message,
      detail: event.detail
    });
  }
});

// 3. Token 使用统计
agent.on('token_usage', (event: MonitorTokenUsageEvent) => {
  metrics.recordTokenUsage({
    agentId: agent.agentId,
    inputTokens: event.inputTokens,
    outputTokens: event.outputTokens,
    totalTokens: event.totalTokens,
    cost: calculateCost(event.totalTokens)
  });
});

// 4. 文件变更触发任务
agent.on('file_changed', (event: MonitorFileChangedEvent) => {
  console.log(`File changed: ${event.path} at ${new Date(event.mtime)}`);
  
  // 自动触发相关任务
  if (event.path.endsWith('.ts')) {
    agent.remind('检测到 TypeScript 文件变更，建议运行类型检查', {
      category: 'file'
    });
  }
});

// 5. Agent 恢复监控
agent.on('agent_resumed', (event: MonitorAgentResumedEvent) => {
  console.log(`Agent resumed via ${event.strategy}`);
  console.log(`Sealed ${event.sealed.length} pending tool calls:`, event.sealed);
  
  // 记录审计日志
  auditLog.record({
    action: 'agent_resumed',
    agentId: agent.agentId,
    strategy: event.strategy,
    sealedCalls: event.sealed.map(c => c.id)
  });
});
```

## 5. 事件订阅机制

### 5.1 AsyncIterable 订阅（流式）

```typescript
// 订阅单个通道
const progressStream = agent.subscribe(['progress'], {
  since: lastBookmark,  // 断点续播
  kinds: ['text_chunk', 'tool:start', 'tool:end', 'done']  // 过滤事件类型
});

for await (const envelope of progressStream) {
  console.log(envelope.event);
}

// 订阅多个通道
const allEvents = agent.subscribe(['progress', 'control', 'monitor']);

for await (const envelope of allEvents) {
  // 处理所有事件
}
```

### 5.2 回调式监听（精确控制）

```typescript
// 监听特定事件类型
const unsubscribe1 = agent.on('permission_required', handleApproval);
const unsubscribe2 = agent.on('tool_executed', recordMetrics);
const unsubscribe3 = agent.on('error', handleError);

// 清理监听器
function cleanup() {
  unsubscribe1();
  unsubscribe2();
  unsubscribe3();
}
```

### 5.3 断点续播机制

```typescript
// 获取最后的 bookmark
const lastBookmark = agent.events.getLastBookmark();
// { seq: 42, timestamp: 1234567890 }

// 从某个 bookmark 开始订阅（不会遗漏任何事件）
for await (const envelope of agent.subscribe(['progress'], { since: lastBookmark })) {
  // 只接收 seq > 42 的事件
}

// 或使用 cursor（基于位置）
const cursor = agent.events.getCursor(); // 返回当前位置

// 获取特定 cursor 之后的历史事件
const timeline = agent.events.getTimeline(cursor);
```

## 6. 事件持久化策略

### 6.1 关键事件自动持久化

以下事件类型会自动写入 Store（用于审计和恢复）：

```typescript
const criticalTypes = new Set([
  'tool:end',           // 工具执行完成
  'done',              // 对话完成
  'permission_decided', // 审批决策
  'agent_resumed',     // Agent 恢复
  'state_changed',     // 状态变化
  'breakpoint_changed',// 断点变化
  'error',            // 错误事件
]);
```

### 6.2 失败重试机制

```typescript
// EventBus 内部实现
if (this.store && this.agentId) {
  const isCritical = this.isCriticalEvent(event);
  
  this.store.appendEvent(this.agentId, timelineEntry)
    .catch((err) => {
      if (isCritical) {
        // 关键事件失败：缓存到内存
        this.failedEvents.push(timelineEntry);
        
        // 发送降级的 Monitor 事件
        this.monitorEmitter.emit('storage_failure', {
          type: 'storage_failure',
          severity: 'critical',
          failedEvent: event.type,
          bufferedCount: this.failedEvents.length
        });
      } else {
        // 非关键事件：仅记录日志
        console.warn(`Failed to persist non-critical event: ${event.type}`);
      }
    });
}

// 成功后自动重试失败的事件
if (this.failedEvents.length > 0) {
  void this.retryFailedEvents();
}
```

## 7. 事件流在前后端对接中的应用

### 7.1 HTTP/SSE 转换

```typescript
// Express/Koa 示例
app.get('/api/chat/:agentId/stream', async (req, res) => {
  const { agentId } = req.params;
  const { since } = req.query;
  
  // 设置 SSE headers
  res.setHeader('Content-Type', 'text/event-stream');
  res.setHeader('Cache-Control', 'no-cache');
  res.setHeader('Connection', 'keep-alive');
  
  const bookmark = since ? JSON.parse(since) : undefined;
  const agent = await getOrCreateAgent(agentId);
  
  // 订阅事件并转发
  const iterator = agent.subscribe(['progress', 'monitor'], { 
    since: bookmark 
  })[Symbol.asyncIterator]();
  
  try {
    for await (const envelope of { [Symbol.asyncIterator]: () => iterator }) {
      // 转换为 SSE 格式
      res.write(`event: ${envelope.event.type}\n`);
      res.write(`data: ${JSON.stringify(envelope)}\n\n`);
      
      if (envelope.event.type === 'done') {
        res.end();
        break;
      }
    }
  } catch (error) {
    res.write(`event: error\n`);
    res.write(`data: ${JSON.stringify({ error: error.message })}\n\n`);
    res.end();
  }
  
  // 客户端断开时清理
  req.on('close', () => {
    iterator.return?.();
  });
});
```

### 7.2 WebSocket 转换

```typescript
// WebSocket 服务器
io.on('connection', (socket) => {
  let unsubscribe: (() => void)[] = [];
  
  socket.on('subscribe', async ({ agentId, channels, since }) => {
    const agent = await getOrCreateAgent(agentId);
    
    // 订阅并推送
    const iterator = agent.subscribe(channels, { since })[Symbol.asyncIterator]();
    
    (async () => {
      for await (const envelope of { [Symbol.asyncIterator]: () => iterator }) {
        socket.emit('event', envelope);
        
        if (envelope.event.type === 'done') {
          break;
        }
      }
    })();
    
    // 监听 Control 事件
    const off1 = agent.on('permission_required', (event) => {
      socket.emit('approval_required', {
        callId: event.call.id,
        toolName: event.call.name,
        input: event.call.inputPreview
      });
    });
    
    unsubscribe.push(off1, () => iterator.return?.());
  });
  
  socket.on('approve', async ({ agentId, callId, decision, note }) => {
    const agent = await getAgent(agentId);
    await agent.decide(callId, decision, { note });
  });
  
  socket.on('disconnect', () => {
    unsubscribe.forEach(fn => fn());
  });
});
```

## 8. 最佳实践和常见陷阱

### 8.1 最佳实践

1. **Progress 用于 UI 更新**
   - 只订阅必要的事件类型（`kinds` 过滤）
   - 及时保存 `bookmark`，支持断线重连
   - `done` 事件必须处理，否则前端会一直等待

2. **Control 用于审批流程**
   - 必须处理 `permission_required`，否则工具卡在 `AWAITING_APPROVAL`
   - `respond()` 只能调用一次
   - Resume 后重新绑定监听器

3. **Monitor 用于运维治理**
   - 区分 `severity` 等级，避免噪音
   - 关键指标持久化到时序数据库
   - 错误事件触发告警

### 8.2 常见陷阱

1. **忘记消费 `done` 事件**
   ```typescript
   // ❌ 错误：缺少 done 处理
   for await (const e of agent.subscribe(['progress'])) {
     if (e.event.type === 'text_chunk') {
       ui.append(e.event.delta);
     }
   }
   
   // ✅ 正确
   for await (const e of agent.subscribe(['progress'])) {
     if (e.event.type === 'text_chunk') {
       ui.append(e.event.delta);
     }
     if (e.event.type === 'done') {
       lastBookmark = e.bookmark;
       break;  // 重要：跳出循环
     }
   }
   ```

2. **在 Progress 中做业务判断**
   ```typescript
   // ❌ 错误：Progress 只负责展示
   for await (const e of agent.subscribe(['progress'])) {
     if (e.event.type === 'tool:start' && e.event.call.name === 'dangerous_tool') {
       await blockTool();  // 应该在 Hook 或 Control 中处理
     }
   }
   
   // ✅ 正确：使用 Control 或 Hook
   agent.on('permission_required', async (event) => {
     if (event.call.name === 'dangerous_tool') {
       await event.respond('deny', { note: 'Tool blocked by policy' });
     }
   });
   ```

3. **忘记清理监听器**
   ```typescript
   // ❌ 错误：内存泄漏
   function subscribeEvents(agent) {
     agent.on('tool_executed', handleToolExecution);
   }
   
   // ✅ 正确
   function subscribeEvents(agent) {
     const unsubscribe = agent.on('tool_executed', handleToolExecution);
     return unsubscribe;  // 返回清理函数
   }
   ```

## 9. 调试技巧

### 9.1 查看事件时间线

```typescript
// 获取所有事件历史
const timeline = agent.events.getTimeline();
console.table(timeline.map(t => ({
  cursor: t.cursor,
  seq: t.bookmark.seq,
  type: t.event.type,
  channel: t.event.channel
})));

// 获取特定 cursor 之后的事件
const recent = agent.events.getTimeline(100);
```

### 9.2 监控 Agent 状态

```typescript
const status = agent.status();
console.log({
  agentId: status.agentId,
  state: status.state,           // READY/WORKING/PAUSED
  stepCount: status.stepCount,   // 对话轮数
  cursor: status.cursor,          // 当前事件位置
  breakpoint: status.breakpoint   // 当前断点状态
});

// 断点状态枚举
// 'READY' | 'PRE_MODEL' | 'STREAMING_MODEL' | 'TOOL_PENDING' | 
// 'AWAITING_APPROVAL' | 'PRE_TOOL' | 'TOOL_EXECUTING' | 'POST_TOOL'
```

### 9.3 启用事件日志

```typescript
// 监听所有事件并记录
agent.subscribe(['progress', 'control', 'monitor']).then(async (stream) => {
  for await (const envelope of stream) {
    console.log(`[${envelope.event.channel}] ${envelope.event.type}`, envelope.event);
  }
});
```

## 总结

Kode-SDK 的三通道事件系统提供了：

1. **清晰的关注点分离**：UI、审批、运维各司其职
2. **灵活的订阅方式**：流式（AsyncIterable）和回调式（on）
3. **可靠的断点续播**：基于 bookmark/cursor 的精确恢复
4. **完善的持久化**：关键事件自动保存，失败自动重试
5. **强大的扩展性**：支持自定义事件过滤、转换和路由

这些特性使其非常适合构建实时交互的 AI Agent 应用，并能无缝对接前端对话界面。

