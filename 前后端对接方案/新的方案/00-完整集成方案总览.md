# Kode-SDK 与前端对话界面完整集成方案

## 0. 文档导航

本方案包含以下文档，建议按顺序阅读：

1. **00-完整集成方案总览.md** (当前文档) - 整体架构和快速开始
2. **01-Kode-SDK核心架构分析.md** - SDK 核心组件详解
3. **02-事件流系统详解.md** - Progress/Control/Monitor 三通道
4. **03-工具调用机制详解.md** - 工具定义、执行、Hook 系统
5. **04-API层设计.md** - HTTP/SSE/WebSocket 接口设计
6. **05-前端对话界面对接方案.md** - 与 frontend 组件的集成

## 1. 方案概述

### 1.1 目标

将 **Kode-SDK** (后端 AI Agent 框架) 与 **Frontend 对话界面** (React 组件) 无缝集成，实现：

- ✅ 实时流式对话界面
- ✅ 工具调用可视化
- ✅ 人工审批流程
- ✅ 消息历史持久化
- ✅ 断点续播能力
- ✅ 多用户支持

### 1.2 整体架构

```
┌─────────────────────────────────────────────────────┐
│                 Frontend Layer                       │
│  ┌──────────────────────────────────────────────┐  │
│  │  React Components (ChatInterface, Messages)  │  │
│  │  - UserAssistantEventMessage                 │  │
│  │  - ObservationPairEventMessage               │  │
│  │  - McpEventMessage                           │  │
│  │  - GenericEventMessage                       │  │
│  └──────────────────────────────────────────────┘  │
│                      ↑ ↓                            │
│  ┌──────────────────────────────────────────────┐  │
│  │  Event Store & State Management              │  │
│  │  - useEventStore                             │  │
│  │  - TextAccumulator                           │  │
│  └──────────────────────────────────────────────┘  │
└─────────────────────────────────────────────────────┘
                       ↑ ↓ (SSE/WebSocket)
┌─────────────────────────────────────────────────────┐
│                  API Gateway                         │
│  ┌──────────────────────────────────────────────┐  │
│  │  RESTful Endpoints                           │  │
│  │  - POST /conversations                       │  │
│  │  - POST /conversations/:id/messages          │  │
│  │  - GET  /conversations/:id/messages          │  │
│  └──────────────────────────────────────────────┘  │
│  ┌──────────────────────────────────────────────┐  │
│  │  Event Streaming                             │  │
│  │  - GET /conversations/:id/events (SSE)       │  │
│  │  - WS  /conversations/:id (WebSocket)        │  │
│  └──────────────────────────────────────────────┘  │
│  ┌──────────────────────────────────────────────┐  │
│  │  Event Conversion Layer                      │  │
│  │  - Kode Event → Frontend Event               │  │
│  │  - Message Format Mapping                    │  │
│  └──────────────────────────────────────────────┘  │
└─────────────────────────────────────────────────────┘
                       ↑ ↓ (SDK API)
┌─────────────────────────────────────────────────────┐
│               Kode-SDK Agent Layer                   │
│  ┌──────────────────────────────────────────────┐  │
│  │  Agent                                        │  │
│  │  - MessageQueue (消息队列)                   │  │
│  │  - EventBus (事件总线)                       │  │
│  │  - ToolRunner (工具执行)                     │  │
│  └──────────────────────────────────────────────┘  │
│  ┌──────────────────────────────────────────────┐  │
│  │  Three-Channel Events                        │  │
│  │  - Progress (UI 更新)                        │  │
│  │  - Control (审批决策)                        │  │
│  │  - Monitor (监控审计)                        │  │
│  └──────────────────────────────────────────────┘  │
│  ┌──────────────────────────────────────────────┐  │
│  │  Infrastructure                              │  │
│  │  - Store (持久化)                            │  │
│  │  - Sandbox (执行环境)                        │  │
│  │  - ModelProvider (LLM)                       │  │
│  └──────────────────────────────────────────────┘  │
└─────────────────────────────────────────────────────┘
```

## 2. 核心技术栈

### 2.1 后端

| 组件 | 技术选型 | 说明 |
|-----|---------|------|
| Agent 框架 | Kode-SDK | 事件驱动的 AI Agent 系统 |
| API 服务器 | Express / Fastify | RESTful + SSE |
| 实时通信 | SSE / Socket.IO | 事件流推送 |
| 数据库 | PostgreSQL / SQLite | 消息和会话持久化 |
| 缓存 | Redis (可选) | 会话状态缓存 |
| 认证 | JWT | 用户身份验证 |

### 2.2 前端

| 组件 | 技术选型 | 说明 |
|-----|---------|------|
| UI 框架 | React | frontend 现有技术栈 |
| 状态管理 | Zustand | useEventStore |
| 实时通信 | EventSource / Socket.IO | SSE/WebSocket 客户端 |
| 路由 | React Router | frontend 现有路由 |
| UI 组件 | 现有组件库 | ChatInterface, Messages 等 |

## 3. 数据流详解

### 3.1 用户发送消息流程

```
┌──────┐  1. 用户输入   ┌──────────────┐
│ User │─────────────→│ ChatInterface │
└──────┘              └──────────────┘
                             │
                             │ 2. handleSendMessage()
                             ↓
                      ┌──────────────┐
                      │ POST /messages│
                      └──────────────┘
                             │
                             │ 3. MessageQueue.send()
                             ↓
                      ┌──────────────┐
                      │  Kode Agent  │
                      └──────────────┘
                             │
                             │ 4. processLoop()
                             ↓
                      ┌──────────────┐
                      │ Model (LLM)  │
                      └──────────────┘
                             │
                             │ 5. Streaming Response
                             ↓
┌──────────────────────────────────────────┐
│          Progress Events                 │
│  - text_chunk (流式文本)                  │
│  - tool:start (工具开始)                  │
│  - tool:end (工具完成)                    │
│  - done (对话结束)                        │
└──────────────────────────────────────────┘
                             │
                             │ 6. SSE Stream
                             ↓
                      ┌──────────────┐
                      │ Event Handler│
                      └──────────────┘
                             │
                             │ 7. Update UI
                             ↓
                      ┌──────────────┐
                      │   Messages   │
                      └──────────────┘
```

### 3.2 事件映射关系

| Kode-SDK 事件 | Frontend 组件 | 说明 |
|--------------|--------------|------|
| `text_chunk` | `UserAssistantEventMessage` | 流式文本，累加显示 |
| `tool:start` | `ObservationPairEventMessage` | 工具调用开始，显示执行中 |
| `tool:end` | `McpEventMessage` / `GenericEventMessage` | 工具结果，展开/折叠显示 |
| `permission_required` | 审批弹窗 | 需要人工决策 |
| `done` | 对话完成状态 | 保存 bookmark |

### 3.3 消息格式转换

#### Kode-SDK Message 格式

```typescript
{
  role: 'assistant',
  content: [
    { type: 'text', text: '我来帮你...' },
    { type: 'tool_use', id: 'tool_1', name: 'fs_read', input: { path: '...' } },
    { type: 'tool_result', tool_use_id: 'tool_1', content: '...', is_error: false }
  ]
}
```

#### Frontend Event 格式

```typescript
// 文本消息
{
  action: 'message',
  source: 'agent',
  args: { content: '我来帮你...' }
}

// 工具调用
{
  action: 'call_tool_mcp',
  source: 'agent',
  id: 'tool_1',
  args: { name: 'fs_read', arguments: { path: '...' } }
}

// 工具结果
{
  observation: 'mcp',
  source: 'agent',
  content: '...',
  extras: { name: 'fs_read', arguments: {...}, duration: 15 }
}
```

## 4. 快速开始

### 4.1 后端设置

#### Step 1: 安装依赖

```bash
npm install kode-sdk express cors
```

#### Step 2: 创建 Agent 运行时

```typescript
// runtime.ts
import { 
  Agent, 
  AgentDependencies, 
  AgentTemplateRegistry,
  ToolRegistry,
  SandboxFactory,
  JSONStore,
  AnthropicProvider
} from 'kode-sdk';

export function createRuntime(): AgentDependencies {
  const templateRegistry = new AgentTemplateRegistry();
  const toolRegistry = new ToolRegistry();
  const sandboxFactory = new SandboxFactory();
  const store = new JSONStore('./.kode-data');
  
  // 注册模板
  templateRegistry.register({
    id: 'chat-assistant',
    systemPrompt: 'You are a helpful AI assistant.',
    tools: ['fs_read', 'fs_write', 'bash_run'],
    model: 'claude-sonnet-4.5-20250929',
  });
  
  // 注册内置工具
  toolRegistry.registerBuiltin('fs', 'bash', 'todo');
  
  return {
    store,
    templateRegistry,
    toolRegistry,
    sandboxFactory,
    modelFactory: (config) => new AnthropicProvider(config)
  };
}
```

#### Step 3: 创建 API 服务器

```typescript
// server.ts
import express from 'express';
import cors from 'cors';
import { Agent } from 'kode-sdk';
import { createRuntime } from './runtime';

const app = express();
app.use(cors());
app.use(express.json());

const deps = createRuntime();
const agents = new Map<string, Agent>();

// 创建会话
app.post('/api/conversations', async (req, res) => {
  const conversationId = `conv_${Date.now()}`;
  
  const agent = await Agent.create({
    agentId: `agt_${conversationId}`,
    templateId: 'chat-assistant',
    sandbox: { kind: 'local', workDir: './workspace' }
  }, deps);
  
  agents.set(conversationId, agent);
  
  res.json({
    conversationId,
    agentId: agent.agentId,
    status: 'ready'
  });
});

// 发送消息
app.post('/api/conversations/:id/messages', async (req, res) => {
  const agent = agents.get(req.params.id);
  if (!agent) return res.status(404).json({ error: 'Not found' });
  
  const messageId = await agent.send(req.body.content);
  res.json({ messageId, status: 'queued' });
});

// SSE 事件流
app.get('/api/conversations/:id/events', async (req, res) => {
  const agent = agents.get(req.params.id);
  if (!agent) return res.status(404).json({ error: 'Not found' });
  
  res.setHeader('Content-Type', 'text/event-stream');
  res.setHeader('Cache-Control', 'no-cache');
  res.setHeader('Connection', 'keep-alive');
  res.flushHeaders();
  
  const iterator = agent.subscribe(['progress'])[Symbol.asyncIterator]();
  
  for await (const envelope of { [Symbol.asyncIterator]: () => iterator }) {
    res.write(`event: ${envelope.event.type}\n`);
    res.write(`data: ${JSON.stringify(envelope)}\n\n`);
    
    if (envelope.event.type === 'done') {
      res.end();
      break;
    }
  }
  
  req.on('close', () => iterator.return?.());
});

app.listen(3000, () => {
  console.log('Server running on http://localhost:3000');
});
```

#### Step 4: 启动服务器

```bash
npx tsx server.ts
```

### 4.2 前端设置

#### Step 1: 创建事件流 Hook

```typescript
// hooks/use-kode-stream.ts
import { useEffect, useState } from 'react';
import { useEventStore } from '#/stores/use-event-store';

export function useKodeStream(conversationId: string) {
  const [isConnected, setIsConnected] = useState(false);
  
  useEffect(() => {
    if (!conversationId) return;
    
    const es = new EventSource(
      `/api/conversations/${conversationId}/events`
    );
    
    es.onopen = () => setIsConnected(true);
    
    es.addEventListener('text_chunk', (e) => {
      const { event } = JSON.parse(e.data);
      useEventStore.getState().appendText(event.delta);
    });
    
    es.addEventListener('tool:start', (e) => {
      const { event } = JSON.parse(e.data);
      useEventStore.getState().addToolCall({
        id: event.call.id,
        name: event.call.name,
        input: event.call.inputPreview,
        status: 'executing'
      });
    });
    
    es.addEventListener('tool:end', (e) => {
      const { event } = JSON.parse(e.data);
      useEventStore.getState().updateToolCall(event.call.id, {
        result: event.call.result,
        duration: event.call.durationMs,
        status: 'completed'
      });
    });
    
    es.addEventListener('done', (e) => {
      const { bookmark } = JSON.parse(e.data);
      useEventStore.getState().setLastBookmark(bookmark.seq);
      es.close();
    });
    
    return () => es.close();
  }, [conversationId]);
  
  return { isConnected };
}
```

#### Step 2: 集成到 ChatInterface

```typescript
// components/KodeChatInterface.tsx
import { ChatInterface } from '#/components/features/chat/chat-interface';
import { useKodeStream } from '#/hooks/use-kode-stream';

export function KodeChatInterface({ conversationId }: { conversationId: string }) {
  const { isConnected } = useKodeStream(conversationId);
  
  if (!isConnected) {
    return <div>Connecting...</div>;
  }
  
  return <ChatInterface />;
}
```

#### Step 3: 发送消息

```typescript
// 在 ChatInterface 中
const handleSendMessage = async (content: string) => {
  await fetch(`/api/conversations/${conversationId}/messages`, {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({ content })
  });
};
```

## 5. 关键功能实现

### 5.1 工具调用可视化

```typescript
// 后端：转换工具事件
function convertToolEvent(call: ToolCallSnapshot) {
  return {
    observation: 'mcp',
    content: JSON.stringify(call.result),
    extras: {
      name: call.name,
      arguments: call.inputPreview,
      duration: call.durationMs
    }
  };
}

// 前端：使用现有组件
<McpEventMessage event={toolEvent} />
// 自动渲染参数和结果，支持展开/折叠
```

### 5.2 人工审批流程

```typescript
// 后端：监听审批请求
agent.on('permission_required', async (event) => {
  // 通过 WebSocket 推送到前端
  io.to(conversationId).emit('approval_required', {
    callId: event.call.id,
    toolName: event.call.name,
    input: event.call.inputPreview
  });
});

// 前端：处理审批
socket.on('approval_required', ({ callId, toolName, input }) => {
  showApprovalDialog({
    toolName,
    input,
    onApprove: () => {
      socket.emit('approve', { callId, decision: 'allow' });
    },
    onDeny: () => {
      socket.emit('approve', { callId, decision: 'deny' });
    }
  });
});

// 后端：处理审批决策
socket.on('approve', async ({ callId, decision }) => {
  await agent.decide(callId, decision);
});
```

### 5.3 消息历史持久化

```typescript
// 后端：加载历史
app.get('/api/conversations/:id/messages', async (req, res) => {
  const agent = agents.get(req.params.id);
  const messages = await deps.store.loadMessages(agent.agentId);
  
  res.json({
    messages: messages.map(convertMessageToFrontend)
  });
});

// 前端：加载历史
useEffect(() => {
  fetch(`/api/conversations/${conversationId}/messages`)
    .then(res => res.json())
    .then(data => {
      data.messages.forEach(msg => {
        useEventStore.getState().addEvent(convertToEvent(msg));
      });
    });
}, [conversationId]);
```

### 5.4 断点续播

```typescript
// 前端：保存 bookmark
localStorage.setItem('lastBookmark', String(bookmark.seq));

// 重新连接时从断点开始
const lastBookmark = localStorage.getItem('lastBookmark');
const es = new EventSource(
  `/api/conversations/${conversationId}/events?since=${lastBookmark}`
);
// 只接收断点之后的新事件
```

## 6. 部署架构

### 6.1 开发环境

```
┌─────────────────┐
│  Frontend Dev   │
│  (Vite :5173)   │
└─────────────────┘
         ↓
┌─────────────────┐
│  API Server     │
│  (Express :3000)│
└─────────────────┘
         ↓
┌─────────────────┐
│  Kode-SDK       │
│  (Local Files)  │
└─────────────────┘
```

### 6.2 生产环境

```
┌──────────────┐
│   Nginx      │
│  (Reverse    │
│   Proxy)     │
└──────────────┘
       ↓
┌──────────────────────────────┐
│  Frontend (Static Files)     │
└──────────────────────────────┘
       ↓
┌──────────────────────────────┐
│  API Server (PM2/Docker)     │
│  - Load Balancer             │
│  - Multiple Instances        │
└──────────────────────────────┘
       ↓
┌──────────────────────────────┐
│  Database (PostgreSQL/Redis) │
└──────────────────────────────┘
       ↓
┌──────────────────────────────┐
│  Kode-SDK Agent Pool         │
│  - Agent 缓存和复用          │
└──────────────────────────────┘
```

### 6.3 Docker 部署

```yaml
# docker-compose.yml
version: '3.8'

services:
  frontend:
    build: ./frontend
    ports:
      - "80:80"
    depends_on:
      - api
  
  api:
    build: ./api
    ports:
      - "3000:3000"
    environment:
      - DATABASE_URL=postgresql://user:pass@db:5432/kode
      - REDIS_URL=redis://redis:6379
      - ANTHROPIC_API_KEY=${ANTHROPIC_API_KEY}
    depends_on:
      - db
      - redis
    volumes:
      - ./workspace:/app/workspace
  
  db:
    image: postgres:15
    environment:
      POSTGRES_USER: user
      POSTGRES_PASSWORD: pass
      POSTGRES_DB: kode
    volumes:
      - db_data:/var/lib/postgresql/data
  
  redis:
    image: redis:7
    volumes:
      - redis_data:/data

volumes:
  db_data:
  redis_data:
```

## 7. 性能优化建议

### 7.1 后端优化

1. **Agent 池管理**
   ```typescript
   const agentPool = new AgentPool(deps, {
     maxSize: 100,
     idleTimeout: 300000
   });
   ```

2. **消息批量持久化**
   ```typescript
   // 每 1 秒或 10 条消息批量写入
   const batchWrite = debounce(async () => {
     await store.saveMessages(agentId, pendingMessages);
   }, 1000);
   ```

3. **Redis 缓存**
   ```typescript
   // 缓存消息历史
   const cached = await redis.get(`messages:${conversationId}`);
   if (cached) return JSON.parse(cached);
   ```

### 7.2 前端优化

1. **虚拟滚动**
   ```typescript
   import { FixedSizeList } from 'react-window';
   ```

2. **分页加载**
   ```typescript
   const { messages, loadMore } = useInfiniteMessages(conversationId);
   ```

3. **事件节流**
   ```typescript
   const throttledUpdate = throttle((delta) => {
     updateUI(delta);
   }, 50); // 每 50ms 更新一次
   ```

## 8. 监控和调试

### 8.1 日志系统

```typescript
// 使用 Winston 或 Pino
import pino from 'pino';

const logger = pino({
  level: 'info',
  transport: {
    target: 'pino-pretty'
  }
});

// 记录关键事件
agent.on('tool_executed', (event) => {
  logger.info({
    type: 'tool_executed',
    toolName: event.call.name,
    duration: event.call.durationMs
  });
});
```

### 8.2 指标收集

```typescript
// Prometheus metrics
import { Counter, Histogram } from 'prom-client';

const messageCounter = new Counter({
  name: 'messages_total',
  help: 'Total messages sent'
});

const toolDuration = new Histogram({
  name: 'tool_duration_seconds',
  help: 'Tool execution duration',
  labelNames: ['tool_name']
});

agent.on('tool_executed', (event) => {
  toolDuration.labels(event.call.name).observe(event.call.durationMs / 1000);
});
```

### 8.3 错误追踪

```typescript
// 使用 Sentry
import * as Sentry from '@sentry/node';

Sentry.init({
  dsn: process.env.SENTRY_DSN,
  tracesSampleRate: 1.0
});

agent.on('error', (event) => {
  Sentry.captureException(new Error(event.message), {
    extra: {
      phase: event.phase,
      detail: event.detail
    }
  });
});
```

## 9. 安全考虑

### 9.1 认证授权

```typescript
// JWT 认证
import jwt from 'jsonwebtoken';

function authenticate(req, res, next) {
  const token = req.headers.authorization?.replace('Bearer ', '');
  const decoded = jwt.verify(token, process.env.JWT_SECRET);
  req.user = decoded;
  next();
}

app.use('/api/conversations', authenticate);
```

### 9.2 权限隔离

```typescript
// 确保用户只能访问自己的会话
async function authorize(req, res, next) {
  const conversation = await db.getConversation(req.params.id);
  
  if (conversation.userId !== req.user.id) {
    return res.status(403).json({ error: 'Forbidden' });
  }
  
  next();
}
```

### 9.3 工具安全策略

```typescript
// 危险工具需要审批
{
  permission: {
    mode: 'ask',
    requireApprovalTools: ['bash_run', 'fs_write', 'fs_edit']
  }
}

// Hook 中自定义安全检查
{
  hooks: {
    async preToolUse(call, agent) {
      if (call.name === 'bash_run') {
        const dangerous = ['rm -rf', 'dd if='];
        if (dangerous.some(cmd => call.input.command.includes(cmd))) {
          return { decision: 'ask', meta: { risk: 'high' } };
        }
      }
    }
  }
}
```

## 10. 常见问题

### Q1: SSE 连接频繁断开怎么办？

**A**: 实现自动重连机制

```typescript
class ReconnectingEventSource {
  private reconnectDelay = 1000;
  
  connect(url: string) {
    const es = new EventSource(url);
    
    es.onerror = () => {
      es.close();
      setTimeout(() => this.connect(url), this.reconnectDelay);
      this.reconnectDelay = Math.min(this.reconnectDelay * 2, 30000);
    };
  }
}
```

### Q2: 如何处理大量并发工具调用？

**A**: 使用 ToolRunner 控制并发数

```typescript
const agent = await Agent.create({
  // ...
  metadata: {
    maxToolConcurrency: 5  // 最多并发 5 个工具
  }
}, deps);
```

### Q3: 消息历史过大怎么优化？

**A**: 使用分页加载和虚拟滚动

```typescript
// 分页 API
app.get('/api/conversations/:id/messages', async (req, res) => {
  const { limit = 50, before } = req.query;
  const messages = await loadMessages(conversationId, { limit, before });
  res.json({ messages, nextCursor: ... });
});

// 前端虚拟滚动
<FixedSizeList
  height={600}
  itemCount={messages.length}
  itemSize={100}
>
  {Row}
</FixedSizeList>
```

### Q4: 如何支持多用户协作？

**A**: 使用 Room 或广播机制

```typescript
// 使用 Socket.IO 房间
socket.join(conversationId);

// 广播事件到房间内所有用户
io.to(conversationId).emit('event', envelope);

// 或使用 Kode-SDK 的 Room
import { Room } from 'kode-sdk';

const room = new Room({ ... });
await room.join(agentId);
```

## 11. 下一步行动

### 11.1 实施步骤

1. ✅ **阶段 1: 基础集成** (1-2 天)
   - [ ] 搭建 Express API 服务器
   - [ ] 实现 SSE 事件流
   - [ ] 前端接入 EventSource

2. ✅ **阶段 2: 核心功能** (3-5 天)
   - [ ] 工具调用可视化
   - [ ] 消息历史持久化
   - [ ] 断点续播机制

3. ✅ **阶段 3: 高级功能** (5-7 天)
   - [ ] 人工审批流程
   - [ ] 多用户支持
   - [ ] 性能优化

4. ✅ **阶段 4: 生产准备** (3-5 天)
   - [ ] 错误处理完善
   - [ ] 监控和日志
   - [ ] 安全加固
   - [ ] 部署配置

### 11.2 验收标准

- [ ] 用户可以流式对话
- [ ] 工具调用实时可视化
- [ ] 支持断线重连不丢消息
- [ ] 危险工具需要人工审批
- [ ] 消息历史可查看和搜索
- [ ] 并发 100 用户无卡顿
- [ ] 99.9% 可用性

## 12. 参考资源

### 12.1 文档

- [Kode-SDK 官方文档](../Kode-sdk/docs/)
- [Frontend 组件文档](../frontend/README.md)
- [事件流指南](../Kode-sdk/docs/events.md)

### 12.2 示例代码

- [Next.js API Route 示例](../Kode-sdk/examples/nextjs-api-route.ts)
- [多用户 Demo](../Kode-sdk/examples/multi-user-demo.ts)
- [Room 协作示例](../Kode-sdk/examples/03-room-collab.ts)

### 12.3 工具

- [Postman Collection](./postman/) - API 测试
- [WebSocket 测试工具](https://websocket.org/echo.html)
- [SSE 测试工具](https://www.piesocket.com/sse-tester)

---

## 总结

本方案提供了 **Kode-SDK 与前端对话界面** 的完整集成路径：

✅ **清晰的架构设计**: 三层架构，关注点分离  
✅ **详细的事件映射**: Kode Event ↔ Frontend Event  
✅ **完整的实现指南**: 从快速开始到生产部署  
✅ **最佳实践**: 性能优化、安全加固、错误处理  
✅ **可扩展性**: 支持多用户、审批、协作

通过本方案，可以快速构建一个功能完善、性能优异的 AI 对话应用。

**开始行动**: 参考"快速开始"章节，30 分钟搭建原型！

