# Kode-SDK 工具调用机制详解

## 1. 工具系统架构

### 1.1 核心组件关系

```
┌─────────────────────────────────────────────────┐
│                 Agent (调度层)                   │
│  - processToolCall()                            │
│  - executeTools()                               │
│  - ToolRunner (并发控制)                         │
└─────────────────────────────────────────────────┘
                      ↓
┌─────────────────────────────────────────────────┐
│            ToolRegistry (注册中心)               │
│  - globalToolRegistry                           │
│  - register(name, factory)                      │
│  - get(name): ToolInstance                      │
└─────────────────────────────────────────────────┘
                      ↓
┌─────────────────────────────────────────────────┐
│              ToolInstance (工具实例)             │
│  - name, description, input_schema              │
│  - exec(args, ctx): Promise<result>             │
│  - hooks?: { preToolUse, postToolUse }          │
└─────────────────────────────────────────────────┘
                      ↓
┌─────────────────────────────────────────────────┐
│               Sandbox (执行环境)                 │
│  - exec(command): Promise<output>               │
│  - readFile(path): Promise<content>             │
│  - writeFile(path, content): Promise<void>      │
└─────────────────────────────────────────────────┘
```

## 2. 工具定义方式

### 2.1 使用 `tool()` 函数（推荐）

**位置**: `Kode-sdk/src/tools/tool.ts`

#### 方式1: 简洁模式

```typescript
import { tool } from 'kode-sdk';

// 零配置，自动推断类型
const myTool = tool('my_tool', async (args, ctx) => {
  const { path } = args;
  const content = await ctx.sandbox.readFile(path);
  return { content };
});
```

#### 方式2: 完整配置模式

```typescript
import { tool } from 'kode-sdk';
import { z } from 'zod';

const myTool = tool({
  name: 'fs_read_enhanced',
  description: '读取文件内容（增强版）',
  
  // Zod schema 自动生成 JSON Schema
  parameters: z.object({
    path: z.string().describe('文件路径'),
    encoding: z.enum(['utf8', 'base64']).optional().default('utf8'),
  }),
  
  async execute(args, ctx) {
    const { path, encoding } = args; // 已验证的参数
    const content = await ctx.sandbox.readFile(path);
    
    if (encoding === 'base64') {
      return { content: Buffer.from(content).toString('base64') };
    }
    
    return { content };
  },
  
  metadata: {
    version: '1.0.0',
    tags: ['filesystem', 'read'],
    timeout: 30000,        // 超时时间（毫秒）
    concurrent: true,      // 支持并发
    readonly: true,        // 只读工具
  },
  
  hooks: {
    async preToolUse(call, agent) {
      // 执行前检查
      if (call.input.path.startsWith('/etc/')) {
        return { decision: 'ask', meta: { risk: 'high' } };
      }
    },
    
    async postToolUse(call, result, agent) {
      // 执行后处理
      if (result.content.length > 1000000) {
        return { 
          update: { 
            result: { 
              ...result, 
              content: result.content.slice(0, 1000) + '...(truncated)' 
            } 
          } 
        };
      }
    }
  }
});
```

### 2.2 内置工具示例

#### fs_read (文件读取)
**位置**: `Kode-sdk/src/tools/fs_read/index.ts`

```typescript
export class FsRead implements ToolInstance {
  name = 'fs_read';
  description = '读取文件内容';
  
  input_schema = {
    type: 'object',
    properties: {
      path: { type: 'string', description: '文件路径' },
    },
    required: ['path']
  };
  
  async exec(args: { path: string }, ctx: ToolContext) {
    try {
      const content = await ctx.sandbox.readFile(args.path);
      return content;
    } catch (error) {
      return {
        ok: false,
        error: `Failed to read file: ${error.message}`
      };
    }
  }
}
```

#### bash_run (命令执行)
**位置**: `Kode-sdk/src/tools/bash_run/index.ts`

```typescript
export class BashRun implements ToolInstance {
  name = 'bash_run';
  description = '执行 Bash 命令';
  
  input_schema = {
    type: 'object',
    properties: {
      command: { type: 'string', description: '要执行的命令' },
      background: { type: 'boolean', description: '是否后台运行' },
    },
    required: ['command']
  };
  
  async exec(args: { command: string; background?: boolean }, ctx: ToolContext) {
    const { command, background } = args;
    
    if (background) {
      const pid = await ctx.sandbox.execBackground(command);
      return { pid, status: 'running' };
    }
    
    const result = await ctx.sandbox.exec(command);
    return {
      stdout: result.stdout,
      stderr: result.stderr,
      exitCode: result.exitCode
    };
  }
}
```

## 3. 工具执行完整流程

### 3.1 从 ContentBlock 到工具调用

```typescript
// 1. 模型返回 tool_use ContentBlock
const modelResponse = {
  role: 'assistant',
  content: [
    { type: 'text', text: '我来读取文件' },
    { 
      type: 'tool_use', 
      id: 'toolu_01ABC', 
      name: 'fs_read', 
      input: { path: 'README.md' } 
    }
  ]
};

// 2. Agent 提取 tool_use
const toolUses = modelResponse.content.filter(
  block => block.type === 'tool_use'
);

// 3. 并发执行工具
const toolResults = await this.executeTools(toolUses);

// 4. 添加 tool_result 到消息历史
this.messages.push({
  role: 'user',
  content: toolResults  // [{ type: 'tool_result', ... }]
});

// 5. 继续下一轮模型调用
```

### 3.2 processToolCall 详细流程

```typescript
private async processToolCall(
  toolUse: { id: string; name: string; input: any }
): Promise<ContentBlock | null> {
  
  // === 第1步: 初始化 ===
  const tool = this.tools.get(toolUse.name);
  const record = this.registerToolRecord(toolUse);
  
  // 发送 tool:start 事件
  this.events.emitProgress({ 
    channel: 'progress',
    type: 'tool:start', 
    call: this.snapshotToolRecord(record.id) 
  });
  
  // === 第2步: 工具存在性检查 ===
  if (!tool) {
    this.updateToolRecord(record.id, { 
      state: 'FAILED', 
      error: `Tool not found: ${toolUse.name}` 
    });
    return this.makeToolResult(toolUse.id, {
      ok: false,
      error: `Tool not found: ${toolUse.name}`,
      recommendations: ['检查工具是否已注册', '确认模板配置']
    });
  }
  
  // === 第3步: 参数验证 ===
  const validation = this.validateToolArgs(tool, toolUse.input);
  if (!validation.ok) {
    this.updateToolRecord(record.id, { 
      state: 'FAILED', 
      error: validation.error 
    });
    return this.makeToolResult(toolUse.id, {
      ok: false,
      error: validation.error,
      recommendations: ['检查参数是否符合 schema', '根据提示修正后重试']
    });
  }
  
  // === 第4步: 权限策略检查 ===
  const policyDecision = this.permissions.evaluate(toolUse.name);
  if (policyDecision === 'deny') {
    this.updateToolRecord(record.id, { 
      state: 'DENIED', 
      error: 'Tool denied by policy' 
    });
    return this.makeToolResult(toolUse.id, {
      ok: false,
      error: 'Permission denied by policy'
    });
  }
  
  // === 第5步: Pre-hook 检查 ===
  const context: ToolContext = {
    agentId: this.agentId,
    sandbox: this.sandbox,
    agent: this,
    services: { todo: this.todoService, filePool: this.filePool }
  };
  
  const preResult = await this.hooks.executePreToolUse(
    { name: toolUse.name, args: toolUse.input, id: toolUse.id },
    context.agent
  );
  
  if (preResult?.decision === 'deny') {
    // Hook 拒绝
    this.updateToolRecord(record.id, { state: 'DENIED' });
    return this.makeToolResult(toolUse.id, preResult.toolResult || {
      ok: false,
      error: preResult.reason || 'Denied by hook'
    });
  }
  
  if (preResult?.decision === 'ask') {
    // 需要人工审批
    this.updateToolRecord(record.id, { 
      state: 'APPROVAL_REQUIRED',
      approval: { required: true, meta: preResult.meta }
    });
    
    await this.requestPermission(record, preResult.meta);
    
    // 等待审批结果
    const decision = record.approval.decision;
    if (decision === 'deny') {
      this.updateToolRecord(record.id, { state: 'DENIED' });
      return this.makeToolResult(toolUse.id, {
        ok: false,
        error: 'Permission denied by user',
        note: record.approval.note
      });
    }
  }
  
  // === 第6步: 执行工具（带超时和取消控制） ===
  const controller = new AbortController();
  this.toolControllers.set(record.id, controller);
  context.signal = controller.signal;
  
  this.updateToolRecord(record.id, { 
    state: 'EXECUTING', 
    startedAt: Date.now() 
  });
  
  let rawResult: any;
  try {
    rawResult = await this.toolRunner.run(() =>
      Promise.race([
        tool.exec(toolUse.input, context),
        this.createTimeoutPromise(this.toolTimeoutMs)
      ])
    );
  } catch (error) {
    this.updateToolRecord(record.id, {
      state: 'FAILED',
      error: error.message,
      isError: true,
      completedAt: Date.now()
    });
    
    // 发送 tool:error 事件
    this.events.emitProgress({
      channel: 'progress',
      type: 'tool:error',
      call: this.snapshotToolRecord(record.id),
      error: error.message
    });
    
    return this.makeToolResult(toolUse.id, {
      ok: false,
      error: error.message
    }, true);
  } finally {
    this.toolControllers.delete(record.id);
  }
  
  // === 第7步: Post-hook 处理 ===
  const postResult = await this.hooks.executePostToolUse(
    { name: toolUse.name, args: toolUse.input, id: toolUse.id },
    rawResult,
    context.agent
  );
  
  let finalResult = rawResult;
  if (postResult?.replace) {
    finalResult = postResult.replace.content;
  } else if (postResult?.update) {
    finalResult = { ...rawResult, ...postResult.update.result };
  }
  
  // === 第8步: 更新记录并发送事件 ===
  this.updateToolRecord(record.id, {
    state: 'COMPLETED',
    result: finalResult,
    completedAt: Date.now(),
    durationMs: Date.now() - record.startedAt!
  });
  
  // 发送 tool:end 事件
  this.events.emitProgress({
    channel: 'progress',
    type: 'tool:end',
    call: this.snapshotToolRecord(record.id)
  });
  
  // 发送 Monitor 事件
  this.events.emitMonitor({
    channel: 'monitor',
    type: 'tool_executed',
    call: this.snapshotToolRecord(record.id)
  });
  
  // === 第9步: 返回 tool_result ===
  return this.makeToolResult(
    toolUse.id, 
    finalResult,
    finalResult?.ok === false || finalResult?._thrownError
  );
}
```

### 3.3 并发执行控制

```typescript
private async executeTools(toolUses: ContentBlock[]): Promise<ContentBlock[]> {
  // 所有工具调用并发执行，由 ToolRunner 控制并发数
  const promises = toolUses.map(toolUse => 
    this.processToolCall(toolUse as any)
  );
  
  const results = await Promise.all(promises);
  
  // 过滤掉 null（被 Hook 拦截的工具）
  return results.filter(r => r !== null) as ContentBlock[];
}

// ToolRunner 实现（默认并发数 3）
class ToolRunner {
  private active = 0;
  private queue: Array<() => void> = [];
  
  async run<T>(task: () => Promise<T>): Promise<T> {
    if (this.active < this.concurrency) {
      this.active++;
      try {
        return await task();
      } finally {
        this.active--;
        this.flush();
      }
    } else {
      return new Promise((resolve, reject) => {
        this.queue.push(async () => {
          this.active++;
          try {
            resolve(await task());
          } catch (err) {
            reject(err);
          } finally {
            this.active--;
            this.flush();
          }
        });
      });
    }
  }
  
  private flush() {
    if (this.queue.length > 0 && this.active < this.concurrency) {
      const next = this.queue.shift();
      next?.();
    }
  }
}
```

## 4. 工具调用记录（ToolCallRecord）

### 4.1 数据结构

```typescript
export interface ToolCallRecord {
  id: string;                    // 唯一标识
  name: string;                  // 工具名称
  input: any;                    // 输入参数
  state: ToolCallState;          // 当前状态
  approval: ToolCallApproval;    // 审批信息
  result?: any;                  // 执行结果
  error?: string;                // 错误信息
  isError?: boolean;             // 是否错误
  startedAt?: number;            // 开始时间
  completedAt?: number;          // 完成时间
  durationMs?: number;           // 执行耗时
  createdAt: number;             // 创建时间
  updatedAt: number;             // 更新时间
  auditTrail: ToolCallAuditEntry[]; // 审计轨迹
}

// 状态枚举
export type ToolCallState =
  | 'PENDING'           // 等待执行
  | 'APPROVAL_REQUIRED' // 需要审批
  | 'APPROVED'          // 已批准
  | 'EXECUTING'         // 执行中
  | 'COMPLETED'         // 已完成
  | 'FAILED'            // 失败
  | 'DENIED'            // 被拒绝
  | 'SEALED';           // 已封口（Resume 时）

// 审批信息
export interface ToolCallApproval {
  required: boolean;
  decision?: 'allow' | 'deny';
  decidedBy?: string;
  decidedAt?: number;
  note?: string;
  meta?: Record<string, any>;
}

// 审计条目
export interface ToolCallAuditEntry {
  state: ToolCallState;
  timestamp: number;
  note?: string;
}
```

### 4.2 状态转换图

```
                    PENDING
                       ↓
          ┌────────────┴────────────┐
          ↓                         ↓
    APPROVAL_REQUIRED          EXECUTING
          ↓                         ↓
    ┌─────┴─────┐            ┌──────┴──────┐
    ↓           ↓            ↓             ↓
 APPROVED    DENIED     COMPLETED       FAILED
    ↓                                      
 EXECUTING                              
    ↓                                      
 COMPLETED / FAILED                       
                                          
        (Resume 时未完成的调用)
                ↓
             SEALED
```

### 4.3 快照（Snapshot）

用于事件传递的轻量级版本：

```typescript
export type ToolCallSnapshot = Pick<
  ToolCallRecord,
  'id' | 'name' | 'state' | 'approval' | 'result' | 'error' | 
  'isError' | 'durationMs' | 'startedAt' | 'completedAt'
> & {
  inputPreview?: any;               // 输入预览（可能被截断）
  auditTrail?: ToolCallAuditEntry[]; // 审计轨迹
};

// 生成快照
private snapshotToolRecord(id: string): ToolCallSnapshot {
  const record = this.toolRecords.get(id);
  if (!record) throw new Error(`Tool record not found: ${id}`);
  
  return {
    id: record.id,
    name: record.name,
    state: record.state,
    approval: record.approval,
    result: record.result,
    error: record.error,
    isError: record.isError,
    durationMs: record.durationMs,
    startedAt: record.startedAt,
    completedAt: record.completedAt,
    inputPreview: this.truncateInput(record.input), // 截断大输入
    auditTrail: record.auditTrail
  };
}
```

## 5. Hook 系统

### 5.1 Hook 接口定义

```typescript
export interface Hooks {
  // 工具执行前
  preToolUse?: (
    call: { name: string; args: any; id: string }, 
    agent: any
  ) => Promise<HookDecision>;
  
  // 工具执行后
  postToolUse?: (
    call: { name: string; args: any; id: string },
    result: any,
    agent: any
  ) => Promise<PostHookResult>;
  
  // 消息变更后
  messagesChanged?: (
    messages: Message[], 
    agent: any
  ) => Promise<void>;
}

// Pre-hook 返回值
export type HookDecision =
  | { decision: 'ask'; meta?: any }           // 需要审批
  | { decision: 'deny'; reason?: string; toolResult?: any } // 拒绝执行
  | { result: any }                           // 直接返回结果（跳过执行）
  | void;                                     // 继续执行

// Post-hook 返回值
export type PostHookResult =
  | void                                      // 保持原结果
  | { update: Partial<ToolOutcome> }          // 更新部分字段
  | { replace: ToolOutcome };                 // 替换整个结果
```

### 5.2 Hook 应用场景

#### 场景1: 安全策略控制

```typescript
const securityHooks: Hooks = {
  async preToolUse(call, agent) {
    // 危险命令检测
    if (call.name === 'bash_run') {
      const cmd = call.args.command;
      const dangerous = ['rm -rf', 'dd if=', 'mkfs', '> /dev/'];
      
      if (dangerous.some(pattern => cmd.includes(pattern))) {
        return { 
          decision: 'ask', 
          meta: { 
            risk: 'high', 
            reason: 'Potentially destructive command' 
          } 
        };
      }
    }
    
    // 敏感文件访问
    if (call.name === 'fs_read' || call.name === 'fs_write') {
      const sensitivePatterns = ['/etc/passwd', '/.ssh/', '/.env'];
      
      if (sensitivePatterns.some(p => call.args.path.includes(p))) {
        return {
          decision: 'deny',
          reason: 'Access to sensitive file denied',
          toolResult: {
            ok: false,
            error: 'Permission denied: sensitive file'
          }
        };
      }
    }
  }
};
```

#### 场景2: 结果后处理

```typescript
const postProcessHooks: Hooks = {
  async postToolUse(call, result, agent) {
    // 大文件内容截断
    if (call.name === 'fs_read' && typeof result === 'string') {
      if (result.length > 100000) {
        return {
          update: {
            result: result.slice(0, 10000) + '\n\n...(truncated, total size: ' + result.length + ' bytes)'
          }
        };
      }
    }
    
    // 敏感信息脱敏
    if (call.name === 'bash_run' && result.stdout) {
      const masked = result.stdout.replace(
        /password[=:]\s*\S+/gi, 
        'password=***'
      );
      return {
        update: {
          result: { ...result, stdout: masked }
        }
      };
    }
  }
};
```

#### 场景3: 自动缓存

```typescript
const cacheHooks: Hooks = {
  async preToolUse(call, agent) {
    // 只读工具启用缓存
    if (call.name === 'fs_read') {
      const cacheKey = `${call.name}:${call.args.path}`;
      const cached = await cache.get(cacheKey);
      
      if (cached) {
        return { result: cached }; // 直接返回缓存，跳过执行
      }
    }
  },
  
  async postToolUse(call, result, agent) {
    if (call.name === 'fs_read' && !result.ok === false) {
      const cacheKey = `${call.name}:${call.args.path}`;
      await cache.set(cacheKey, result, { ttl: 300 }); // 5分钟缓存
    }
  }
};
```

## 6. 权限管理

### 6.1 权限配置

```typescript
export interface PermissionConfig {
  mode: 'auto' | 'ask' | 'deny' | 'custom';
  requireApprovalTools?: string[];  // 需要审批的工具列表
  autoAllowTools?: string[];        // 自动允许的工具列表
  autoDenyTools?: string[];         // 自动拒绝的工具列表
}

// 在模板中配置
{
  id: 'my-assistant',
  permission: {
    mode: 'ask',
    requireApprovalTools: ['bash_run', 'fs_write', 'fs_edit'],
    autoAllowTools: ['fs_read', 'fs_glob', 'fs_grep'],
  }
}
```

### 6.2 权限决策流程

```typescript
class PermissionManager {
  evaluate(toolName: string): 'auto' | 'ask' | 'deny' {
    const config = this.config;
    
    // 1. 检查 autoDeny 列表
    if (config.autoDenyTools?.includes(toolName)) {
      return 'deny';
    }
    
    // 2. 检查 autoAllow 列表
    if (config.autoAllowTools?.includes(toolName)) {
      return 'auto';
    }
    
    // 3. 检查 requireApproval 列表
    if (config.requireApprovalTools?.includes(toolName)) {
      return 'ask';
    }
    
    // 4. 根据全局模式决策
    switch (config.mode) {
      case 'auto': return 'auto';
      case 'ask': return 'ask';
      case 'deny': return 'deny';
      case 'custom': 
        // 由 Hook 或外部逻辑决定
        return 'auto';
    }
  }
}
```

## 7. 工具上下文（ToolContext）

### 7.1 上下文结构

```typescript
export interface ToolContext {
  agentId: string;                // Agent ID
  sandbox: Sandbox;               // 沙箱环境
  agent: any;                     // Agent 实例
  services?: {                    // 可选服务
    todo?: TodoService;
    filePool?: FilePool;
  };
  signal?: AbortSignal;           // 取消信号
  emit?: (eventType: string, data?: any) => void; // 自定义事件发射
}
```

### 7.2 增强上下文（EnhancedToolContext）

使用 `tool()` 函数定义的工具会获得增强上下文：

```typescript
export interface EnhancedToolContext extends ToolContext {
  emit(eventType: string, data?: any): void;
}

// 在工具中使用
tool({
  name: 'long_task',
  async execute(args, ctx) {
    ctx.emit('task_started', { taskId: args.id });
    
    for (let i = 0; i < 100; i++) {
      await doWork(i);
      ctx.emit('progress', { percent: i });
    }
    
    ctx.emit('task_completed', { taskId: args.id });
    return { success: true };
  }
});

// Agent 中监听
agent.on('tool_custom_event', (event) => {
  if (event.eventType === 'progress') {
    console.log(`Progress: ${event.data.percent}%`);
  }
});
```

## 8. 工具结果格式

### 8.1 标准格式

```typescript
// 成功结果（任意格式）
{
  content: "...",
  status: "success",
  // ... 其他字段
}

// 错误结果（统一格式）
{
  ok: false,
  error: "错误描述",
  recommendations?: string[]  // 可选的修复建议
}
```

### 8.2 转换为 ContentBlock

```typescript
private makeToolResult(
  toolUseId: string, 
  result: any, 
  isError: boolean = false
): ContentBlock {
  return {
    type: 'tool_result',
    tool_use_id: toolUseId,
    content: result,
    is_error: isError
  };
}

// 示例
{
  type: 'tool_result',
  tool_use_id: 'toolu_01ABC',
  content: { content: '文件内容...' },
  is_error: false
}

// 错误示例
{
  type: 'tool_result',
  tool_use_id: 'toolu_01XYZ',
  content: {
    ok: false,
    error: 'File not found: /path/to/file',
    recommendations: ['检查文件路径', '确认文件是否存在']
  },
  is_error: true
}
```

## 9. 内置工具清单

| 工具名 | 功能 | 输入参数 |
|-------|------|---------|
| `fs_read` | 读取文件 | `path` |
| `fs_write` | 写入文件 | `path, content` |
| `fs_edit` | 编辑文件 | `path, edits[]` |
| `fs_glob` | 文件搜索 | `pattern, exclude?` |
| `fs_grep` | 内容搜索 | `pattern, path?, flags?` |
| `fs_multi_edit` | 批量编辑 | `edits[]` |
| `bash_run` | 执行命令 | `command, background?` |
| `bash_logs` | 查看日志 | `pid` |
| `bash_kill` | 终止进程 | `pid` |
| `todo_read` | 读取 Todo | - |
| `todo_write` | 写入 Todo | `todos[]` |
| `task_run` | 子任务执行 | `task, context?` |

## 10. 与前端对接的关键点

### 10.1 工具调用的前端展示

```typescript
// 监听 tool:start 事件
case 'tool:start': {
  const { call } = event;
  
  ui.renderToolExecution({
    id: call.id,
    name: call.name,
    input: call.inputPreview,
    state: call.state,
    status: 'executing',
    startedAt: call.startedAt
  });
  break;
}

// 监听 tool:end 事件
case 'tool:end': {
  const { call } = event;
  
  ui.updateToolExecution({
    id: call.id,
    result: call.result,
    error: call.error,
    isError: call.isError,
    state: call.state,
    status: call.state === 'COMPLETED' ? 'success' : 'failed',
    duration: call.durationMs,
    completedAt: call.completedAt
  });
  break;
}
```

### 10.2 工具结果映射

Kode-SDK 的 `tool_result` ContentBlock 可以直接映射到前端：

```typescript
// Kode-SDK 格式
{
  type: 'tool_result',
  tool_use_id: 'toolu_01ABC',
  content: {
    content: '文件内容...',
    lineCount: 100,
    size: 5000
  },
  is_error: false
}

// 前端展示格式（可以保持一致）
{
  type: 'tool_result',
  tool_use_id: 'toolu_01ABC',
  content: {
    content: '文件内容...',
    lineCount: 100,
    size: 5000
  },
  is_error: false
}
```

### 10.3 审批 UI 集成

```typescript
// 后端监听审批请求
agent.on('permission_required', async (event) => {
  const { call, respond } = event;
  
  // 推送到前端 UI
  ws.emit('approval_request', {
    id: call.id,
    toolName: call.name,
    input: call.inputPreview,
    approval: call.approval
  });
  
  // 等待用户决策（不立即调用 respond）
});

// 前端用户审批后
ws.on('user_decision', async ({ callId, decision, note }) => {
  await agent.decide(callId, decision, { note });
});

// 监听审批结果
agent.on('permission_decided', (event) => {
  ws.emit('approval_decided', {
    callId: event.callId,
    decision: event.decision,
    decidedBy: event.decidedBy,
    note: event.note
  });
});
```

## 总结

Kode-SDK 的工具系统特点：

1. **灵活的定义方式**: `tool()` 函数支持简洁和完整两种模式
2. **完善的生命周期**: 从参数验证到结果处理的全流程管理
3. **强大的 Hook 系统**: 支持执行前后的自定义逻辑
4. **精细的权限控制**: 多层级的权限策略和审批流程
5. **并发控制**: ToolRunner 自动管理并发执行
6. **详细的审计**: ToolCallRecord 记录完整的执行轨迹
7. **事件驱动**: 通过 Progress/Monitor 事件实时通知执行状态

这些特性使其能够安全、高效地执行各类工具操作，并与前端无缝集成。

