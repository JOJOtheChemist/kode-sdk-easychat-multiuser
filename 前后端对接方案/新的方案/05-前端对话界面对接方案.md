# 前端对话界面对接方案

基于前面分析的 frontend 对话界面组件和 Kode-SDK 事件系统，本文档详细说明如何将两者对接。

## 1. 整体对接架构

### 1.1 数据流向

```
┌──────────────────────────────────────────────┐
│        Frontend Components                   │
│  ChatInterface → Messages → EventMessage     │
│     ↓                                        │
│  ObservationPairEventMessage                 │
│  UserAssistantEventMessage                   │
│  McpEventMessage                             │
└──────────────────────────────────────────────┘
           ↑ (UI 更新)
┌──────────────────────────────────────────────┐
│         Frontend Event Handler               │
│  - handleTextChunk()                         │
│  - handleToolStart()                         │
│  - handleToolEnd()                           │
│  - handleDone()                              │
└──────────────────────────────────────────────┘
           ↑ (SSE/WebSocket)
┌──────────────────────────────────────────────┐
│           API Gateway                        │
│  - 事件格式转换                               │
│  - Kode Event → Frontend Event               │
└──────────────────────────────────────────────┘
           ↑ (Kode Events)
┌──────────────────────────────────────────────┐
│         Kode-SDK Agent                       │
│  - Progress Events                           │
│  - Control Events                            │
│  - Monitor Events                            │
└──────────────────────────────────────────────┘
```

## 2. 事件映射方案

### 2.1 核心映射表

| Kode-SDK 事件 | Frontend 期望格式 | 对应组件 |
|--------------|-----------------|---------|
| `text_chunk` | `{ role: 'assistant', content: [{ type: 'text', text }] }` | `UserAssistantEventMessage` |
| `tool:start` | `{ action: 'tool_use', args: { name, input } }` | `ObservationPairEventMessage` |
| `tool:end` | `{ observation: 'tool_result', content, extras }` | `GenericEventMessage` + `MCPObservationContent` |
| `done` | 触发对话完成状态 | `ChatInterface` 状态更新 |

### 2.2 详细映射规则

#### 2.2.1 文本流式输出

**Kode-SDK 事件**:
```typescript
{
  type: 'text_chunk',
  step: 1,
  delta: "你好"
}
```

**转换为前端格式**:
```typescript
{
  role: 'assistant',
  content: [
    { type: 'text', text: "你好" }  // 累加 delta
  ],
  source: 'agent',
  action: 'message'
}
```

**前端处理**:
```typescript
// ChatInterface 中
case 'text_chunk': {
  // 累加到当前消息
  ui.appendText(event.delta);
  break;
}

// 最终渲染为 UserAssistantEventMessage
<ChatMessage type="agent" message={accumulatedText} />
```

#### 2.2.2 工具调用开始

**Kode-SDK 事件**:
```typescript
{
  type: 'tool:start',
  call: {
    id: 'tool_abc123',
    name: 'fs_read',
    state: 'EXECUTING',
    inputPreview: { path: 'README.md' }
  }
}
```

**转换为前端格式**:
```typescript
{
  action: 'call_tool_mcp',  // 或其他 action 类型
  args: {
    name: 'fs_read',
    input: { path: 'README.md' },
    thought: ''  // 可选
  },
  source: 'agent',
  id: 'tool_abc123'
}
```

**前端处理**:
```typescript
// EventMessage 组件判断
if (hasObservationPair && isOpenHandsAction(event)) {
  return (
    <ObservationPairEventMessage
      event={convertedEvent}
      actions={actions}
    />
  );
}

// ObservationPairEventMessage 渲染
if (hasThoughtProperty(event.args) && event.action !== "think") {
  return (
    <div>
      <ChatMessage type="agent" message={event.args.thought} />
      <MicroagentStatusWrapper ... />
    </div>
  );
}
```

#### 2.2.3 工具调用完成

**Kode-SDK 事件**:
```typescript
{
  type: 'tool:end',
  call: {
    id: 'tool_abc123',
    name: 'fs_read',
    state: 'COMPLETED',
    result: "# My Project\n...",
    durationMs: 15
  }
}
```

**转换为前端格式**:
```typescript
// 作为 observation
{
  observation: 'tool_result',  // 或 'mcp' 对于 MCP 工具
  content: "# My Project\n...",
  extras: {
    name: 'fs_read',
    arguments: { path: 'README.md' },
    duration: 15,
    success: true
  },
  source: 'agent'
}
```

**前端处理**:
```typescript
// 如果是 MCP 工具
if (isMcpObservation(event)) {
  return (
    <McpEventMessage
      event={event}
      shouldShowConfirmationButtons={false}
    />
  );
}

// McpEventMessage 渲染
<GenericEventMessage
  title={getEventContent(event).title}  // "CALL_TOOL_MCP: fs_read"
  details={<MCPObservationContent event={event} />}
  success={getObservationResult(event)}
/>

// MCPObservationContent 显示参数和结果
<div>
  <h3>Arguments</h3>
  <ReactJsonView src={event.extras.arguments} />
  
  <h3>Output</h3>
  <ReactJsonView src={outputData} />
</div>
```

## 3. 前端状态管理

### 3.1 消息状态

```typescript
// 使用 frontend 的 event-message-store
import { useEventStore } from '#/stores/use-event-store';

// 在对话界面中
const storeEvents = useEventStore((state) => state.events);

// 添加 Kode 事件
const addKodeEvent = (kodeEvent: KodeEvent) => {
  const frontendEvent = convertKodeEventToFrontendEvent(kodeEvent);
  useEventStore.getState().addEvent(frontendEvent);
};

// 事件转换函数
function convertKodeEventToFrontendEvent(kodeEvent: any) {
  switch (kodeEvent.type) {
    case 'text_chunk':
      return {
        action: 'message',
        source: 'agent',
        args: {
          content: kodeEvent.delta
        }
      };
      
    case 'tool:start':
      return {
        action: 'call_tool_mcp',
        source: 'agent',
        id: kodeEvent.call.id,
        args: {
          name: kodeEvent.call.name,
          arguments: kodeEvent.call.inputPreview
        }
      };
      
    case 'tool:end':
      return {
        observation: 'mcp',
        source: 'agent',
        content: JSON.stringify(kodeEvent.call.result),
        extras: {
          name: kodeEvent.call.name,
          arguments: kodeEvent.call.inputPreview,
          duration: kodeEvent.call.durationMs
        }
      };
      
    default:
      return kodeEvent;
  }
}
```

### 3.2 流式文本累加

```typescript
// 文本累加器
class TextAccumulator {
  private chunks: Map<number, string> = new Map();
  
  addChunk(step: number, delta: string) {
    const current = this.chunks.get(step) || '';
    this.chunks.set(step, current + delta);
  }
  
  getText(step: number): string {
    return this.chunks.get(step) || '';
  }
  
  finalize(step: number): string {
    const text = this.getText(step);
    this.chunks.delete(step);
    return text;
  }
}

// 在事件处理中使用
const accumulator = new TextAccumulator();

function handleKodeEvent(envelope: any) {
  const { event } = envelope;
  
  switch (event.type) {
    case 'text_chunk':
      accumulator.addChunk(event.step, event.delta);
      // 更新 UI
      setAssistantMessage(accumulator.getText(event.step));
      break;
      
    case 'text_chunk_end':
      const finalText = accumulator.finalize(event.step);
      // 添加到消息历史
      addMessage({
        role: 'assistant',
        content: [{ type: 'text', text: finalText }]
      });
      break;
  }
}
```

## 4. SSE 客户端实现

### 4.1 EventSource 封装

```typescript
// hooks/use-kode-event-stream.ts
import { useEffect, useState } from 'react';

export function useKodeEventStream(conversationId: string, lastBookmark?: number) {
  const [events, setEvents] = useState<any[]>([]);
  const [isConnected, setIsConnected] = useState(false);
  const [error, setError] = useState<Error | null>(null);
  
  useEffect(() => {
    if (!conversationId) return;
    
    const params = new URLSearchParams({
      channels: 'progress,monitor',
      ...(lastBookmark && { since: String(lastBookmark) })
    });
    
    const url = `/api/conversations/${conversationId}/events?${params}`;
    const eventSource = new EventSource(url);
    
    eventSource.onopen = () => {
      setIsConnected(true);
      setError(null);
    };
    
    // 文本流式输出
    eventSource.addEventListener('text_chunk', (e) => {
      const envelope = JSON.parse(e.data);
      handleTextChunk(envelope);
    });
    
    // 工具调用开始
    eventSource.addEventListener('tool:start', (e) => {
      const envelope = JSON.parse(e.data);
      handleToolStart(envelope);
    });
    
    // 工具调用结束
    eventSource.addEventListener('tool:end', (e) => {
      const envelope = JSON.parse(e.data);
      handleToolEnd(envelope);
    });
    
    // 对话完成
    eventSource.addEventListener('done', (e) => {
      const envelope = JSON.parse(e.data);
      handleDone(envelope);
      eventSource.close();
    });
    
    // 错误处理
    eventSource.addEventListener('error', (e: any) => {
      const data = JSON.parse(e.data || '{}');
      setError(new Error(data.error || 'Stream error'));
      eventSource.close();
    });
    
    eventSource.onerror = () => {
      setIsConnected(false);
      setError(new Error('Connection failed'));
    };
    
    return () => {
      eventSource.close();
      setIsConnected(false);
    };
  }, [conversationId, lastBookmark]);
  
  return { events, isConnected, error };
}
```

### 4.2 集成到 ChatInterface

```typescript
// ChatInterface 改造
import { useKodeEventStream } from '#/hooks/use-kode-event-stream';
import { useConversationId } from '#/hooks/use-conversation-id';

export function ChatInterface() {
  const { conversationId } = useConversationId();
  const lastBookmark = useEventStore((state) => state.lastBookmark);
  
  // 订阅 Kode 事件流
  const { events, isConnected, error } = useKodeEventStream(
    conversationId!, 
    lastBookmark
  );
  
  // ... 其他逻辑
  
  return (
    <div>
      {!isConnected && <div>Connecting...</div>}
      {error && <ErrorMessage error={error} />}
      
      {/* 原有的消息渲染 */}
      <Messages messages={storeEvents} />
    </div>
  );
}
```

## 5. 工具调用界面映射

### 5.1 MCP 工具显示

基于 frontend 现有的 `MCPObservationContent` 组件：

```typescript
// 后端转换 Kode tool_result 为 MCP 格式
function convertToolResultToMCP(call: ToolCallSnapshot) {
  return {
    observation: 'mcp',
    content: typeof call.result === 'string' 
      ? call.result 
      : JSON.stringify(call.result),
    extras: {
      name: call.name,
      arguments: call.inputPreview || {},
      duration: call.durationMs,
      success: call.state === 'COMPLETED'
    }
  };
}

// 前端直接使用现有组件
<MCPObservationContent event={mcpEvent} />
```

### 5.2 通用工具显示

对于非 MCP 工具，使用 `GenericEventMessage`：

```typescript
// 后端生成标题和详情
function getToolEventContent(call: ToolCallSnapshot) {
  return {
    title: `${call.name.toUpperCase()}`,
    details: formatToolDetails(call),
    success: call.state === 'COMPLETED' ? 'success' : 'error'
  };
}

function formatToolDetails(call: ToolCallSnapshot): string {
  let details = '';
  
  // 输入参数
  details += `**Input:**\n\`\`\`json\n${JSON.stringify(call.inputPreview, null, 2)}\n\`\`\`\n\n`;
  
  // 输出结果
  if (call.result) {
    details += `**Output:**\n\`\`\`\n${formatResult(call.result)}\n\`\`\`\n\n`;
  }
  
  // 错误信息
  if (call.error) {
    details += `**Error:**\n${call.error}\n\n`;
  }
  
  // 执行时间
  if (call.durationMs) {
    details += `**Duration:** ${call.durationMs}ms`;
  }
  
  return details;
}

// 前端渲染
<GenericEventMessage
  title={title}
  details={details}
  success={success}
  initiallyExpanded={false}
/>
```

## 6. 消息历史加载

### 6.1 从 Kode Store 加载历史

```typescript
// API 端点
app.get('/api/conversations/:conversationId/messages', async (req, res) => {
  const { conversationId } = req.params;
  const agent = await getOrResumeAgent(conversationId);
  
  // 获取消息历史
  const messages = await deps.store.loadMessages(agent.agentId);
  
  // 转换为前端格式
  const frontendMessages = messages.map(convertMessageToFrontend);
  
  res.json({ messages: frontendMessages });
});

// 消息转换
function convertMessageToFrontend(message: Message) {
  return {
    role: message.role,
    content: message.content.map(block => {
      if (block.type === 'text') {
        return { type: 'text', text: block.text };
      }
      if (block.type === 'tool_use') {
        return {
          type: 'tool_use',
          id: block.id,
          name: block.name,
          input: block.input
        };
      }
      if (block.type === 'tool_result') {
        return {
          type: 'tool_result',
          tool_use_id: block.tool_use_id,
          content: block.content,
          is_error: block.is_error
        };
      }
      return block;
    })
  };
}
```

### 6.2 前端历史加载

```typescript
// hooks/use-conversation-history.ts
export function useConversationHistory(conversationId: string) {
  const [messages, setMessages] = useState<Message[]>([]);
  const [isLoading, setIsLoading] = useState(true);
  
  useEffect(() => {
    if (!conversationId) return;
    
    fetch(`/api/conversations/${conversationId}/messages`)
      .then(res => res.json())
      .then(data => {
        setMessages(data.messages);
        
        // 转换并添加到事件 store
        data.messages.forEach(msg => {
          useEventStore.getState().addEvent(convertToEvent(msg));
        });
      })
      .finally(() => setIsLoading(false));
  }, [conversationId]);
  
  return { messages, isLoading };
}

// 在 ChatInterface 中使用
const { messages, isLoading } = useConversationHistory(conversationId);
```

## 7. 用户输入处理

### 7.1 发送消息

```typescript
// ChatInterface 中的 handleSendMessage
const handleSendMessage = async (
  content: string,
  images: File[],
  files: File[]
) => {
  // 1. 显示乐观更新（用户消息）
  setOptimisticUserMessage(content);
  
  // 2. 发送到后端
  const response = await fetch(
    `/api/conversations/${conversationId}/messages`,
    {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ content, images, files })
    }
  );
  
  const { messageId } = await response.json();
  
  // 3. SSE 连接会自动推送后续事件
  // 不需要额外处理
};
```

### 7.2 附件处理

```typescript
// 如果有图片或文件附件
const handleSendWithAttachments = async (
  content: string,
  images: File[],
  files: File[]
) => {
  // 转换图片为 base64
  const imageUrls = await Promise.all(
    images.map(img => convertImageToBase64(img))
  );
  
  // 上传文件
  const uploadedFiles = await uploadFiles(files);
  
  // 构建消息内容
  const messageContent = [
    { type: 'text', text: content },
    ...imageUrls.map(url => ({ type: 'image', source: { type: 'url', url } })),
    ...uploadedFiles.map(path => ({ type: 'file', path }))
  ];
  
  // 发送
  await fetch(`/api/conversations/${conversationId}/messages`, {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({ content: messageContent })
  });
};
```

## 8. 审批流程集成

### 8.1 监听审批请求

```typescript
// 使用 WebSocket 监听审批事件
socket.on('approval_required', (data) => {
  const { callId, toolName, input, approval } = data;
  
  // 显示审批 UI
  showApprovalDialog({
    callId,
    toolName,
    input,
    risk: approval.meta?.risk,
    onApprove: (note) => {
      socket.emit('approve', { callId, decision: 'allow', note });
    },
    onDeny: (note) => {
      socket.emit('approve', { callId, decision: 'deny', note });
    }
  });
});

// 监听审批结果
socket.on('approval_decided', (data) => {
  const { callId, decision, decidedBy, note } = data;
  
  // 更新 UI 显示审批结果
  updateToolCallStatus(callId, {
    approved: decision === 'allow',
    decidedBy,
    note
  });
});
```

### 8.2 审批 UI 组件

```typescript
// components/ApprovalDialog.tsx
export function ApprovalDialog({ 
  toolName, 
  input, 
  risk,
  onApprove, 
  onDeny 
}: ApprovalDialogProps) {
  const [note, setNote] = useState('');
  
  return (
    <Modal isOpen={true}>
      <h2>Tool Approval Required</h2>
      
      <div>
        <strong>Tool:</strong> {toolName}
      </div>
      
      <div>
        <strong>Risk Level:</strong> 
        <span className={`risk-${risk}`}>{risk}</span>
      </div>
      
      <div>
        <strong>Input:</strong>
        <ReactJsonView src={input} />
      </div>
      
      <textarea
        value={note}
        onChange={(e) => setNote(e.target.value)}
        placeholder="Add a note (optional)"
      />
      
      <div>
        <button onClick={() => onApprove(note)}>Approve</button>
        <button onClick={() => onDeny(note)}>Deny</button>
      </div>
    </Modal>
  );
}
```

## 9. 错误处理

### 9.1 前端错误显示

```typescript
// 监听错误事件
eventSource.addEventListener('error', (e: any) => {
  const data = JSON.parse(e.data || '{}');
  
  // 使用 frontend 的错误提示
  displayErrorToast(data.error || 'An error occurred');
  
  // 或使用 ErrorMessageBanner
  useErrorMessageStore.getState().setErrorMessage({
    message: data.error,
    detail: data.detail
  });
});

// ErrorMessageBanner 组件已存在
<ErrorMessageBanner message={errorMessage} />
```

### 9.2 网络错误重连

```typescript
// 实现自动重连
class ReconnectingEventSource {
  private eventSource: EventSource | null = null;
  private reconnectDelay = 1000;
  private maxReconnectDelay = 30000;
  
  connect(url: string, handlers: any) {
    this.eventSource = new EventSource(url);
    
    this.eventSource.onopen = () => {
      this.reconnectDelay = 1000; // 重置延迟
      handlers.onOpen?.();
    };
    
    this.eventSource.onerror = () => {
      this.eventSource?.close();
      
      // 指数退避重连
      setTimeout(() => {
        this.connect(url, handlers);
      }, this.reconnectDelay);
      
      this.reconnectDelay = Math.min(
        this.reconnectDelay * 2, 
        this.maxReconnectDelay
      );
    };
    
    // 绑定其他事件处理器
    Object.entries(handlers).forEach(([event, handler]) => {
      if (event !== 'onOpen' && event !== 'onError') {
        this.eventSource?.addEventListener(event, handler as any);
      }
    });
  }
  
  close() {
    this.eventSource?.close();
  }
}
```

## 10. 性能优化

### 10.1 虚拟滚动

```typescript
// 使用 react-window 优化长消息列表
import { FixedSizeList } from 'react-window';

export function VirtualizedMessages({ messages }: { messages: any[] }) {
  const Row = ({ index, style }: any) => (
    <div style={style}>
      <EventMessage event={messages[index]} />
    </div>
  );
  
  return (
    <FixedSizeList
      height={600}
      itemCount={messages.length}
      itemSize={100}
      width="100%"
    >
      {Row}
    </FixedSizeList>
  );
}
```

### 10.2 消息分页加载

```typescript
// 滚动加载更多历史消息
export function useInfiniteMessages(conversationId: string) {
  const [messages, setMessages] = useState<Message[]>([]);
  const [cursor, setCursor] = useState<string | null>(null);
  const [hasMore, setHasMore] = useState(true);
  
  const loadMore = async () => {
    if (!hasMore) return;
    
    const params = new URLSearchParams({
      limit: '50',
      ...(cursor && { before: cursor })
    });
    
    const response = await fetch(
      `/api/conversations/${conversationId}/messages?${params}`
    );
    
    const data = await response.json();
    
    setMessages(prev => [...data.messages, ...prev]);
    setCursor(data.nextCursor);
    setHasMore(data.hasMore);
  };
  
  return { messages, loadMore, hasMore };
}

// 在 ChatInterface 中使用
const { messages, loadMore, hasMore } = useInfiniteMessages(conversationId);

<InfiniteScroll
  dataLength={messages.length}
  next={loadMore}
  hasMore={hasMore}
  loader={<LoadingSpinner />}
  scrollableTarget="scrollableDiv"
>
  <Messages messages={messages} />
</InfiniteScroll>
```

## 11. 完整集成示例

### 11.1 React 组件集成

```typescript
// components/KodeChatInterface.tsx
import React, { useEffect, useState } from 'react';
import { ChatInterface } from '#/components/features/chat/chat-interface';
import { useEventStore } from '#/stores/use-event-store';

export function KodeChatInterface({ conversationId }: { conversationId: string }) {
  const [eventSource, setEventSource] = useState<EventSource | null>(null);
  const accumulator = useRef(new TextAccumulator());
  
  useEffect(() => {
    if (!conversationId) return;
    
    // 1. 加载历史消息
    loadHistory(conversationId);
    
    // 2. 连接事件流
    const es = new EventSource(
      `/api/conversations/${conversationId}/events?channels=progress,monitor`
    );
    
    es.addEventListener('text_chunk', (e) => {
      const envelope = JSON.parse(e.data);
      const { event } = envelope;
      
      accumulator.current.addChunk(event.step, event.delta);
      
      // 触发 UI 更新
      useEventStore.getState().updateCurrentMessage({
        role: 'assistant',
        content: [{ 
          type: 'text', 
          text: accumulator.current.getText(event.step) 
        }]
      });
    });
    
    es.addEventListener('text_chunk_end', (e) => {
      const envelope = JSON.parse(e.data);
      const { event } = envelope;
      
      const finalText = accumulator.current.finalize(event.step);
      
      useEventStore.getState().addEvent({
        action: 'message',
        source: 'agent',
        args: { content: finalText }
      });
    });
    
    es.addEventListener('tool:start', (e) => {
      const envelope = JSON.parse(e.data);
      const { call } = envelope.event;
      
      useEventStore.getState().addEvent({
        action: 'call_tool_mcp',
        source: 'agent',
        id: call.id,
        args: {
          name: call.name,
          arguments: call.inputPreview
        }
      });
    });
    
    es.addEventListener('tool:end', (e) => {
      const envelope = JSON.parse(e.data);
      const { call } = envelope.event;
      
      useEventStore.getState().addEvent({
        observation: 'mcp',
        source: 'agent',
        content: JSON.stringify(call.result),
        extras: {
          name: call.name,
          arguments: call.inputPreview,
          duration: call.durationMs
        }
      });
    });
    
    es.addEventListener('done', (e) => {
      const envelope = JSON.parse(e.data);
      
      useEventStore.getState().setLastBookmark(envelope.bookmark.seq);
      es.close();
    });
    
    setEventSource(es);
    
    return () => {
      es.close();
    };
  }, [conversationId]);
  
  // 使用原有的 ChatInterface 组件
  return <ChatInterface />;
}

async function loadHistory(conversationId: string) {
  const response = await fetch(
    `/api/conversations/${conversationId}/messages`
  );
  const { messages } = await response.json();
  
  messages.forEach((msg: Message) => {
    useEventStore.getState().addEvent(convertMessageToEvent(msg));
  });
}

function convertMessageToEvent(message: Message): any {
  if (message.role === 'user') {
    return {
      action: 'message',
      source: 'user',
      args: {
        content: message.content
          .filter(b => b.type === 'text')
          .map(b => (b as any).text)
          .join('')
      }
    };
  }
  
  if (message.role === 'assistant') {
    // 转换 assistant 消息和工具调用
    const events: any[] = [];
    
    message.content.forEach(block => {
      if (block.type === 'text') {
        events.push({
          action: 'message',
          source: 'agent',
          args: { content: (block as any).text }
        });
      }
      
      if (block.type === 'tool_use') {
        events.push({
          action: 'call_tool_mcp',
          source: 'agent',
          id: (block as any).id,
          args: {
            name: (block as any).name,
            arguments: (block as any).input
          }
        });
      }
      
      if (block.type === 'tool_result') {
        events.push({
          observation: 'mcp',
          source: 'agent',
          content: (block as any).content
        });
      }
    });
    
    return events;
  }
  
  return message;
}
```

## 总结

前端对接方案的核心要点：

1. **事件格式转换**: Kode-SDK 事件 → Frontend 期望格式
2. **流式文本累加**: 使用 TextAccumulator 管理增量文本
3. **工具调用映射**: tool:start/end → ObservationPairEventMessage
4. **SSE 连接管理**: 断点续播、自动重连、错误处理
5. **历史消息加载**: 从 Kode Store 加载并转换
6. **审批流程集成**: WebSocket 监听审批事件
7. **性能优化**: 虚拟滚动、分页加载

关键优势：
- **无缝集成**: 复用 frontend 现有组件，无需大改
- **格式兼容**: ContentBlock 格式天然兼容
- **事件驱动**: SSE/WebSocket 实时推送
- **断点续播**: 支持断线重连不丢消息

