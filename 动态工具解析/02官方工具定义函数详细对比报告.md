# Kode SDK 官方工具定义函数详细对比报告

**版本**: Kode SDK v2.7+  
**生成日期**: 2025-10-19  
**文档类型**: 技术分析报告

---

## 目录

1. [官方定义函数清单](#1-官方定义函数清单)
2. [源码定义位置](#2-源码定义位置)
3. [tool() 详细分析](#3-tool-详细分析)
4. [defineTool() 详细分析](#4-definetool-详细分析)
5. [注册机制核心差异](#5-注册机制核心差异)
6. [prompt 属性处理差异](#6-prompt-属性处理差异)
7. [使用场景建议](#7-使用场景建议)
8. [实际代码示例](#8-实际代码示例)
9. [总结对比表](#9-总结对比表)

---

## 1. 官方定义函数清单

Kode SDK 提供以下官方工具定义函数：

| 函数 | 文件 | 行号 | 作用 | 引入版本 |
|------|------|------|------|---------|
| `tool()` | `src/tools/tool.ts` | 54-153 | 单个工具定义（Zod 参数） | v2.0+ |
| `tools()` | `src/tools/tool.ts` | 158-160 | 批量工具定义（Zod 参数） | v2.0+ |
| `defineTool()` | `src/tools/define.ts` | 144-217 | 单个工具定义（简化参数） | v2.7+ |
| `defineTools()` | `src/tools/define.ts` | 222-224 | 批量工具定义（简化参数） | v2.7+ |

### 官方导出验证

**`src/index.ts` 第 80-88 行**：

```typescript
export {
  defineTool,
  defineTools,
  extractTools,
  ToolAttributes,
  ParamDef,
  SimpleToolDef,
} from './tools/define';
export { tool, tools, ToolDefinition, EnhancedToolContext } from './tools/tool';
```

**结论**: 所有函数均为官方提供，有完整的 TypeScript 类型定义和文档支持。

---

## 2. 源码定义位置

### 2.1 tool() 函数族

**文件**: `src/tools/tool.ts`

**接口定义** (第 10-25 行):

```typescript
export interface ToolDefinition<TArgs = any, TResult = any> {
  name: string;
  description?: string;
  parameters?: ZodType<TArgs>;  // ← 使用 Zod 进行参数验证
  execute: (args: TArgs, ctx: EnhancedToolContext) => Promise<TResult> | TResult;
  metadata?: {
    version?: string;
    tags?: string[];
    cacheable?: boolean;
    cacheTTL?: number;
    timeout?: number;
    concurrent?: boolean;
    readonly?: boolean;
  };
  hooks?: Hooks;
}
```

**函数签名** (第 38-49 行):

```typescript
// 重载 1: 零配置模式
export function tool<TArgs = any, TResult = any>(
  name: string,
  executeFn: (args: TArgs, ctx?: EnhancedToolContext) => Promise<TResult> | TResult
): ToolInstance;

// 重载 2: 完整配置模式
export function tool<TArgs = any, TResult = any>(
  definition: ToolDefinition<TArgs, TResult>
): ToolInstance;
```

**实现** (第 54-153 行):

```typescript
export function tool<TArgs = any, TResult = any>(
  nameOrDef: string | ToolDefinition<TArgs, TResult>,
  executeFn?: (args: TArgs, ctx?: EnhancedToolContext) => Promise<TResult> | TResult
): ToolInstance {
  // 解析参数
  const def: ToolDefinition<TArgs, TResult> = /* ... */;
  
  // 生成 JSON Schema
  const input_schema = def.parameters
    ? zodToJsonSchema(def.parameters, { target: 'openApi3', $refStrategy: 'none' })
    : { type: 'object', properties: {} };

  // 创建工具实例
  const toolInstance: ToolInstance = {
    name: def.name,
    description: def.description || `Execute ${def.name}`,
    input_schema,
    hooks: def.hooks,
    async exec(args: any, ctx: ToolContext): Promise<any> { /* ... */ },
    toDescriptor(): ToolDescriptor { /* ... */ },
  };

  // ⭐ 关键：注册工厂函数返回同一个实例
  globalToolRegistry.register(def.name, () => toolInstance);
  
  return toolInstance;
}
```

---

### 2.2 defineTool() 函数族

**文件**: `src/tools/define.ts`

**接口定义** (第 39-54 行):

```typescript
export interface SimpleToolDef<TArgs = any, TResult = any> {
  name: string;
  description: string;
  params?: Record<string, ParamDef>;  // ← 自动生成 Schema
  input_schema?: any;  // 或直接提供 Schema
  attributes?: ToolAttributes;
  prompt?: string;  // ⭐ 支持 prompt 字段
  exec(args: TArgs, ctx: EnhancedToolContext): Promise<TResult> | TResult;
}

export interface ToolAttributes {
  readonly?: boolean;
  noEffect?: boolean;
}

export interface ParamDef {
  type: 'string' | 'number' | 'boolean' | 'object' | 'array';
  description?: string;
  required?: boolean;
  default?: any;
  enum?: any[];
  items?: ParamDef;
  properties?: Record<string, ParamDef>;
}
```

**函数实现** (第 144-217 行):

```typescript
export function defineTool<TArgs = any, TResult = any>(
  def: SimpleToolDef<TArgs, TResult>,
  options?: { autoRegister?: boolean }
): ToolInstance {
  // 自动生成 schema 或使用提供的
  const input_schema = def.input_schema || generateSchema(def.params);

  const toolInstance: ToolInstance = {
    name: def.name,
    description: def.description,
    input_schema,
    prompt: def.prompt,  // ⭐ 从 def 中读取 prompt
    async exec(args: any, ctx: ToolContext): Promise<any> { /* ... */ },
    toDescriptor(): ToolDescriptor { /* ... */ },
  };

  // ⭐ 关键：注册工厂函数每次重建实例
  if (options?.autoRegister !== false) {
    globalToolRegistry.register(def.name, (_config) => {
      return defineTool(def, { autoRegister: false });
    });
  }

  return toolInstance;
}
```

**批量定义** (第 222-224 行):

```typescript
export function defineTools(defs: SimpleToolDef[]): ToolInstance[] {
  return defs.map((def) => defineTool(def));
}
```

---

## 3. tool() 详细分析

### 3.1 特点

- **参数验证**: 使用 Zod 进行运行时类型验证
- **Schema 生成**: 通过 `zod-to-json-schema` 自动生成 JSON Schema
- **错误处理**: 内置参数验证和异常捕获
- **注册机制**: 单例模式，工厂函数返回同一个实例引用

### 3.2 注册机制源码

```typescript
// 第 149-150 行
globalToolRegistry.register(def.name, () => toolInstance);
```

**解析**:
- 闭包捕获 `toolInstance` 变量
- 工厂函数 `() => toolInstance` 每次调用都返回**同一个对象引用**
- 内存中只有一个实例存在

### 3.3 对象生命周期

```
创建阶段：
  tool() 被调用
    ↓
  创建 toolInstance (内存地址: 0x1000)
    ↓
  注册工厂函数: () => 0x1000
    ↓
  返回 0x1000

使用阶段：
  registry.create('tool_name')
    ↓
  调用工厂函数: () => 0x1000
    ↓
  返回 0x1000 (同一个引用)
```

### 3.4 prompt 属性处理

```typescript
// 创建工具
export const FsWrite = tool({
  name: 'fs_write',
  description: 'Write file',
  parameters: z.object({ /* ... */ }),
  async execute(args, ctx) { /* ... */ },
});

// 事后添加 prompt
FsWrite.prompt = PROMPT;

// Agent 使用
const tool = registry.create('fs_write');
// tool === FsWrite (同一个引用)
// tool.prompt === PROMPT ✅
```

**结论**: 事后添加的 `prompt` 属性**有效**，因为返回的是同一个对象。

---

## 4. defineTool() 详细分析

### 4.1 特点

- **简化定义**: 使用简单的类型定义，不需要 Zod
- **自动 Schema**: 从 `params` 对象自动生成 JSON Schema
- **Prompt 支持**: 接口中包含 `prompt` 字段
- **配置灵活**: 支持 `config` 参数，可动态创建实例

### 4.2 注册机制源码

```typescript
// 第 208-214 行
if (options?.autoRegister !== false) {
  globalToolRegistry.register(def.name, (_config) => {
    // 工厂函数：根据 config 重建工具实例
    return defineTool(def, { autoRegister: false });
  });
}
```

**解析**:
- 闭包捕获 `def` 对象（定义）而非 `toolInstance`（实例）
- 工厂函数 `(_config) => defineTool(def, ...)` 每次调用都**重新执行 defineTool**
- 每次创建**新的对象实例**

### 4.3 对象生命周期

```
创建阶段：
  defineTool(def) 被调用
    ↓
  创建 toolInstance1 (内存地址: 0x1000)
    ↓
  注册工厂函数: (_config) => defineTool(def, ...)
    ↓
  返回 0x1000

使用阶段（第一次）：
  registry.create('tool_name')
    ↓
  调用工厂函数: defineTool(def, ...)
    ↓
  创建 toolInstance2 (内存地址: 0x2000) ← 新对象
    ↓
  返回 0x2000

使用阶段（第二次）：
  registry.create('tool_name')
    ↓
  调用工厂函数: defineTool(def, ...)
    ↓
  创建 toolInstance3 (内存地址: 0x3000) ← 又一个新对象
    ↓
  返回 0x3000
```

### 4.4 prompt 属性处理

```typescript
// ❌ 错误方式：事后添加
export const createSchedulesBatchTool = defineTool({
  name: 'create_schedules_batch',
  description: 'Batch create schedules',
  params: { /* ... */ },
  async exec(args, ctx) { /* ... */ },
  // 注意：这里没有 prompt 字段
});

// 事后添加 prompt
(createSchedulesBatchTool as any).prompt = PROMPT;

// Agent 使用
const tool = registry.create('create_schedules_batch');
// tool !== createSchedulesBatchTool (不同引用)
// tool.prompt === undefined ❌
// 因为 def 里没有 prompt，新创建的实例没有这个属性
```

```typescript
// ✅ 正确方式：在定义中包含
export const createSchedulesBatchTool = defineTool({
  name: 'create_schedules_batch',
  description: 'Batch create schedules',
  prompt: PROMPT,  // ⭐ 在这里定义
  params: { /* ... */ },
  async exec(args, ctx) { /* ... */ },
});

// Agent 使用
const tool = registry.create('create_schedules_batch');
// tool.prompt === PROMPT ✅
// 因为 def 里有 prompt，新创建的实例会包含这个属性
```

**结论**: 事后添加的 `prompt` 属性**无效**，必须在 `def` 对象中定义。

---

## 5. 注册机制核心差异

### 5.1 源码对比

| 维度 | tool() | defineTool() |
|------|--------|--------------|
| **闭包捕获** | `toolInstance`（实例） | `def`（定义对象） |
| **工厂函数** | `() => toolInstance` | `(_config) => defineTool(def, ...)` |
| **调用结果** | 返回同一个对象 | 创建新对象 |
| **内存模型** | 单例模式 | 工厂模式 |

### 5.2 图示对比

#### tool() - 单例模式

```
┌─────────────────────────────────────┐
│  tool() 执行                        │
├─────────────────────────────────────┤
│  创建: toolInstance (0x1000)        │
│  注册: () => 0x1000                 │
│  返回: 0x1000                       │
└─────────────────────────────────────┘
            │
            │ 事后修改
            ↓
┌─────────────────────────────────────┐
│  toolInstance (0x1000)              │
│  .prompt = PROMPT ✓                 │
└─────────────────────────────────────┘
            │
            │ Agent 使用
            ↓
┌─────────────────────────────────────┐
│  registry.create()                  │
│    → 调用 () => 0x1000              │
│    → 返回 0x1000 (同一个引用)       │
│    → .prompt 存在 ✓                 │
└─────────────────────────────────────┘
```

#### defineTool() - 工厂模式

```
┌─────────────────────────────────────┐
│  defineTool(def) 执行               │
├─────────────────────────────────────┤
│  创建: toolInstance1 (0x1000)       │
│  注册: (_config) => defineTool(def) │
│  返回: 0x1000                       │
└─────────────────────────────────────┘
            │
            │ 事后修改
            ↓
┌─────────────────────────────────────┐
│  toolInstance1 (0x1000)             │
│  .prompt = PROMPT (只在这个实例上)  │
└─────────────────────────────────────┘
            │
            │ Agent 使用
            ↓
┌─────────────────────────────────────┐
│  registry.create()                  │
│    → 调用 defineTool(def)           │
│    → 创建 toolInstance2 (0x2000)    │
│    → def 里没有 prompt 字段         │
│    → 返回 0x2000 (新对象)           │
│    → .prompt 不存在 ✗               │
└─────────────────────────────────────┘
```

### 5.3 为什么设计不同？

#### tool() 的设计意图

**目标**: 简单、快速、性能优先

**优点**:
- 单例模式，内存效率高
- 无需重复创建对象
- 适合配置固定的工具

**缺点**:
- 不支持动态配置
- 所有使用方共享同一个实例

#### defineTool() 的设计意图

**目标**: 灵活、可配置、支持动态创建

**优点**:
- 支持 `config` 参数，可根据不同配置创建不同实例
- 实例隔离，避免状态污染
- 适合需要动态配置的工具（如 `task_run`）

**缺点**:
- 每次创建新实例，内存开销大
- 事后修改属性无效

**实际案例**: `task_run` 工具需要根据不同的 `templates` 配置创建不同实例

```typescript
// src/tools/task_run/index.ts
export function createTaskRunTool(templates: AgentTemplate[]) {
  return tool({
    name: 'task_run',
    // ...
  });
  // 可以根据不同的 templates 生成不同的 prompt
}

// 使用时
const tool1 = registry.create('task_run', { templates: [t1, t2] });
const tool2 = registry.create('task_run', { templates: [t3, t4] });
// 两个实例可以有不同的配置
```

---

## 6. prompt 属性处理差异

### 6.1 tool() 处理 prompt

**方式 1: 事后添加（有效）**

```typescript
export const FsWrite = tool({
  name: 'fs_write',
  description: 'Write file',
  parameters: z.object({
    path: z.string(),
    content: z.string(),
  }),
  async execute(args, ctx) {
    await ctx.sandbox.fs.write(args.path, args.content);
    return { ok: true };
  },
});

FsWrite.prompt = PROMPT;  // ✅ 有效
```

**原因**: `tool()` 返回的是单例，工厂函数返回同一个对象引用。

**验证**:

```typescript
const tool1 = registry.create('fs_write');
const tool2 = registry.create('fs_write');
console.log(tool1 === tool2);  // true
console.log(tool1.prompt);     // PROMPT
console.log(tool2.prompt);     // PROMPT
```

---

### 6.2 defineTool() 处理 prompt

**方式 1: 事后添加（无效）**

```typescript
export const createSchedulesBatchTool = defineTool({
  name: 'create_schedules_batch',
  description: 'Batch create schedules',
  params: { /* ... */ },
  async exec(args, ctx) { /* ... */ },
});

(createSchedulesBatchTool as any).prompt = PROMPT;  // ❌ 无效
```

**原因**: `defineTool()` 的工厂函数每次重建实例，新实例基于 `def`，而 `def` 里没有 `prompt`。

**验证**:

```typescript
const tool1 = registry.create('create_schedules_batch');
const tool2 = registry.create('create_schedules_batch');
console.log(tool1 === tool2);  // false (不同实例)
console.log(createSchedulesBatchTool.prompt);  // PROMPT (原实例有)
console.log(tool1.prompt);     // undefined (新实例没有)
console.log(tool2.prompt);     // undefined (新实例没有)
```

**方式 2: 定义时包含（有效）**

```typescript
export const createSchedulesBatchTool = defineTool({
  name: 'create_schedules_batch',
  description: 'Batch create schedules',
  prompt: PROMPT,  // ✅ 在这里定义
  params: { /* ... */ },
  async exec(args, ctx) { /* ... */ },
});
```

**原因**: `prompt` 在 `def` 对象中，每次 `defineTool(def)` 都会创建包含 `prompt` 的新实例。

**验证**:

```typescript
const tool1 = registry.create('create_schedules_batch');
const tool2 = registry.create('create_schedules_batch');
console.log(tool1 === tool2);  // false (不同实例)
console.log(tool1.prompt);     // PROMPT ✅
console.log(tool2.prompt);     // PROMPT ✅
```

---

## 7. 使用场景建议

### 7.1 何时使用 tool()

**适用场景**:
- ✅ 工具配置简单且固定
- ✅ 需要运行时类型验证（Zod）
- ✅ 对性能有要求（单例模式）
- ✅ 可以事后添加属性（如 prompt）

**示例**: 内置工具（fs_read, fs_write, fs_edit 等）

```typescript
import { tool } from '@kode/sdk';
import { z } from 'zod';
import { PROMPT } from './prompt';

export const FsRead = tool({
  name: 'fs_read',
  description: 'Read file contents',
  parameters: z.object({
    path: z.string(),
  }),
  async execute(args, ctx) {
    const content = await ctx.sandbox.fs.read(args.path);
    return { content };
  },
  metadata: {
    readonly: true,
  },
});

FsRead.prompt = PROMPT;  // 可以这样添加
```

---

### 7.2 何时使用 defineTool()

**适用场景**:
- ✅ 工具可能需要动态配置
- ✅ 不需要复杂的运行时验证
- ✅ 希望接口定义简洁
- ✅ prompt 可以在定义时确定

**示例**: 自定义业务工具

```typescript
import { defineTool } from '@kode/sdk';
import { DESCRIPTION, PROMPT } from './prompt';

export const createSchedulesBatchTool = defineTool({
  name: 'create_schedules_batch',
  description: DESCRIPTION,
  prompt: PROMPT,  // ⭐ 必须在这里定义
  params: {
    date: {
      type: 'string',
      description: '日期，格式 YYYY-MM-DD',
    },
    natural_language: {
      type: 'string',
      description: '用户的自然语言描述',
    },
    slot_interval: {
      type: 'number',
      description: '时间槽间隔（分钟）',
      required: false,
    },
  },
  attributes: { readonly: false },
  async exec(args, ctx) {
    // 实现逻辑
  },
});
```

---

### 7.3 选择决策树

```
开始
  │
  ├─ 需要 Zod 验证？
  │   └─ 是 → 使用 tool()
  │
  ├─ 需要动态配置？
  │   └─ 是 → 使用 defineTool()
  │
  ├─ 希望接口简洁？
  │   └─ 是 → 使用 defineTool()
  │
  ├─ 对性能有极高要求？
  │   └─ 是 → 使用 tool()
  │
  └─ 默认推荐
      └─ defineTool() (更符合直觉，接口简单)
```

---

## 8. 实际代码示例

### 8.1 tool() 完整示例

```typescript
// src/tools/fs_write/index.ts
import { tool } from '../tool';
import { z } from 'zod';
import { patterns } from '../type-inference';
import { DESCRIPTION, PROMPT } from './prompt';
import { ToolContext } from '../../core/types';

export const FsWrite = tool({
  name: 'fs_write',
  description: DESCRIPTION,
  parameters: z.object({
    path: patterns.filePath('Path to file within the sandbox'),
    content: z.string().describe('Content to write'),
  }),
  async execute(args, ctx: ToolContext) {
    const { path, content } = args;

    // 文件新鲜度验证
    const freshness = await ctx.services?.filePool?.validateWrite(path);
    if (freshness && !freshness.isFresh) {
      return {
        ok: false,
        error: 'File appears to have changed externally.',
      };
    }

    // 写入文件
    await ctx.sandbox.fs.write(path, content);
    await ctx.services?.filePool?.recordEdit(path);

    const bytes = Buffer.byteLength(content, 'utf8');
    const lines = content.split('\n').length;

    return {
      ok: true,
      path,
      bytes,
      lines,
    };
  },
  metadata: {
    readonly: false,
    version: '1.0',
  },
});

// 事后添加 prompt（有效）
FsWrite.prompt = PROMPT;
```

---

### 8.2 defineTool() 完整示例

```typescript
// server/tools/create_schedules_batch/index.ts
import { defineTool } from '../../../src';
import { DESCRIPTION, PROMPT } from './prompt';
import { BatchCreateInput } from './types';
import { validateInput } from './validator';
import { executeBatchCreate } from './executor';

export const createSchedulesBatchTool = defineTool({
  name: 'create_schedules_batch',
  description: DESCRIPTION,
  prompt: PROMPT,  // ⭐ 必须在定义中包含
  params: {
    date: {
      type: 'string',
      description: '日期，格式 YYYY-MM-DD',
    },
    natural_language: {
      type: 'string',
      description: '用户的自然语言描述',
    },
    slot_interval: {
      type: 'number',
      description: '时间槽间隔（分钟）',
      required: false,
    },
  },
  attributes: { readonly: false },
  async exec(args: BatchCreateInput, ctx) {
    // 验证输入
    const validation = validateInput(args);
    if (!validation.valid) {
      return { ok: false, error: validation.error };
    }
    
    // 执行批量创建
    return executeBatchCreate(args, ctx);
  },
});

// ❌ 不要这样做，无效
// (createSchedulesBatchTool as any).prompt = PROMPT;
```

---

### 8.3 prompt 定义示例

```typescript
// prompt.ts
export const DESCRIPTION = '将用户描述的日程相关自然语言转化为结构化的时间表格式';

export const PROMPT = `使用此工具批量创建多个日程记录。

核心特点：
- 一次性创建多条日程，减少调用次数
- 自动解析时间段、拆分时间槽、提取任务和备注
- 智能匹配任务名称到已有任务

📝 参数说明：
- date (必需): 日期，格式 YYYY-MM-DD
- natural_language (必需): 用户的自然语言描述
- slot_interval (可选): 时间槽间隔（分钟），默认30

🎯 使用示例：
create_schedules_batch({
  date: "2025-10-18",
  natural_language: "我下午1点半到5点在开发工具"
})

💡 最佳使用场景：
- 用户口语化描述一段时间的活动
- 系统会自动处理所有细节
`;
```

---

## 9. 总结对比表

### 9.1 核心差异

| 维度 | tool() | defineTool() |
|------|--------|--------------|
| **定义文件** | `src/tools/tool.ts` | `src/tools/define.ts` |
| **参数验证** | Zod (运行时验证) | 自动 Schema (类型推断) |
| **接口复杂度** | 中等 | 简单 |
| **注册机制** | 单例模式 | 工厂模式 |
| **闭包捕获** | `toolInstance` | `def` |
| **工厂函数** | `() => instance` | `() => defineTool(def)` |
| **每次调用** | 返回同一对象 | 创建新对象 |
| **prompt 事后添加** | ✅ 有效 | ❌ 无效 |
| **prompt 定义时添加** | ❌ 不支持 | ✅ 支持 |
| **动态配置** | ❌ 不支持 | ✅ 支持 |
| **内存效率** | 高（单例） | 低（多实例） |
| **性能** | 优秀 | 良好 |
| **适用场景** | 内置工具 | 业务工具 |

---

### 9.2 prompt 属性处理对比

| 操作 | tool() | defineTool() |
|------|--------|--------------|
| **在 def 中定义** | ❌ 接口不支持 | ✅ 接口支持 |
| **事后添加** | ✅ 有效 | ❌ 无效 |
| **Agent 能看到** | ✅ 能（同一对象） | ✅ 能（如果在 def 中定义）<br/>❌ 不能（如果事后添加） |

---

### 9.3 注册机制对比

| 维度 | tool() | defineTool() |
|------|--------|--------------|
| **设计模式** | Singleton（单例） | Factory（工厂） |
| **实例数量** | 1 个 | 多个 |
| **对象引用** | 所有调用共享 | 每次调用独立 |
| **状态隔离** | 无（共享状态） | 有（独立状态） |
| **可配置性** | 静态 | 动态 |

---

## 10. 官方文档参考

### 10.1 官方文档位置

- **简化工具 API**: `docs/simplified-tools.md`
- **示例代码**: `examples/tooling/simplified-tools.ts`
- **测试用例**: `tests/tool-define.test.ts`

### 10.2 官方说明摘录

**`docs/simplified-tools.md` 第 1-11 行**:

```markdown
# 简化的工具定义 API

## 概述

Kode SDK v2.7 引入了全新的工具定义 API，大幅简化了开发体验：

- ✅ **自动 Schema 生成**：从类型定义自动生成 JSON Schema，无需手动编写
- ✅ **简化的属性标记**：用 `readonly`/`noEffect` 替代复杂的 `access`/`mutates`/`safe`
- ✅ **自定义事件支持**：工具内可发射自定义事件到 monitor 通道
- ✅ **向后兼容**：完全兼容现有的 `ToolInstance` 接口
```

---

## 11. 结论与建议

### 11.1 核心发现

1. **tool() 和 defineTool() 都是官方函数**，均在 `src/index.ts` 中导出
2. **注册机制不同**是导致 prompt 处理差异的根本原因：
   - `tool()`: 单例模式，工厂函数返回同一实例
   - `defineTool()`: 工厂模式，工厂函数重建新实例
3. **prompt 属性**:
   - `tool()`: 可以事后添加（因为返回同一对象）
   - `defineTool()`: 必须在定义时包含（因为基于 def 重建）

### 11.2 最佳实践

#### 对于 tool() 用户

```typescript
// ✅ 推荐：事后添加
export const MyTool = tool({ /* ... */ });
MyTool.prompt = PROMPT;
```

#### 对于 defineTool() 用户

```typescript
// ✅ 推荐：定义时包含
export const MyTool = defineTool({
  /* ... */,
  prompt: PROMPT,  // 必须在这里
});

// ❌ 错误：事后添加（无效）
// (MyTool as any).prompt = PROMPT;
```

### 11.3 迁移建议

如果你的代码使用 `defineTool()` 且事后添加 `prompt`：

1. **检查代码**:
   ```bash
   grep -r "defineTool" --include="*.ts" | grep -l "\.prompt = "
   ```

2. **修改方式**:
   - 将 `prompt` 移到 `defineTool()` 的参数对象中
   - 删除事后添加的代码

3. **验证**:
   ```typescript
   const tool = registry.create('your_tool_name');
   console.assert(tool.prompt !== undefined, 'prompt 应该存在');
   ```

---

**报告结束**

如有疑问，请参考源码：
- `src/tools/tool.ts`
- `src/tools/define.ts`
- `docs/simplified-tools.md`

