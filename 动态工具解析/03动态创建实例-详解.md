# 动态创建实例 - 详细解释

## 1. 什么是动态创建实例？

**动态创建实例** = 根据不同的参数/配置，创建具有不同行为的工具实例

对比：
- **静态实例**：一个模具，造出的所有产品都一样
- **动态实例**：一个可调节的模具，根据设置造出不同的产品

---

## 2. 实际场景示例

### 场景 1: 餐厅点餐系统 🍕

#### 静态实例（tool()）

```typescript
// 只有一个披萨制作器，配置固定
const pizzaMaker = tool({
  name: 'make_pizza',
  description: 'Make a Margherita pizza',
  parameters: z.object({
    size: z.enum(['small', 'medium', 'large']),
  }),
  async execute(args) {
    // 固定配置：只能做 Margherita 披萨
    return {
      type: 'Margherita',  // 固定
      toppings: ['tomato', 'mozzarella', 'basil'],  // 固定
      size: args.size,
    };
  },
});

// 问题：如果要做其他类型的披萨怎么办？
// 答：不行，配置是固定的
```

#### 动态实例（defineTool()）

```typescript
// 可配置的披萨制作器
const createPizzaMaker = (config: { 
  type: string; 
  toppings: string[]; 
}) => {
  return defineTool({
    name: 'make_pizza',
    description: `Make a ${config.type} pizza`,
    params: {
      size: { type: 'string', enum: ['small', 'medium', 'large'] },
    },
    async exec(args) {
      return {
        type: config.type,      // 根据配置动态决定
        toppings: config.toppings,  // 根据配置动态决定
        size: args.size,
      };
    },
  });
};

// 使用：根据不同配置创建不同实例
const margheritaMaker = createPizzaMaker({
  type: 'Margherita',
  toppings: ['tomato', 'mozzarella', 'basil'],
});

const pepperoniMaker = createPizzaMaker({
  type: 'Pepperoni',
  toppings: ['tomato', 'mozzarella', 'pepperoni'],
});

// 两个制作器，行为不同！
```

---

### 场景 2: 多语言翻译工具 🌍

#### 静态实例

```typescript
// 固定翻译成英语
const translator = tool({
  name: 'translate',
  description: 'Translate to English',
  parameters: z.object({
    text: z.string(),
  }),
  async execute(args) {
    return await translateAPI(args.text, 'en');  // 目标语言固定
  },
});
```

#### 动态实例

```typescript
// 可配置目标语言
const createTranslator = (targetLanguage: string) => {
  return defineTool({
    name: `translate_to_${targetLanguage}`,
    description: `Translate to ${targetLanguage}`,
    params: {
      text: { type: 'string' },
    },
    async exec(args) {
      return await translateAPI(args.text, targetLanguage);  // 动态语言
    },
  });
};

// 创建多个不同的翻译器
const englishTranslator = createTranslator('en');
const chineseTranslator = createTranslator('zh');
const japaneseTranslator = createTranslator('ja');

// 每个翻译器的行为不同
```

---

### 场景 3: 真实案例 - task_run 工具 🎯

这是 Kode SDK 中的真实案例：

#### 业务需求

Agent 需要把复杂任务委托给子 Agent，但不同的子 Agent 有不同的能力：

- **代码专家 Agent**: 只能用文件操作工具
- **数据分析 Agent**: 只能用数据库和可视化工具
- **全能 Agent**: 可以用所有工具

#### 问题

如果用静态实例，`task_run` 工具只能创建一种类型的子 Agent。

#### 解决方案：动态创建

```typescript
// src/tools/task_run/index.ts (简化版)

// 定义不同的 Agent 模板
interface AgentTemplate {
  id: string;
  tools: string[];  // 这个 Agent 可以用哪些工具
  whenToUse: string;
}

// 创建 task_run 工具的工厂函数
export function createTaskRunTool(templates: AgentTemplate[]) {
  
  // 根据 templates 生成不同的 prompt
  const prompt = generatePrompt(templates);
  
  return tool({
    name: 'task_run',
    description: 'Delegate task to sub-agent',
    parameters: z.object({
      description: z.string(),
      prompt: z.string(),
      agentTemplateId: z.string(),  // 选择哪个模板
    }),
    async execute(args, ctx) {
      // 根据 agentTemplateId 找到对应的模板
      const template = templates.find(t => t.id === args.agentTemplateId);
      
      if (!template) {
        throw new Error(`Template ${args.agentTemplateId} not found`);
      }
      
      // 使用这个模板的工具集创建子 Agent
      return await ctx.agent.delegateTask({
        templateId: template.id,
        prompt: args.prompt,
        tools: template.tools,  // 不同模板，不同工具！
      });
    },
  });
  
  // 工具的 prompt 也是动态的
  (tool as any).prompt = prompt;
  return tool;
}

// 使用场景 1: 代码项目
const codeProjectTemplates = [
  {
    id: 'code-expert',
    tools: ['fs_read', 'fs_write', 'fs_edit', 'grep'],
    whenToUse: 'For code editing tasks',
  },
  {
    id: 'test-expert',
    tools: ['fs_read', 'fs_write', 'run_tests'],
    whenToUse: 'For testing tasks',
  },
];

const taskRunForCode = createTaskRunTool(codeProjectTemplates);

// 使用场景 2: 数据分析项目
const dataProjectTemplates = [
  {
    id: 'data-analyst',
    tools: ['sql_query', 'data_viz', 'stats'],
    whenToUse: 'For data analysis tasks',
  },
  {
    id: 'ml-expert',
    tools: ['train_model', 'predict', 'evaluate'],
    whenToUse: 'For machine learning tasks',
  },
];

const taskRunForData = createTaskRunTool(dataProjectTemplates);

// 两个 task_run 工具，行为完全不同！
```

#### 实际使用

```typescript
// Agent 1: 代码项目
const codeAgent = new Agent({
  tools: ['task_run', 'fs_read', 'fs_write'],
  // task_run 只能创建 code-expert 或 test-expert
});

await codeAgent.run('帮我重构这个项目');
// Agent 内部调用：
// task_run({ 
//   agentTemplateId: 'code-expert',  // 只能选这两个之一
//   prompt: '重构 user.ts 文件' 
// })

// Agent 2: 数据项目
const dataAgent = new Agent({
  tools: ['task_run', 'sql_query'],
  // task_run 只能创建 data-analyst 或 ml-expert
});

await dataAgent.run('分析这份数据');
// Agent 内部调用：
// task_run({ 
//   agentTemplateId: 'data-analyst',  // 只能选这两个之一
//   prompt: '分析用户行为数据' 
// })
```

---

## 3. 为什么需要动态创建？

### 问题：静态实例的局限

```typescript
// 如果用静态实例
const taskRun = tool({
  name: 'task_run',
  // 问题：templates 是固定的，无法根据不同项目调整
  templates: [/* 固定配置 */],
  // ...
});

// 所有 Agent 都用同一个配置
const agent1 = new Agent({ tools: ['task_run'] });  // 被迫用固定配置
const agent2 = new Agent({ tools: ['task_run'] });  // 被迫用固定配置
```

### 解决：动态创建实例

```typescript
// 不同项目创建不同配置的 task_run
const taskRunForCode = createTaskRunTool(codeTemplates);
const taskRunForData = createTaskRunTool(dataTemplates);

// 不同 Agent 用不同的 task_run
const agent1 = new Agent({ tools: [taskRunForCode] });  // 代码专用配置
const agent2 = new Agent({ tools: [taskRunForData] });  // 数据专用配置
```

---

## 4. 动态创建的实现原理

### defineTool() 的工厂模式

```typescript
// defineTool() 注册时
globalToolRegistry.register('tool_name', (config) => {
  // 工厂函数：根据 config 动态创建
  return defineTool(def, { autoRegister: false });
});

// 使用时传入不同的 config
const tool1 = registry.create('tool_name', { mode: 'simple' });
const tool2 = registry.create('tool_name', { mode: 'advanced' });
// 每次都是新实例，可以有不同的行为
```

### tool() 无法动态创建

```typescript
// tool() 注册时
const toolInstance = { /* 固定配置 */ };
globalToolRegistry.register('tool_name', () => toolInstance);

// 使用时无法改变配置
const tool1 = registry.create('tool_name', { mode: 'simple' });   // config 被忽略
const tool2 = registry.create('tool_name', { mode: 'advanced' }); // config 被忽略
// 永远返回同一个实例，配置固定
```

---

## 5. 完整对比示例

### 场景：数据库连接工具

#### 需求

不同环境需要连接不同的数据库：
- 开发环境：连接本地 MySQL
- 测试环境：连接测试 PostgreSQL  
- 生产环境：连接生产 PostgreSQL

#### 静态实例（不灵活）

```typescript
const dbQuery = tool({
  name: 'db_query',
  description: 'Query database',
  parameters: z.object({
    sql: z.string(),
  }),
  async execute(args) {
    // 问题：数据库配置写死了
    const connection = await mysql.connect({
      host: 'localhost',
      database: 'dev_db',
    });
    return await connection.query(args.sql);
  },
});

// 所有环境都连接 dev_db，无法改变
```

#### 动态实例（灵活）

```typescript
// 工具工厂函数
function createDbQueryTool(dbConfig: {
  type: 'mysql' | 'postgres';
  host: string;
  database: string;
}) {
  return defineTool({
    name: 'db_query',
    description: `Query ${dbConfig.type} database: ${dbConfig.database}`,
    params: {
      sql: { type: 'string' },
    },
    async exec(args) {
      // 根据配置连接不同的数据库
      const connection = await (dbConfig.type === 'mysql'
        ? mysql.connect(dbConfig)
        : postgres.connect(dbConfig)
      );
      return await connection.query(args.sql);
    },
  });
}

// 不同环境创建不同的工具实例
const devDbQuery = createDbQueryTool({
  type: 'mysql',
  host: 'localhost',
  database: 'dev_db',
});

const testDbQuery = createDbQueryTool({
  type: 'postgres',
  host: 'test.example.com',
  database: 'test_db',
});

const prodDbQuery = createDbQueryTool({
  type: 'postgres',
  host: 'prod.example.com',
  database: 'prod_db',
});

// 使用
const devAgent = new Agent({ tools: [devDbQuery] });    // 连接开发数据库
const testAgent = new Agent({ tools: [testDbQuery] });  // 连接测试数据库
const prodAgent = new Agent({ tools: [prodDbQuery] });  // 连接生产数据库
```

---

## 6. 核心概念总结

### 静态实例 = 固定配置

```
创建 → [固定实例] → 使用
         ↓
      配置 A
      
所有使用方都用配置 A
```

### 动态实例 = 可变配置

```
创建 → [工厂函数] → 使用时传入配置 A → [实例 A]
         ↓
         └─────────→ 使用时传入配置 B → [实例 B]
         └─────────→ 使用时传入配置 C → [实例 C]
         
不同配置，不同实例，不同行为
```

---

## 7. 何时需要动态创建？

### ✅ 需要动态创建的场景

1. **多环境部署**：开发/测试/生产环境配置不同
2. **多租户系统**：不同用户/组织有不同配置
3. **可插拔架构**：根据项目类型加载不同工具集
4. **A/B 测试**：同一工具不同版本/策略
5. **权限控制**：不同角色看到不同的工具行为

### ❌ 不需要动态创建的场景

1. **简单工具**：配置固定，不会改变
2. **单一用途**：只有一种使用方式
3. **无状态工具**：不依赖外部配置

---

## 8. 实际代码对比

### tool() - 静态配置

```typescript
// 文件系统工具 - 配置固定
export const FsRead = tool({
  name: 'fs_read',
  description: 'Read file',
  parameters: z.object({
    path: z.string(),
  }),
  async execute(args, ctx) {
    // 配置固定：总是从 sandbox 读取
    return await ctx.sandbox.fs.read(args.path);
  },
});

// 所有 Agent 都用同样的方式读文件
```

### defineTool() - 动态配置

```typescript
// API 调用工具 - 配置动态
function createApiTool(apiConfig: {
  baseURL: string;
  apiKey: string;
  timeout: number;
}) {
  return defineTool({
    name: 'api_call',
    description: `Call API at ${apiConfig.baseURL}`,
    params: {
      endpoint: { type: 'string' },
      method: { type: 'string' },
      body: { type: 'object', required: false },
    },
    async exec(args) {
      // 根据配置调用不同的 API
      return await fetch(`${apiConfig.baseURL}${args.endpoint}`, {
        method: args.method,
        headers: {
          'Authorization': `Bearer ${apiConfig.apiKey}`,
        },
        timeout: apiConfig.timeout,
        body: args.body ? JSON.stringify(args.body) : undefined,
      });
    },
  });
}

// 不同的 API 服务
const githubAPI = createApiTool({
  baseURL: 'https://api.github.com',
  apiKey: process.env.GITHUB_TOKEN,
  timeout: 5000,
});

const stripeAPI = createApiTool({
  baseURL: 'https://api.stripe.com',
  apiKey: process.env.STRIPE_KEY,
  timeout: 10000,
});

// 不同 Agent 调用不同的 API
```

---

## 总结

**动态创建实例** = 根据不同参数/配置创建具有不同行为的对象

**关键特征**：
- ✅ 同一个定义，不同的配置
- ✅ 创建多个实例，行为各异
- ✅ 灵活适应不同场景

**典型应用**：
- 多环境配置（开发/测试/生产）
- 多租户系统（不同用户不同配置）
- 可插拔架构（根据项目动态加载）
- 权限控制（不同角色不同权限）

**在 Kode SDK 中**：
- `tool()` → 静态实例（配置固定）
- `defineTool()` → 动态实例（配置灵活）

