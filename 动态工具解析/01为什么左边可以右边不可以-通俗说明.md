
# 为什么左边可以被看到，右边不可以？ 🤔

## 问题描述

**左边（fs_write）**：事后添加 `prompt`，Agent **能看到** ✅
**右边（create_schedules_batch）**：事后添加 `prompt`，Agent **看不到** ❌

为什么会这样？🤷‍♂️

---

## 🎭 通俗比喻：复印机 vs 原件传递

### 左边（fs_write）- 传递原件 📄

想象一个**传递原件**的场景：

```
1. 创建一份文档（工具实例）
   const 文档 = 制作工具("fs_write")
   
2. 在文档上贴便签（添加 prompt）
   文档.prompt = "使用说明"
   
3. 把文档放入档案柜（注册到 registry）
   档案柜.存入("fs_write", () => 文档)  ← 注意：返回的是【原件】
   
4. Agent 来借文档
   const 借到的文档 = 档案柜.取出("fs_write")
   → 拿到的是【原件】，上面有便签 ✅
```

**关键**：档案柜里存的是**原件的引用**，每次取出都是**同一份文档**。
所以你贴的便签当然在上面！✅

---

### 右边（create_schedules_batch）- 复印文档 📋

想象一个**复印文档**的场景：

```
1. 创建一份文档模板（工具定义）
   const 模板 = {
     name: "create_schedules_batch",
     description: "...",
     // 注意：模板里【没有】prompt 字段
   }
   
2. 用模板制作文档（工具实例）
   const 文档 = 制作工具(模板)
   
3. 在文档上贴便签（添加 prompt）
   文档.prompt = "使用说明"
   
4. 把【模板】放入档案柜（注册）
   档案柜.存入("create_schedules_batch", () => {
     return 制作工具(模板)  ← 注意：每次都【复印】一份新文档
   })
   
5. Agent 来借文档
   const 借到的文档 = 档案柜.取出("create_schedules_batch")
   → 拿到的是【复印件】，是用模板新做的，没有便签 ❌
```

**关键**：档案柜里存的是**模板 + 复印机**，每次取出都**复印一份新的**。
新复印的文档上，当然没有你之前贴的便签！❌

---

## 🔍 代码层面的解释

### 左边 - `tool()` 函数

```typescript
// 1. 创建实例
export const FsWrite = tool({
  name: 'fs_write',
  description: '...',
  // ...
});

// 2. 事后添加 prompt
FsWrite.prompt = PROMPT;

// 3. tool() 内部的注册逻辑（简化版）
function tool(definition) {
  const toolInstance = { /* 工具实例 */ };
  
  // 注册：返回同一个实例
  registry.register(definition.name, () => toolInstance);  // ← 返回【原件】
  
  return toolInstance;
}

// 4. Agent 使用时
const tool = registry.create('fs_write');  
// → 得到的是 toolInstance（原件），有 prompt ✅
```

---

### 右边 - `defineTool()` 函数

```typescript
// 1. 创建实例
export const createSchedulesBatchTool = defineTool({
  name: 'create_schedules_batch',
  description: '...',
  // 注意：这里没有 prompt 字段
});

// 2. 事后添加 prompt
(createSchedulesBatchTool as any).prompt = PROMPT;

// 3. defineTool() 内部的注册逻辑（简化版）
function defineTool(def) {
  const toolInstance = { /* 工具实例 */ };
  
  // 注册：返回一个【复印】新实例的函数
  registry.register(def.name, () => {
    return defineTool(def);  // ← 【复印】一份新的，def 里没有 prompt
  });
  
  return toolInstance;
}

// 4. Agent 使用时
const tool = registry.create('create_schedules_batch');
// → 调用 defineTool(def) 复印了一份新实例
// → 新实例是根据 def 创建的，def 里没有 prompt ❌
```

---

## 📊 对比表格

| 维度 | 左边（fs_write） | 右边（create_schedules_batch） |
|------|-----------------|-------------------------------|
| **使用函数** | `tool()` | `defineTool()` |
| **注册方式** | `() => toolInstance` | `() => defineTool(def)` |
| **返回内容** | 原件（同一个对象） | 复印件（新对象） |
| **事后添加 prompt** | ✅ 有效 | ❌ 无效 |
| **比喻** | 图书馆借书（原件） | 复印店复印（副本） |

---

## 🎯 为什么要这样设计？

### `tool()` - 简单场景
- 工具配置简单，不需要动态参数
- 可以直接返回同一个实例
- 性能更好（不用重复创建）

### `defineTool()` - 灵活场景
- 工具可能需要根据配置动态创建（比如 task_run 需要传入 templates）
- 所以设计成"每次都重新创建"，可以传入不同的 config
- 代价：事后添加的属性会丢失

---

## ✅ 解决方案

### 方案1：把 prompt 放到定义里（推荐）✅

```typescript
// ❌ 错误方式
export const createSchedulesBatchTool = defineTool({
  name: 'create_schedules_batch',
  description: DESCRIPTION,
  // 没有 prompt
});
(createSchedulesBatchTool as any).prompt = PROMPT;  // 会丢失

// ✅ 正确方式
export const createSchedulesBatchTool = defineTool({
  name: 'create_schedules_batch',
  description: DESCRIPTION,
  prompt: PROMPT,  // 在这里传入
});
```

### 方案2：改用 `tool()` 函数（如果不需要动态配置）

```typescript
import { tool } from '../../../src';
import { z } from 'zod';

export const createSchedulesBatchTool = tool({
  name: 'create_schedules_batch',
  description: DESCRIPTION,
  parameters: z.object({
    date: z.string(),
    natural_language: z.string(),
    slot_interval: z.number().optional(),
  }),
  async execute(args, ctx) {
    // ...
  },
});

createSchedulesBatchTool.prompt = PROMPT;  // 这样就可以
```

---

## 💡 一句话总结

**左边能看到**：因为 `tool()` 把**原件**存进档案柜，你贴的便签还在上面。

**右边看不到**：因为 `defineTool()` 把**复印机**存进档案柜，每次取出都是**新复印的**，你贴在原件上的便签当然不在复印件上。

**解决办法**：把便签贴在模板上（在定义时传入 prompt），这样每次复印出来的文档都有便签！

---

## 🔧 检查你的代码

### 快速检查方法

1. 找到你的工具定义文件（`index.ts`）
2. 看第一行导入：
   ```typescript
   import { tool } from '...'         // ← 用的是 tool()
   import { defineTool } from '...'   // ← 用的是 defineTool()
   ```
3. 如果是 `defineTool()`，检查：
   - ✅ prompt 在 `defineTool({ ... prompt: PROMPT ... })` 里
   - ❌ prompt 在外面 `(tool as any).prompt = PROMPT` → 需要移进去

### 批量检查命令

在项目根目录运行：

```bash
# 查找所有使用 defineTool 但事后添加 prompt 的文件
grep -r "defineTool" --include="*.ts" | grep -l "\.prompt = "
```

如果有输出，说明这些文件需要修复。

---

希望这份说明让你理解了为什么会有这个问题！🎉

