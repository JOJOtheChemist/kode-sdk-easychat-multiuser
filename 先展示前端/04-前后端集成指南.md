# 前后端集成指南

## 概述

本文档详细说明如何将前端（端口 3020）与后端 Kode-SDK（GLM-4.5-air 模型）连接起来，实现完整的对话功能。

---

## 架构图

```
┌─────────────────┐         ┌──────────────────┐         ┌─────────────────┐
│   前端 (3020)   │         │  WebSocket       │         │  Kode-SDK       │
│   React + SIO   │◄────────┤  Bridge (3001)   │◄────────┤  GLM-4.5-air    │
│                 │ Socket  │  适配层          │  Events │                 │
└─────────────────┘         └──────────────────┘         └─────────────────┘
```

### 数据流

```
用户输入
   ↓
前端 ChatInputField
   ↓
Socket.IO emit("oh_user_action")
   ↓
WebSocket Bridge 接收
   ↓
转换为 Kode-SDK 格式
   ↓
Agent.send(message)
   ↓
GLM-4.5-air 模型处理
   ↓
Agent 事件流（Progress + Monitor）
   ↓
转换为前端格式
   ↓
Socket.IO emit("oh_event")
   ↓
前端接收并显示
```

---

## 一、后端服务器已创建 ✅

### 1.1 WebSocket Bridge 服务器

**位置**: `Kode-sdk/server/websocket-bridge.ts`

**功能**:
- ✅ Socket.IO 服务器（端口 3001）
- ✅ Kode-SDK Agent 管理
- ✅ 消息格式转换（前端 ↔ Kode-SDK）
- ✅ 事件流转发（Kode-SDK → 前端）
- ✅ GLM-4.5-air 模型集成
- ✅ 工具调用支持（TODO、文件系统）

### 1.2 已安装的依赖

```json
{
  "dependencies": {
    "express": "^4.18.2",
    "socket.io": "^4.6.1",
    "cors": "^2.8.5"
  },
  "devDependencies": {
    "@types/express": "^4.17.17",
    "@types/cors": "^2.8.13",
    "ts-node-dev": "^2.0.0"
  }
}
```

---

## 二、前端配置

### 2.1 创建环境变量文件

在 `frontend/` 目录下创建 `.env.local` 文件：

```bash
# frontend/.env.local
VITE_BACKEND_BASE_URL=localhost:3001
```

### 2.2 WebSocket 连接配置

前端已经配置好 Socket.IO 客户端，会自动连接到 `VITE_BACKEND_BASE_URL` 指定的地址。

**连接逻辑** (`frontend/src/context/ws-client-provider.tsx`):

```typescript
const baseUrl = 
  (import.meta.env.VITE_BACKEND_BASE_URL as string | undefined) ||
  window?.location.host;

const sio = io(baseUrl, {
  transports: ["websocket"],
  path: "/socket.io",
  query: {
    conversationId: conversationId,
    // ... 其他参数
  }
});
```

---

## 三、启动步骤

### 3.1 启动后端服务器

```bash
# 进入后端目录
cd /Users/yeya/FlutterProjects/kode-sdk/Kode-sdk

# 方式 1: 直接启动
npm run server

# 方式 2: 开发模式（自动重启）
npm run server:dev
```

**预期输出**:

```
╔═══════════════════════════════════════════════════════╗
║         WebSocket Bridge Server 已启动               ║
╚═══════════════════════════════════════════════════════╝

🌐 服务器地址: http://localhost:3001
🔗 前端地址: http://localhost:3020
🤖 AI 模型: glm-4.5-air

✅ 准备接收前端连接...
```

### 3.2 配置并启动前端

1. **创建环境变量文件**:

```bash
# 在 frontend 目录下
echo "VITE_BACKEND_BASE_URL=localhost:3001" > .env.local
```

2. **启动前端**:

```bash
cd /Users/yeya/FlutterProjects/kode-sdk/frontend
npm run dev
```

3. **访问前端**:

打开浏览器访问 `http://localhost:3020`

---

## 四、消息格式映射

### 4.1 前端 → 后端

**前端发送** (`Socket.IO emit`):

```typescript
// 事件名: "oh_user_action"
{
  action: "message",
  args: {
    content: "你好",
    image_urls: [],
    file_urls: [],
    timestamp: "2025-10-13T..."
  }
}
```

**后端接收并转换**:

```typescript
// 提取 content 并发送给 Agent
await agent.send(data.args.content);
```

### 4.2 后端 → 前端

#### A. 文本流事件

**Kode-SDK 事件**:
```typescript
{
  type: 'text_chunk',
  delta: '你好'
}
```

**转换为前端格式** (`Socket.IO emit: "oh_event"`):
```typescript
{
  id: "1001",
  source: "agent",
  type: "message",
  message: "你好",
  timestamp: "2025-10-13T...",
  action: "message",
  args: { content: "你好" }
}
```

#### B. 工具调用事件

**Kode-SDK 事件**:
```typescript
{
  type: 'tool:start',
  call: {
    name: 'todo_write',
    id: 'call_123',
    inputPreview: { todos: [...] }
  }
}
```

**转换为前端格式**:
```typescript
{
  id: "1002",
  source: "agent",
  type: "tool_call_start",
  message: "调用工具: todo_write",
  timestamp: "2025-10-13T...",
  action: "todo_write",
  args: { todos: [...] },
  extras: {
    tool_name: "todo_write",
    tool_id: "call_123"
  }
}
```

#### C. 完成事件

**Kode-SDK 事件**:
```typescript
{
  type: 'done',
  reason: 'completed'
}
```

**转换为前端格式**:
```typescript
{
  id: "1003",
  source: "agent",
  type: "agent_state_change",
  message: "finished",
  timestamp: "2025-10-13T...",
  extras: {
    agent_state: "finished",
    reason: "completed"
  }
}
```

---

## 五、完整测试流程

### 5.1 启动服务

1. **终端 1 - 启动后端**:
```bash
cd /Users/yeya/FlutterProjects/kode-sdk/Kode-sdk
npm run server
```

2. **终端 2 - 启动前端**:
```bash
cd /Users/yeya/FlutterProjects/kode-sdk/frontend
# 确保已创建 .env.local 文件
npm run dev
```

### 5.2 测试对话

1. **打开浏览器**: `http://localhost:3020`
2. **输入测试消息**: "你好"
3. **观察行为**:
   - ✅ 前端发送消息
   - ✅ 后端接收并处理
   - ✅ GLM-4.5-air 生成回复
   - ✅ 前端显示流式回复

### 5.3 测试工具调用

1. **输入**: "请帮我创建2个待办事项：1. 学习SDK 2. 编写文档"
2. **预期行为**:
   - ✅ 显示工具调用开始（todo_write）
   - ✅ 显示工具执行参数
   - ✅ 显示工具执行完成
   - ✅ 显示AI的最终回复

### 5.4 查看日志

**后端日志**:
```
📨 收到前端消息: { action: 'message', args: { content: '你好' } }
📤 发送事件到前端: message 你好
📤 发送事件到前端: message_end 
📤 发送事件到前端: agent_state_change finished
```

**浏览器控制台**:
- 查看 WebSocket 连接状态
- 查看接收到的事件
- 查看任何错误信息

---

## 六、常见问题排查

### 6.1 前端无法连接到后端

**症状**: 前端显示 "Failed to connect to server"

**解决方案**:

1. **检查后端是否运行**:
```bash
curl http://localhost:3001/health
# 应返回: {"status":"ok","agents":0,...}
```

2. **检查环境变量**:
```bash
# 在 frontend 目录下
cat .env.local
# 应显示: VITE_BACKEND_BASE_URL=localhost:3001
```

3. **检查端口占用**:
```bash
lsof -i :3001
# 应该显示 node 进程
```

4. **重启前端开发服务器**:
```bash
# 环境变量更改后需要重启
npm run dev
```

### 6.2 消息发送成功但无响应

**症状**: 前端发送消息，后端收到，但无回复

**检查步骤**:

1. **查看后端日志**:
```bash
# 应该看到：
📨 收到前端消息: ...
📤 发送事件到前端: ...
```

2. **检查 GLM API Key**:
```bash
# 在 Kode-sdk/server/websocket-bridge.ts 中
# 确认 GLM_API_KEY 正确
```

3. **测试 GLM 模型**:
```bash
cd Kode-sdk
npx ts-node examples/test-glm.ts
# 应该成功获得回复
```

### 6.3 工具调用失败

**症状**: AI 尝试调用工具，但失败

**检查**:

1. **查看后端日志中的错误信息**
2. **确认工具已注册** (在 `websocket-bridge.ts` 中)
3. **检查工具权限** (文件系统工具需要正确的工作目录)

### 6.4 CORS 错误

**症状**: 浏览器控制台显示 CORS 错误

**解决方案**:

后端已配置 CORS，确保 `FRONTEND_URL` 正确：

```typescript
// websocket-bridge.ts
const FRONTEND_URL = 'http://localhost:3020';
```

如果前端端口不同，修改这个值并重启后端。

---

## 七、监控与调试

### 7.1 后端日志

后端会输出详细日志：

```bash
🔌 客户端连接: socket_id_123
📝 会话 ID: default
✅ Agent 就绪: default
📨 收到前端消息: { action: 'message', ... }
🔧 调用工具: todo_write
📊 Token 使用: 输入=45, 输出=28
📤 发送事件到前端: tool_call_start 调用工具: todo_write
📤 发送事件到前端: message 我已经...
```

### 7.2 前端调试

打开浏览器开发者工具：

1. **Network 标签**:
   - 查看 WebSocket 连接（WS）
   - 查看消息收发

2. **Console 标签**:
   - 查看任何 JavaScript 错误
   - 查看 Socket.IO 日志（如果启用）

3. **React DevTools**:
   - 查看组件状态
   - 查看 Store 数据

### 7.3 健康检查端点

```bash
# 检查后端状态
curl http://localhost:3001/health

# 返回：
{
  "status": "ok",
  "agents": 1,
  "timestamp": "2025-10-13T..."
}
```

---

## 八、优化建议

### 8.1 生产环境配置

1. **使用环境变量管理敏感信息**:

```bash
# 后端
export GLM_API_KEY="your-api-key"
export PORT=3001

# 前端
VITE_BACKEND_BASE_URL=your-production-domain:3001
```

2. **启用 HTTPS**:
- 配置 SSL 证书
- 更新 CORS 设置

3. **添加请求限制**:
- 实现速率限制
- 添加身份验证

### 8.2 性能优化

1. **Agent 池管理**:
- 限制并发 Agent 数量
- 实现 Agent 超时清理

2. **消息队列**:
- 处理高并发请求
- 实现消息持久化

3. **缓存策略**:
- 缓存常用响应
- 实现会话持久化

---

## 九、API 参考

### 9.1 WebSocket 事件

#### 客户端 → 服务器

```typescript
// 事件: "oh_user_action"
socket.emit("oh_user_action", {
  action: "message",
  args: {
    content: string,
    image_urls?: string[],
    file_urls?: string[],
    timestamp?: string
  }
});
```

#### 服务器 → 客户端

```typescript
// 事件: "oh_event"
socket.on("oh_event", (data: {
  id: string,
  source: "user" | "agent",
  type: string,
  message: string,
  timestamp: string,
  action?: string,
  args?: any,
  extras?: any
}) => {
  // 处理事件
});
```

### 9.2 支持的事件类型

| 事件类型 | 说明 | 来源 |
|---------|------|------|
| `message` | 文本消息 | User/Agent |
| `message_start` | 消息开始 | Agent |
| `message_end` | 消息结束 | Agent |
| `tool_call_start` | 工具调用开始 | Agent |
| `tool_call_end` | 工具调用结束 | Agent |
| `agent_state_change` | Agent 状态变化 | Agent |
| `error` | 错误 | Agent |

---

## 十、下一步

### 10.1 功能扩展

- [ ] 添加图片上传支持
- [ ] 添加文件上传支持
- [ ] 实现会话历史
- [ ] 添加用户认证
- [ ] 实现多用户支持

### 10.2 前端增强

- [ ] 优化消息显示
- [ ] 添加工具调用可视化
- [ ] 实现消息编辑
- [ ] 添加快捷命令

### 10.3 后端增强

- [ ] 添加更多工具
- [ ] 实现工具审批流程
- [ ] 添加日志系统
- [ ] 实现监控告警

---

## 附录 A: 快速启动脚本

### 启动后端

```bash
#!/bin/bash
cd /Users/yeya/FlutterProjects/kode-sdk/Kode-sdk
npm run server
```

### 启动前端

```bash
#!/bin/bash
cd /Users/yeya/FlutterProjects/kode-sdk/frontend

# 创建环境变量文件（如果不存在）
if [ ! -f .env.local ]; then
  echo "VITE_BACKEND_BASE_URL=localhost:3001" > .env.local
fi

npm run dev
```

### 完整启动（需要 tmux 或多终端）

```bash
#!/bin/bash
# 启动后端
cd /Users/yeya/FlutterProjects/kode-sdk/Kode-sdk
npm run server &
BACKEND_PID=$!

# 等待后端启动
sleep 3

# 启动前端
cd /Users/yeya/FlutterProjects/kode-sdk/frontend
if [ ! -f .env.local ]; then
  echo "VITE_BACKEND_BASE_URL=localhost:3001" > .env.local
fi
npm run dev &
FRONTEND_PID=$!

echo "✅ 服务已启动"
echo "   后端 PID: $BACKEND_PID"
echo "   前端 PID: $FRONTEND_PID"
echo ""
echo "访问: http://localhost:3020"
echo ""
echo "按 Ctrl+C 停止所有服务"

# 等待中断信号
trap "kill $BACKEND_PID $FRONTEND_PID; exit" INT
wait
```

---

## 附录 B: 测试用例

### B.1 基本对话测试

```typescript
// 测试消息
const testMessages = [
  "你好",
  "请介绍一下你自己",
  "你能做什么",
];

// 预期行为
// 1. 发送消息
// 2. 收到 message_start 事件
// 3. 收到多个 message 事件（流式文本）
// 4. 收到 message_end 事件
// 5. 收到 agent_state_change (finished) 事件
```

### B.2 工具调用测试

```typescript
// 测试消息
const toolTestMessages = [
  "请创建一个待办事项：学习 Kode-SDK",
  "列出所有待办事项",
  "读取当前目录的文件",
];

// 预期行为
// 1. 发送消息
// 2. 收到 tool_call_start 事件
// 3. 收到 tool_call_end 事件（带结果）
// 4. 收到 message 事件（AI 的总结）
// 5. 收到 agent_state_change (finished) 事件
```

---

**文档版本**: v1.0  
**更新时间**: 2025-10-13  
**维护者**: AI Assistant

