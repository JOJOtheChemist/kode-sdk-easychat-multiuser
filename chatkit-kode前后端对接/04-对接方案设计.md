# ChatKit 前端 + Kode-SDK 后端对接方案

## 方案概述

由于 ChatKit 前端使用特定的 ChatKit 协议，而 Kode-SDK 使用自定义事件协议，我们需要开发一个**适配层（Adapter Layer）**来桥接两者。

## 架构设计

```
┌─────────────────────────────────────────────┐
│         React 前端（不修改）                  │
│    使用 @openai/chatkit-react               │
└─────────────────┬───────────────────────────┘
                  │
                  │ ChatKit 协议（SSE）
                  ↓
┌─────────────────────────────────────────────┐
│         FastAPI 适配层                       │
│                                             │
│  ┌─────────────────────────────────────┐  │
│  │  ChatKit Protocol Adapter           │  │
│  │  - POST /chatkit                    │  │
│  │  - 解析 ChatKit 请求                 │  │
│  │  - 转换为 Kode-SDK 调用             │  │
│  │  - 转换事件为 ChatKit SSE           │  │
│  └─────────────────────────────────────┘  │
│                                             │
└─────────────────┬───────────────────────────┘
                  │
                  │ Kode-SDK API
                  ↓
┌─────────────────────────────────────────────┐
│         Kode-SDK Agent 层                    │
│                                             │
│  ┌─────────────────────────────────────┐  │
│  │  Agent 管理                          │  │
│  │  - 创建/恢复 Agent                   │  │
│  │  - 工具注册（save_fact等）          │  │
│  │  - 流式对话处理                      │  │
│  └─────────────────────────────────────┘  │
│                                             │
│  ┌─────────────────────────────────────┐  │
│  │  持久化存储                          │  │
│  │  - JSONStore                         │  │
│  │  - 会话历史                          │  │
│  │  - Facts 存储                        │  │
│  └─────────────────────────────────────┘  │
└─────────────────────────────────────────────┘
```

## 核心组件设计

### 1. FastAPI 适配器（chatkit_adapter.py）

```python
from fastapi import FastAPI, Request
from fastapi.responses import StreamingResponse
import json
from typing import AsyncIterator

app = FastAPI()

@app.post("/chatkit")
async def chatkit_endpoint(request: Request):
    """
    接收 ChatKit 协议请求，转发给 Kode-SDK Agent
    """
    # 1. 解析 ChatKit 请求
    payload = await request.json()
    thread_id = payload.get("thread_id")
    messages = payload.get("messages", [])
    
    # 2. 获取或创建 Kode-SDK Agent
    agent = await get_or_create_agent(thread_id)
    
    # 3. 获取最新用户消息
    user_message = get_latest_user_message(messages)
    
    # 4. 调用 Kode-SDK 流式对话
    event_stream = agent.chatStream(user_message)
    
    # 5. 转换事件流为 ChatKit SSE 格式
    sse_stream = convert_to_chatkit_sse(event_stream, thread_id)
    
    return StreamingResponse(
        sse_stream,
        media_type="text/event-stream"
    )
```

### 2. Agent 管理器（agent_manager.py）

```python
from kode_sdk import Agent, AgentConfig, AgentDependencies
import asyncio
from typing import Dict

class AgentManager:
    """管理多个用户的 Agent 实例"""
    
    def __init__(self, deps: AgentDependencies):
        self.deps = deps
        self.agents: Dict[str, Agent] = {}
        self.locks: Dict[str, asyncio.Lock] = {}
    
    async def get_or_create(self, thread_id: str) -> Agent:
        """获取或创建 Agent"""
        if thread_id not in self.agents:
            if thread_id not in self.locks:
                self.locks[thread_id] = asyncio.Lock()
            
            async with self.locks[thread_id]:
                if thread_id not in self.agents:
                    config = AgentConfig(
                        templateId='chatkit-assistant',
                        sandbox={
                            'kind': 'local',
                            'workDir': f'./workspace/{thread_id}'
                        }
                    )
                    agent = await Agent.create(config, self.deps)
                    self.agents[thread_id] = agent
        
        return self.agents[thread_id]
```

### 3. 事件转换器（event_converter.py）

```python
from typing import AsyncIterator
import json

async def convert_to_chatkit_sse(
    kode_events: AsyncIterator,
    thread_id: str
) -> AsyncIterator[str]:
    """
    将 Kode-SDK 事件流转换为 ChatKit SSE 格式
    """
    async for envelope in kode_events:
        event = envelope.event
        
        # 文本流事件
        if event.type == 'text_chunk':
            yield format_sse_event({
                "type": "text.delta",
                "delta": event.delta,
                "thread_id": thread_id
            })
        
        # 工具调用事件（转换为客户端工具调用）
        elif event.type == 'tool_call':
            if event.tool in ['switch_theme', 'record_fact']:
                yield format_sse_event({
                    "type": "client_tool_call",
                    "name": event.tool,
                    "arguments": event.args,
                    "thread_id": thread_id
                })
        
        # 消息完成事件
        elif event.type == 'message_complete':
            yield format_sse_event({
                "type": "thread_item.done",
                "thread_id": thread_id,
                "item": {
                    "id": generate_id(),
                    "thread_id": thread_id,
                    "type": "assistant_message",
                    "content": event.message
                }
            })

def format_sse_event(data: dict) -> str:
    """格式化为 SSE 事件"""
    return f"event: thread.stream\ndata: {json.dumps(data)}\n\n"
```

### 4. 工具定义（tools.py）

```python
from kode_sdk import defineTool
import uuid
from datetime import datetime

# Fact 存储（可以使用 JSON 文件或数据库）
facts_store = {}

# save_fact 工具
save_fact_tool = defineTool({
    'name': 'save_fact',
    'description': '记录用户分享的事实信息',
    'parameters': {
        'fact': {
            'type': 'string',
            'description': '事实内容'
        }
    },
    'handler': async (params, context) => {
        fact_id = f"fact_{uuid.uuid4().hex[:8]}"
        fact = {
            'id': fact_id,
            'text': params['fact'],
            'status': 'saved',
            'createdAt': datetime.now().isoformat()
        }
        facts_store[fact_id] = fact
        
        # 触发客户端工具调用
        context.emit_client_tool_call('record_fact', {
            'fact_id': fact_id,
            'fact_text': params['fact']
        })
        
        return {'fact_id': fact_id, 'status': 'saved'}
    }
})

# switch_theme 工具
switch_theme_tool = defineTool({
    'name': 'switch_theme',
    'description': '切换界面主题（亮色/暗色）',
    'parameters': {
        'theme': {
            'type': 'string',
            'enum': ['light', 'dark'],
            'description': '主题类型'
        }
    },
    'handler': async (params, context) => {
        # 触发客户端工具调用
        context.emit_client_tool_call('switch_theme', {
            'theme': params['theme']
        })
        
        return {'theme': params['theme']}
    }
})
```

### 5. 初始化和配置（main.py）

```python
from fastapi import FastAPI
from kode_sdk import (
    JSONStore,
    AgentTemplateRegistry,
    ToolRegistry,
    SandboxFactory,
    GLMProvider,
    AgentDependencies
)
from .agent_manager import AgentManager
from .tools import save_fact_tool, switch_theme_tool
from .chatkit_adapter import chatkit_endpoint
import os

app = FastAPI()

# 初始化 Kode-SDK 依赖
def init_kode_sdk() -> AgentDependencies:
    store = JSONStore('./.kode')
    templates = AgentTemplateRegistry()
    tools = ToolRegistry()
    sandbox_factory = SandboxFactory()
    
    # 注册工具
    tools.register('save_fact', () => save_fact_tool)
    tools.register('switch_theme', () => switch_theme_tool)
    
    # 注册模板
    templates.register({
        'id': 'chatkit-assistant',
        'systemPrompt': """
你是 ChatKit Guide，一个帮助用户的助手。
主要功能：
1. 记录用户分享的事实信息（使用 save_fact 工具）
2. 切换界面主题（使用 switch_theme 工具）
3. 回答用户问题

每当用户分享一个具体的事实时，立即调用 save_fact 工具保存。
当用户要求切换主题时，调用 switch_theme 工具。
        """,
        'tools': ['save_fact', 'switch_theme'],
        'model': 'glm-4.5-air'
    })
    
    # 模型工厂
    def model_factory(config):
        return GLMProvider(
            os.getenv('GLM_API_KEY'),
            config.model,
            os.getenv('GLM_BASE_URL', 'https://open.bigmodel.cn/api/paas/v4')
        )
    
    return AgentDependencies(
        store=store,
        templateRegistry=templates,
        toolRegistry=tools,
        sandboxFactory=sandbox_factory,
        modelFactory=model_factory
    )

# 全局 Agent 管理器
deps = init_kode_sdk()
agent_manager = AgentManager(deps)

# 注册 ChatKit 端点
@app.post("/chatkit")
async def chatkit_route(request: Request):
    return await chatkit_endpoint(request, agent_manager)

@app.get("/health")
async def health():
    return {"status": "ok"}
```

## 关键技术点

### 1. 客户端工具调用的实现

由于 Kode-SDK 不原生支持客户端工具，需要在适配层实现：

```typescript
// 扩展 Kode-SDK 工具上下文
interface ExtendedToolContext {
  // 原有上下文
  ...
  
  // 新增：客户端工具调用队列
  clientToolCalls: Array<{
    name: string;
    arguments: any;
  }>;
  
  // 新增：触发客户端工具调用
  emitClientToolCall(name: string, args: any): void;
}

// 在工具处理器中使用
handler: async (params, context: ExtendedToolContext) => {
  context.emitClientToolCall('record_fact', {
    fact_id: factId,
    fact_text: params.fact
  });
  return result;
}

// 在事件转换时检查并发送
async function* convertEvents(kodeEvents, context) {
  for await (const event of kodeEvents) {
    yield* handleEvent(event);
    
    // 检查是否有客户端工具调用
    for (const call of context.clientToolCalls) {
      yield formatSSE({
        type: 'client_tool_call',
        name: call.name,
        arguments: call.arguments
      });
    }
    context.clientToolCalls = [];
  }
}
```

### 2. 线程 ID 映射

ChatKit 使用 `thread_id` 管理会话，需要映射到 Kode-SDK 的 Agent 实例：

```
thread_id (ChatKit) → Agent ID (Kode-SDK)
- 一对一映射
- 使用 thread_id 作为 Agent 的标识
- Agent Manager 负责维护映射关系
```

### 3. 消息历史管理

Kode-SDK 自动管理消息历史（通过 Store），无需额外处理。每次调用 `agent.chatStream()` 会自动包含历史上下文。

### 4. Facts 存储

有两种方案：

**方案 A：使用 Kode-SDK 内置存储**
```python
# 将 facts 保存到 Agent 的 metadata 中
agent.metadata['facts'] = facts_store
```

**方案 B：独立存储（推荐）**
```python
# 使用单独的 JSON 文件或数据库
class FactsStore:
    def save(self, thread_id, fact):
        # 保存到文件或数据库
        pass
```

## 实现步骤

### Phase 1: 基础适配层（1-2天）

1. ✅ 搭建 FastAPI 项目结构
2. ✅ 实现 `/chatkit` 端点
3. ✅ 实现基础事件转换（text_chunk）
4. ✅ 测试简单对话流

### Phase 2: 工具系统（2-3天）

1. ✅ 实现 `save_fact` 工具
2. ✅ 实现 `switch_theme` 工具
3. ✅ 实现客户端工具调用机制
4. ✅ 测试工具调用流程

### Phase 3: 完善功能（2-3天）

1. ✅ 实现 Agent 管理器
2. ✅ 实现 Facts 存储和 API
3. ✅ 错误处理和日志
4. ✅ 性能优化

### Phase 4: 测试和优化（1-2天）

1. ✅ 端到端测试
2. ✅ 压力测试
3. ✅ 前端集成测试
4. ✅ 文档完善

## 技术栈选择

### 后端框架
- **FastAPI**: 高性能、异步支持、自动文档
- **Python 3.11+**: 更好的异步性能

### Kode-SDK 集成
- **TypeScript**: Kode-SDK 是 TypeScript 库
- **需要 Node.js 环境**: 运行 Kode-SDK

### 桥接方案
有两种方案连接 Python 和 TypeScript：

**方案 A：Python 调用 Node.js 子进程**
```python
import subprocess
import json

def call_kode_agent(message):
    result = subprocess.run(
        ['node', 'kode_wrapper.js', message],
        capture_output=True
    )
    return json.loads(result.stdout)
```

**方案 B：使用 HTTP/gRPC 桥接**
```
Python FastAPI ←HTTP→ Node.js Kode-SDK 服务
```

**方案 C：全 Node.js 实现（推荐）**
```
使用 Node.js + Express/Fastify 实现整个后端
直接使用 Kode-SDK，无需桥接
```

## 推荐方案：全 TypeScript 实现

考虑到复杂度和性能，推荐使用 **Node.js + TypeScript** 全栈实现：

```
Node.js + Fastify/Express
  ↓
ChatKit 适配层（TypeScript）
  ↓
Kode-SDK（TypeScript）
```

优点：
- ✅ 无需跨语言调用
- ✅ 性能更好
- ✅ 类型安全
- ✅ 开发效率高

缺点：
- ⚠️ 需要熟悉 TypeScript
- ⚠️ 无法复用 Python ChatKit 后端代码

## 下一步

选择实现方案后，我将提供详细的代码实现。推荐使用 **全 TypeScript 方案**。

你希望使用哪种方案？
1. 全 TypeScript 实现（推荐）
2. Python + Node.js 桥接
3. 其他方案

