## 会话页面入口

- `routes/conversation.tsx` 在加载时通过 `useConversationId` 读取 URL 参数，配合 `useActiveConversation` 拉取会话详情。
- 进入页面会重置终端/Jupyter/会话状态，并将 `AgentState` 设置为 `LOADING`，确保 UI 回到初始态。
- 如果后端返回的会话状态为 `STOPPED`，会尝试调用 `useStartConversation` 重新启动。

## WebSocket 建立与事件分发

1. `WebSocketProviderWrapper`（version=0）包裹整个页面。
2. `context/ws-client-provider.tsx` 负责创建 Socket.IO 连接，自动携带 `conversation_id` 与 `session_api_key`。
3. 收到的消息会经过 `handleAssistantMessage` 做基础处理，再根据类型推送到：
   - `useEventStore`：缓存所有事件，并转换为 UI 所需格式。
   - `useErrorMessageStore` / `trackError`：统一 toast 和错误上报。
   - React Query：当文件写入/编辑、命令执行时，主动 `invalidateQueries` 刷新相关数据。
4. WebSocket 断连时会记录 `latest_event_id`，方便重连后补偿。

## React Query 与数据同步

- `query-client-config.ts` 设置了全局 Query/Mutation 错误处理，401 会自动刷新认证状态，其余错误展示 toast。
- `hooks/query/use-active-conversation.ts` 按会话状态动态拉取最新数据，并将当前会话写入 `ConversationService`，供其他 API 复用。
- `services/conversation-service.api.ts` 根据当前会话自动拼接 URL、请求头，实现 REST 与 WebSocket 状态的一致。

## 聊天 UI 渲染

- `components/features/conversation/conversation-main/*`：按窗口宽度切换移动端与桌面布局。
- `ChatInterfaceWrapper`（内部组合多个 Chat 组件）从 `useEventStore` 获取事件序列，拆分成消息、动作、观察等类型，渲染聊天时间轴。
- `hooks/chat` 系列处理输入框逻辑、上传文件/图片、发送消息等交互。

## 新版对话界面预览（静态演示）

- 路由 `conversation-preview`（`routes/conversation-preview.tsx`）提供一个与正式会话隔离的 UI 入口，用于独立演示和验收界面。
- 主组件 `components/features/conversation-preview/conversation-preview.tsx` 仅依赖本地 `useState`，初始输入框填入 `'你好'`，并模拟用户与助手的单轮回复。
- 预览子组件拆分为 `preview-header` / `preview-chat-messages` / `preview-composer`，便于后续接入真实数据流时按块替换。
- 该页面不会触发真实的 REST 或 WebSocket 请求，可在不启动后端的情况下快速查看样式与交互反馈。

## 常见调试切入点

1. 先看 `useEventStore` 中事件是如何入栈的，再查对应的 UI 渲染组件。
2. 遇到数据不同步时，检查 React Query 的 `invalidateQueries` 是否被触发。
3. 如果 WebSocket 无法连接，重点排查 `conversation.status` 是否为 `RUNNING` 以及 `session_api_key` 是否正确透传。
