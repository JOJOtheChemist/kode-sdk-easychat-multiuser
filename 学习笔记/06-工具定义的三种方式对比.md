# 工具定义的三种方式对比

## 概述

KODE SDK 提供了三种工具定义方式，从简单到复杂依次为：`defineTool`（简化函数）、`tool`（Zod Schema）、直接构造 `ToolInstance`（底层方式）。本文档详细对比这三种方式的原理、使用场景和转换流程。

---

## 一、三种定义方式概览

### 1.1 快速对比表

| 方式 | 函数/API | Schema 类型 | 特点 | 适用场景 |
|-----|---------|------------|------|---------|
| **简化定义** | `defineTool` | 简化参数 → JSON Schema | ✅ 最简单<br>✅ 自动生成 Schema<br>❌ 功能有限 | 快速开发、简单工具 |
| **Zod Schema** | `tool` | Zod → JSON Schema | ✅ 类型安全<br>✅ 强大验证<br>✅ 自动推断 | 复杂工具、类型严格 |
| **底层方式** | 直接构造 | 手写 JSON Schema | ✅ 完全控制<br>❌ 最繁琐 | 特殊需求、底层开发 |

---

## 二、方式一：`defineTool` 简化定义（推荐入门）

### 2.1 核心原理

**这不是模板，而是一个封装函数！**

`defineTool` 是定义在 `src/tools/define.ts` 的辅助函数，它接收简化的参数定义，然后：
1. 自动转换为标准 JSON Schema
2. 使用 AJV 进行参数校验
3. 返回标准的 `ToolInstance` 对象

**位置：** `src/tools/define.ts` 第 144-217 行

### 2.2 使用示例（来自 demo-server.ts）

```typescript
const calculatorTool = defineTool({
  name: 'calculator',
  description: '执行数学计算，支持加减乘除',
  
  // 🔑 简化的参数定义
  params: {
    operation: {
      type: 'string',
      enum: ['add', 'subtract', 'multiply', 'divide'],
      description: '运算类型',
    },
    a: { type: 'number', description: '第一个数字' },
    b: { type: 'number', description: '第二个数字' },
  },
  
  attributes: { readonly: true, noEffect: true },
  
  async exec(args: { operation: string; a: number; b: number }) {
    // 工具执行逻辑
    switch (args.operation) {
      case 'add': return { ok: true, result: args.a + args.b };
      // ...
    }
  }
});
```

### 2.3 内部转换流程

#### 步骤 1：定义简化的 params

```typescript
// 你写的简化定义
params: {
  operation: {
    type: 'string',
    enum: ['add', 'subtract', 'multiply', 'divide'],
    description: '运算类型',
  },
  a: { type: 'number', description: '第一个数字' },
  b: { type: 'number', description: '第二个数字' },
}
```

#### 步骤 2：自动生成 JSON Schema

**位置：** `src/tools/define.ts` 第 59-98 行

```typescript
function generateSchema(params?: Record<string, ParamDef>): any {
  if (!params) {
    return { type: 'object', properties: {} };
  }

  const properties: Record<string, any> = {};
  const required: string[] = [];

  for (const [key, def] of Object.entries(params)) {
    const prop: any = { type: def.type };

    if (def.description) prop.description = def.description;
    if (def.enum) prop.enum = def.enum;
    if (def.default !== undefined) prop.default = def.default;

    // 处理嵌套类型（array、object）
    if (def.type === 'array' && def.items) {
      prop.items = generateSchemaProp(def.items);
    }
    if (def.type === 'object' && def.properties) {
      const nested = generateSchema(def.properties);
      prop.properties = nested.properties;
      if (nested.required?.length > 0) {
        prop.required = nested.required;
      }
    }

    properties[key] = prop;

    // 🔑 默认所有字段都是 required（除非明确设置 required: false）
    if (def.required !== false) {
      required.push(key);
    }
  }

  return {
    type: 'object',
    properties,
    ...(required.length > 0 ? { required } : {}),
  };
}
```

#### 步骤 3：生成的 JSON Schema

```json
{
  "type": "object",
  "properties": {
    "operation": {
      "type": "string",
      "enum": ["add", "subtract", "multiply", "divide"],
      "description": "运算类型"
    },
    "a": {
      "type": "number",
      "description": "第一个数字"
    },
    "b": {
      "type": "number",
      "description": "第二个数字"
    }
  },
  "required": ["operation", "a", "b"]
}
```

#### 步骤 4：创建 ToolInstance

**位置：** `src/tools/define.ts` 第 149-205 行

```typescript
export function defineTool<TArgs = any, TResult = any>(
  def: SimpleToolDef<TArgs, TResult>,
  options?: { autoRegister?: boolean }
): ToolInstance {
  // 🔑 关键：自动生成 schema 或使用提供的
  const input_schema = def.input_schema || generateSchema(def.params);

  const toolInstance: ToolInstance = {
    name: def.name,
    description: def.description,
    input_schema,  // 生成的 JSON Schema
    prompt: def.prompt,

    async exec(args: any, ctx: ToolContext): Promise<any> {
      // 增强上下文，添加 emit 方法
      const enhancedCtx: EnhancedToolContext = {
        ...ctx,
        emit(eventType: string, data?: any) {
          ctx.agent?.events?.emitMonitor({
            type: 'tool_custom_event' as any,
            toolName: def.name,
            eventType,
            data,
            timestamp: Date.now(),
          } as any);
        },
      };

      return await def.exec(args, enhancedCtx);
    },

    toDescriptor(): ToolDescriptor {
      // 转换 attributes 为内部 metadata
      const metadata: Record<string, any> = { tuned: false };
      
      if (def.attributes?.readonly) {
        metadata.access = 'read';
        metadata.mutates = false;
      } else {
        metadata.access = 'write';
        metadata.mutates = true;
      }
      
      if (def.attributes?.noEffect !== undefined) {
        metadata.safe = def.attributes.noEffect;
      }

      return {
        source: 'registered',
        name: def.name,
        registryId: def.name,
        metadata,
      };
    },
  };

  // 🔑 自动注册到全局 registry（支持 Resume）
  if (options?.autoRegister !== false) {
    globalToolRegistry.register(def.name, (_config) => {
      return defineTool(def, { autoRegister: false });
    });
  }

  return toolInstance;
}
```

### 2.4 简化参数定义接口

**位置：** `src/tools/define.ts` 第 22-30 行

```typescript
export interface ParamDef {
  type: 'string' | 'number' | 'boolean' | 'object' | 'array';
  description?: string;
  required?: boolean;      // 默认 true
  default?: any;
  enum?: any[];            // 枚举值
  items?: ParamDef;        // 数组元素类型（type 为 array 时）
  properties?: Record<string, ParamDef>;  // 对象属性（type 为 object 时）
}
```

### 2.5 支持的功能特性

#### ✅ 基本类型
```typescript
params: {
  name: { type: 'string', description: '名称' },
  age: { type: 'number', description: '年龄' },
  active: { type: 'boolean', description: '是否激活' },
}
```

#### ✅ 枚举值
```typescript
params: {
  status: { 
    type: 'string', 
    enum: ['pending', 'active', 'completed'],
    description: '状态'
  },
}
```

#### ✅ 可选参数
```typescript
params: {
  required_field: { type: 'string' },  // 默认 required
  optional_field: { type: 'string', required: false },
}
```

#### ✅ 默认值
```typescript
params: {
  timeout: { 
    type: 'number', 
    default: 3000,
    description: '超时时间（毫秒）'
  },
}
```

#### ✅ 数组类型
```typescript
params: {
  tags: {
    type: 'array',
    items: { type: 'string' },
    description: '标签列表',
  },
}
```

#### ✅ 嵌套对象
```typescript
params: {
  user: {
    type: 'object',
    properties: {
      name: { type: 'string' },
      email: { type: 'string' },
      age: { type: 'number', required: false },
    },
    description: '用户信息',
  },
}
```

---

## 三、方式二：`tool` 函数（Zod Schema）

### 3.1 核心原理

**也是一个函数，但使用 Zod 进行类型安全的参数定义！**

`tool` 函数定义在 `src/tools/tool.ts`，它：
1. 接收 Zod Schema 作为参数定义
2. 自动转换 Zod → JSON Schema（使用 `zod-to-json-schema`）
3. 在执行前使用 Zod 校验参数
4. 提供完整的 TypeScript 类型推断

**位置：** `src/tools/tool.ts` 第 54-153 行

### 3.2 使用示例

```typescript
import { z } from 'zod';
import { tool } from '../src/tools/tool';

const calculatorTool = tool({
  name: 'calculator',
  description: '执行数学计算',
  
  // 🔑 使用 Zod Schema
  parameters: z.object({
    operation: z.enum(['add', 'subtract', 'multiply', 'divide'])
      .describe('运算类型'),
    a: z.number().describe('第一个数字'),
    b: z.number().describe('第二个数字'),
  }),
  
  async execute(args, ctx) {
    // args 已经过 Zod 校验，类型安全！
    // TypeScript 能自动推断 args 的类型
    const { operation, a, b } = args;
    
    switch (operation) {
      case 'add': return a + b;
      case 'subtract': return a - b;
      case 'multiply': return a * b;
      case 'divide':
        if (b === 0) throw new Error('除数不能为0');
        return a / b;
    }
  }
});
```

### 3.3 Zod → JSON Schema 转换

**位置：** `src/tools/tool.ts` 第 69-72 行

```typescript
// 生成 JSON Schema
const input_schema = def.parameters
  ? zodToJsonSchema(def.parameters, { 
      target: 'openApi3',      // 目标格式：OpenAPI 3.0
      $refStrategy: 'none'     // 不使用 $ref 引用
    })
  : { type: 'object', properties: {} };
```

### 3.4 Zod 校验流程

**位置：** `src/tools/tool.ts` 第 81-94 行

```typescript
async exec(args: any, ctx: ToolContext): Promise<any> {
  try {
    // 参数验证
    if (def.parameters) {
      const parseResult = def.parameters.safeParse(args);
      if (!parseResult.success) {
        return {
          ok: false,
          error: `Invalid parameters: ${parseResult.error.message}`,
          _validationError: true,  // 标记为校验错误
        };
      }
      args = parseResult.data;  // 使用校验后的数据（可能包含转换）
    }

    // 执行工具
    const result = await def.execute(args, enhancedCtx);
    
    // 处理返回值...
  } catch (error: any) {
    return {
      ok: false,
      error: error?.message || String(error),
      _thrownError: true,
    };
  }
}
```

### 3.5 Zod 的高级功能

#### ✅ 类型转换
```typescript
parameters: z.object({
  port: z.string().transform(val => parseInt(val, 10)),  // 字符串 → 数字
  enabled: z.union([z.boolean(), z.string()]).transform(val => {
    if (typeof val === 'string') return val === 'true';
    return val;
  }),
}),
```

#### ✅ 自定义验证
```typescript
parameters: z.object({
  email: z.string().email('无效的邮箱地址'),
  age: z.number().min(0).max(150, '年龄必须在 0-150 之间'),
  url: z.string().url('无效的 URL'),
}),
```

#### ✅ 条件验证
```typescript
parameters: z.object({
  type: z.enum(['local', 'remote']),
  path: z.string().optional(),
  url: z.string().optional(),
}).refine(data => {
  // 如果是 remote 类型，必须提供 url
  if (data.type === 'remote' && !data.url) {
    return false;
  }
  // 如果是 local 类型，必须提供 path
  if (data.type === 'local' && !data.path) {
    return false;
  }
  return true;
}, {
  message: 'local 需要 path, remote 需要 url',
}),
```

#### ✅ 复杂嵌套结构
```typescript
parameters: z.object({
  users: z.array(z.object({
    name: z.string().min(1),
    email: z.string().email(),
    roles: z.array(z.enum(['admin', 'user', 'guest'])),
    metadata: z.record(z.string(), z.any()).optional(),
  })),
}),
```

---

## 四、方式三：直接构造 ToolInstance（底层方式）

### 4.1 核心原理

直接创建符合 `ToolInstance` 接口的对象，完全手动控制。

**位置：** `src/tools/registry.ts`

### 4.2 使用示例

```typescript
import { ToolInstance } from '../src/tools/registry';

const calculatorTool: ToolInstance = {
  name: 'calculator',
  description: '执行数学计算',
  
  // 🔑 手写 JSON Schema
  input_schema: {
    type: 'object',
    properties: {
      operation: {
        type: 'string',
        enum: ['add', 'subtract', 'multiply', 'divide'],
        description: '运算类型',
      },
      a: {
        type: 'number',
        description: '第一个数字',
      },
      b: {
        type: 'number',
        description: '第二个数字',
      },
    },
    required: ['operation', 'a', 'b'],
  },
  
  async exec(args: any, ctx: ToolContext): Promise<any> {
    // 需要手动处理所有逻辑
    const { operation, a, b } = args;
    
    // 手动校验（如果需要）
    if (typeof a !== 'number' || typeof b !== 'number') {
      return { ok: false, error: '参数类型错误' };
    }
    
    // 执行逻辑
    switch (operation) {
      case 'add': return { ok: true, result: a + b };
      case 'subtract': return { ok: true, result: a - b };
      case 'multiply': return { ok: true, result: a * b };
      case 'divide':
        if (b === 0) return { ok: false, error: '除数不能为0' };
        return { ok: true, result: a / b };
      default:
        return { ok: false, error: '不支持的运算' };
    }
  },
  
  toDescriptor() {
    return {
      source: 'registered' as const,
      name: 'calculator',
      registryId: 'calculator',
      metadata: {
        access: 'read',
        mutates: false,
        safe: true,
      },
    };
  },
};
```

---

## 五、三种方式的详细对比

### 5.1 Schema 定义对比

#### defineTool（简化）
```typescript
params: {
  name: { type: 'string', description: '名称' },
  age: { type: 'number', required: false },
}
```

#### tool（Zod）
```typescript
parameters: z.object({
  name: z.string().describe('名称'),
  age: z.number().optional(),
}),
```

#### 直接构造（JSON Schema）
```typescript
input_schema: {
  type: 'object',
  properties: {
    name: { type: 'string', description: '名称' },
    age: { type: 'number' },
  },
  required: ['name'],
}
```

### 5.2 校验方式对比

| 方式 | 校验器 | 校验时机 | 错误信息 |
|-----|-------|---------|---------|
| `defineTool` | AJV（自动生成的 Schema） | Agent 执行时 | JSON Schema 错误 |
| `tool` | Zod（`.safeParse()`） | 工具执行前 | Zod 错误（更友好） |
| 直接构造 | AJV（手写的 Schema） | Agent 执行时 | JSON Schema 错误 |

### 5.3 类型安全对比

```typescript
// defineTool：需要手动指定类型
async exec(args: { name: string; age: number }) {
  args.name  // string（手动指定）
}

// tool：自动推断类型
parameters: z.object({
  name: z.string(),
  age: z.number(),
}),
async execute(args, ctx) {
  args.name  // string（自动推断！）
  args.age   // number（自动推断！）
}

// 直接构造：无类型安全
async exec(args: any, ctx: ToolContext) {
  args.name  // any（需要手动断言）
}
```

### 5.4 功能完整性对比

| 功能 | defineTool | tool (Zod) | 直接构造 |
|-----|-----------|-----------|---------|
| 基本类型 | ✅ | ✅ | ✅ |
| 枚举 | ✅ | ✅ | ✅ |
| 可选参数 | ✅ | ✅ | ✅ |
| 默认值 | ✅ | ✅ | ✅ |
| 嵌套对象 | ✅ | ✅ | ✅ |
| 数组 | ✅ | ✅ | ✅ |
| 类型转换 | ❌ | ✅ | ❌ |
| 自定义验证 | ❌ | ✅ | 需手动实现 |
| 条件验证 | ❌ | ✅ | 需手动实现 |
| 类型推断 | ❌ | ✅ | ❌ |
| 自动注册 | ✅ | ✅ | 需手动注册 |

---

## 六、选择指南

### 6.1 推荐使用场景

#### 使用 `defineTool` 如果：
- ✅ 快速开发原型
- ✅ 工具参数简单
- ✅ 不需要复杂的类型转换
- ✅ 想要最少的样板代码

**示例场景：** 简单的计算器、天气查询、时间工具

#### 使用 `tool` (Zod) 如果：
- ✅ 需要类型安全
- ✅ 参数需要复杂验证
- ✅ 需要类型转换
- ✅ 大型项目或团队协作

**示例场景：** 文件操作、API 调用、数据库操作、复杂业务逻辑

#### 使用直接构造如果：
- ✅ 需要完全控制
- ✅ 特殊的工具实现需求
- ✅ 底层框架开发

**示例场景：** SDK 内部工具、特殊协议支持、性能优化

### 6.2 迁移路径

```
开始开发（快速原型）
    ↓
使用 defineTool
    ↓
需要更强类型安全 / 复杂验证
    ↓
迁移到 tool (Zod)
    ↓
需要特殊控制
    ↓
使用直接构造
```

---

## 七、实战示例对比

### 7.1 同一个工具的三种实现

#### 场景：文件读取工具

**方式 1：defineTool**
```typescript
const readFileTool = defineTool({
  name: 'read_file',
  description: '读取文件内容',
  params: {
    path: { type: 'string', description: '文件路径' },
    encoding: { 
      type: 'string', 
      enum: ['utf8', 'ascii', 'base64'],
      default: 'utf8',
      required: false,
    },
  },
  async exec(args, ctx) {
    const content = await ctx.sandbox.fs.read(args.path, args.encoding);
    return { ok: true, content };
  },
});
```

**方式 2：tool (Zod)**
```typescript
const readFileTool = tool({
  name: 'read_file',
  description: '读取文件内容',
  parameters: z.object({
    path: z.string()
      .min(1, '路径不能为空')
      .refine(p => !p.includes('..'), '路径不能包含 ..')
      .describe('文件路径'),
    encoding: z.enum(['utf8', 'ascii', 'base64'])
      .default('utf8')
      .describe('编码格式'),
  }),
  async execute(args, ctx) {
    // args 类型自动推断！
    const content = await ctx.sandbox.fs.read(args.path, args.encoding);
    return { content };
  },
});
```

**方式 3：直接构造**
```typescript
const readFileTool: ToolInstance = {
  name: 'read_file',
  description: '读取文件内容',
  input_schema: {
    type: 'object',
    properties: {
      path: {
        type: 'string',
        description: '文件路径',
      },
      encoding: {
        type: 'string',
        enum: ['utf8', 'ascii', 'base64'],
        default: 'utf8',
        description: '编码格式',
      },
    },
    required: ['path'],
  },
  async exec(args: any, ctx: ToolContext) {
    // 手动验证
    if (typeof args.path !== 'string' || args.path.length === 0) {
      return { ok: false, error: '路径不能为空' };
    }
    if (args.path.includes('..')) {
      return { ok: false, error: '路径不能包含 ..' };
    }
    
    const encoding = args.encoding || 'utf8';
    const content = await ctx.sandbox.fs.read(args.path, encoding);
    return { ok: true, content };
  },
  toDescriptor() {
    return {
      source: 'registered',
      name: 'read_file',
      registryId: 'read_file',
      metadata: { access: 'read', mutates: false },
    };
  },
};
```

---

## 八、总结

### 8.1 核心要点

1. **`defineTool` 是封装函数，不是模板**
   - 提供简化的参数定义接口
   - 自动转换为 JSON Schema
   - 使用 AJV 进行校验

2. **`tool` 使用 Zod 提供类型安全**
   - 强大的验证功能
   - 自动类型推断
   - 更友好的错误信息

3. **所有方式最终都生成 ToolInstance**
   - 包含 `input_schema`（JSON Schema）
   - 包含 `exec` 执行函数
   - 包含 `toDescriptor` 描述函数

### 8.2 选择建议

```
简单工具 → defineTool
   ↓
复杂工具 → tool (Zod)
   ↓
特殊需求 → 直接构造
```

### 8.3 最佳实践

- ✅ 新手入门使用 `defineTool`
- ✅ 生产环境推荐 `tool` (Zod)
- ✅ 始终提供清晰的 description
- ✅ 为枚举值添加注释
- ✅ 合理设置 required 和 default
- ✅ 使用 TypeScript 类型注解提高代码质量

### 8.4 代码位置速查

| 功能 | 文件 | 行号 | 说明 |
|-----|------|------|------|
| defineTool 函数 | `src/tools/define.ts` | 144-217 | 简化定义入口 |
| generateSchema | `src/tools/define.ts` | 59-98 | JSON Schema 生成 |
| ParamDef 接口 | `src/tools/define.ts` | 22-30 | 参数定义接口 |
| tool 函数 | `src/tools/tool.ts` | 54-153 | Zod Schema 方式 |
| Zod 校验 | `src/tools/tool.ts` | 84-94 | 参数校验逻辑 |
| Zod → JSON Schema | `src/tools/tool.ts` | 69-72 | Schema 转换 |
| ToolInstance 接口 | `src/tools/registry.ts` | - | 工具实例接口 |

---

## 九、调试技巧

### 9.1 查看生成的 Schema

```typescript
// 查看 defineTool 生成的 Schema
const tool = defineTool({ /* ... */ });
console.log('Schema:', JSON.stringify(tool.input_schema, null, 2));

// 查看 tool (Zod) 生成的 Schema
const zodTool = tool({ /* ... */ });
console.log('Schema:', JSON.stringify(zodTool.input_schema, null, 2));
```

### 9.2 测试参数校验

```typescript
// 手动测试校验
const testArgs = { operation: 'add', a: 1, b: 2 };
const result = await calculatorTool.exec(testArgs, ctx);
console.log('Result:', result);
```

### 9.3 对比三种方式的输出

```typescript
// 创建相同功能的三个工具
const tool1 = defineTool({ /* ... */ });
const tool2 = tool({ /* ... */ });
const tool3 = /* 直接构造 */;

// 对比它们的 Schema
console.log('defineTool Schema:', tool1.input_schema);
console.log('tool (Zod) Schema:', tool2.input_schema);
console.log('Direct Schema:', tool3.input_schema);
```

这样你就完全理解了工具定义的本质：**它们都是函数/构造方式，不是模板，最终都生成标准的 ToolInstance 对象**！

