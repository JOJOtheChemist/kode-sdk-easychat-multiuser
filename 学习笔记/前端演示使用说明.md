# 多步工具调用 Web 演示

## 🎯 功能

实时验证 Kode-SDK 的多步工具调用机制，直观展示：
- ✅ 用户输入
- ✅ LLM 回复（流式显示）
- ✅ 工具调用过程
- ✅ 每个工具的输入/输出
- ✅ 执行时间统计

## 🚀 快速启动

### 方式一：使用启动脚本（推荐）

```bash
cd /Users/yeya/FlutterProjects/kode-sdk/kode-sdk
./start-demo.sh
```

### 方式二：手动启动

```bash
cd /Users/yeya/FlutterProjects/kode-sdk/kode-sdk

# 设置环境变量
export ANTHROPIC_API_KEY="ef22d69d218e4cad8ae3c15bcc77d30d.eULl6aqOo8YEDKzG"
export ANTHROPIC_BASE_URL="https://api.z.ai/api/anthropic"
export ANTHROPIC_MODEL_ID="glm-4.5-air"
export PORT=3000

# 启动服务器
npx ts-node demo-server.ts
```

## 📱 访问界面

启动成功后，打开浏览器访问：

```
http://localhost:3000
```

## 🧪 测试示例

### 示例 1：简单两步

输入：
```
计算 15 + 8，然后乘以 2
```

预期流程：
1. LLM 理解任务
2. 调用 `calculator(add, 15, 8)` → 返回 23
3. 结果传递给 LLM
4. 调用 `calculator(multiply, 23, 2)` → 返回 46
5. LLM 生成最终答案

### 示例 2：三步计算

输入：
```
先算 30 * 4，再减去 50，最后除以 2
```

预期流程：
1. `calculator(multiply, 30, 4)` → 120
2. `calculator(subtract, 120, 50)` → 70
3. `calculator(divide, 70, 2)` → 35

### 示例 3：复杂表达式

输入：
```
计算 100 除以 5，然后加上 20，最后乘以 3
```

预期流程：
1. `calculator(divide, 100, 5)` → 20
2. `calculator(add, 20, 20)` → 40
3. `calculator(multiply, 40, 3)` → 120

## 🎨 界面说明

### 左侧：LLM 回复
- 实时显示 LLM 的文本输出
- 流式显示，逐字呈现

### 右侧：工具调用
- 显示每个工具调用的详细信息
- 包括：
  - 工具名称
  - 输入参数
  - 输出结果
  - 执行时间

### 底部：状态栏
- 连接状态（绿点表示活跃）
- 工具调用次数
- 当前模型

## 📊 观察重点

### 验证目标

通过界面可以清晰看到：

1. **工具调用顺序** - 按照逻辑依次调用
2. **结果传递** - 每个工具的结果都被下一个工具使用
3. **LLM 决策** - LLM 基于前一个结果决定下一步
4. **完整链条** - 从开始到结束的完整流程

### 关键现象

✅ **成功的标志**：
- 多个工具被依次调用
- 后面工具的输入包含前面工具的输出
- LLM 的最终答案整合了所有结果

❌ **失败的标志**：
- 只调用了一个工具就结束
- 工具调用顺序错误
- 最终答案不完整

## 🔧 技术实现

### 后端（demo-server.ts）

```typescript
// SSE 流式响应
app.post('/api/chat', async (req, res) => {
  // 设置 SSE 响应头
  res.setHeader('Content-Type', 'text/event-stream');
  
  // 监听 Agent 事件
  agent.on('tool_executed', (event) => {
    // 发送工具执行结果
    sendEvent('tool', { ...event });
  });
  
  // 订阅 progress 流
  for await (const event of agent.subscribe(['progress'])) {
    // 流式发送文本和工具事件
  }
});
```

### 前端（index.html）

```javascript
// EventSource 接收 SSE
const response = await fetch('/api/chat', {
  method: 'POST',
  body: JSON.stringify({ message })
});

const reader = response.body.getReader();
// 实时处理流式数据
while (true) {
  const { done, value } = await reader.read();
  if (done) break;
  
  // 解析 SSE 事件
  handleEvent(eventType, data);
}
```

## 🐛 故障排查

### 问题 1: 服务器启动失败

**检查**：
```bash
# 查看端口占用
lsof -i :3000

# 查看错误日志
tail -f nohup.out
```

**解决**：
```bash
# 使用其他端口
PORT=3001 ./start-demo.sh
```

### 问题 2: API Key 无效

**检查**：
```bash
curl http://localhost:3000/api/health
```

**解决**：
```bash
# 重新设置环境变量
export ANTHROPIC_API_KEY="your-valid-key"
```

### 问题 3: 工具调用失败

**检查**：查看浏览器控制台和服务器日志

**解决**：
- 检查网络连接
- 验证 API Key
- 查看具体错误信息

## 📁 文件结构

```
kode-sdk/
├── demo-server.ts          # 后端服务器
├── public/
│   └── index.html          # 前端界面
├── start-demo.sh           # 启动脚本
└── examples/
    └── shared/
        └── runtime.ts      # 运行时配置
```

## 🎓 学习要点

### 核心机制验证

通过这个演示可以直观理解：

1. **工具结果传递**
   - 每个工具执行完成后
   - 结果以 `user` 角色追加到 `messages`
   - 下一轮 `runStep()` 将完整 messages 发送给 LLM

2. **自动循环**
   - `ensureProcessing()` 触发下一轮
   - 无需手动控制
   - 自动持续直到完成

3. **流式响应**
   - 文本逐字显示
   - 工具调用实时更新
   - 用户体验流畅

### 与文档对照

```typescript
// agent.ts:950-962
const outcomes = await this.executeTools(toolBlocks);
if (outcomes.length > 0) {
  // 1. 结果追加到消息历史
  this.messages.push({ role: 'user', content: outcomes });
  
  // 2. 触发下一轮处理
  this.ensureProcessing();
  return;
}
```

在界面上可以看到这个过程的实时发生！

## 💡 扩展建议

### 添加更多工具

```typescript
// 在 demo-server.ts 中添加
const timeTool = defineTool({
  name: 'get_time',
  description: '获取当前时间',
  // ...
});
```

### 自定义界面

修改 `public/index.html`：
- 调整颜色主题
- 添加动画效果
- 增加统计图表

### 持久化对话

```typescript
// 保存对话历史
const history = await agent.getMessages();
localStorage.setItem('chat-history', JSON.stringify(history));
```

## 🔗 相关文档

- [成功验证-多轮工具调用.md](./成功验证-多轮工具调用.md) - 验证总结
- [01工具执行与事件流.md](./01工具执行与事件流.md) - 核心机制
- [Z.AI-GLM配置说明.md](./Z.AI-GLM配置说明.md) - API 配置

---

**创建时间**: 2025-10-16  
**端口**: 3000  
**状态**: ✅ 可用

🎉 **开始体验多步工具调用吧！**

