# Kode-SDK 多用户架构说明

## 🎯 核心架构原理

### 关键设计：单 Runtime，多 Agent

```
┌─────────────────────────────────────────────────────┐
│          应用启动时创建（单例）                          │
│                                                       │
│  ┌──────────────────────────────────────────────┐   │
│  │         AgentDependencies (Runtime)          │   │
│  │  ┌────────────────────────────────────────┐  │   │
│  │  │  Store (JSONStore/RedisStore)          │  │   │
│  │  │  - 所有 Agent 的持久化数据              │  │   │
│  │  │  - 按 agentId 隔离                      │  │   │
│  │  └────────────────────────────────────────┘  │   │
│  │  ┌────────────────────────────────────────┐  │   │
│  │  │  TemplateRegistry                      │  │   │
│  │  │  - 模板定义（系统提示、工具列表）         │  │   │
│  │  └────────────────────────────────────────┘  │   │
│  │  ┌────────────────────────────────────────┐  │   │
│  │  │  ToolRegistry                          │  │   │
│  │  │  - 工具注册表                           │  │   │
│  │  └────────────────────────────────────────┘  │   │
│  │  ┌────────────────────────────────────────┐  │   │
│  │  │  SandboxFactory                        │  │   │
│  │  │  - 沙箱工厂                             │  │   │
│  │  └────────────────────────────────────────┘  │   │
│  │  ┌────────────────────────────────────────┐  │   │
│  │  │  ModelFactory (GLM-4.5-air)            │  │   │
│  │  │  - 模型创建工厂                         │  │   │
│  │  └────────────────────────────────────────┘  │   │
│  └──────────────────────────────────────────────┘   │
└─────────────────────────────────────────────────────┘
                           │
                           │ 每个请求基于 userId/sessionId
                           │ 创建或恢复对应的 Agent
                           ▼
    ┌──────────────────────────────────────────────┐
    │           多个 Agent 实例                      │
    │                                                │
    │  Agent(agentId: 'user:123')  ← 用户 123       │
    │  Agent(agentId: 'user:456')  ← 用户 456       │
    │  Agent(agentId: 'session:abc') ← 会话 abc     │
    │  Agent(agentId: 'session:xyz') ← 会话 xyz     │
    │                                                │
    │  每个 Agent 有独立的：                          │
    │  - 消息队列                                     │
    │  - 工具调用记录                                 │
    │  - Todo 列表                                   │
    │  - 上下文状态                                   │
    │  - 沙箱环境                                     │
    └──────────────────────────────────────────────┘
```

## ✨ 核心概念

### 1. Runtime（依赖容器）- 单例

**Runtime 只需要一个**，在应用启动时创建：

```typescript
// server.ts (应用启动入口)
import { createRuntime } from './examples/shared/runtime';
import { GLMProvider } from './src';

// ✅ 全局单例 - 整个应用共享
const deps = createRuntime(({ templates, registerBuiltin }) => {
  registerBuiltin('fs', 'bash', 'todo');

  templates.register({
    id: 'repo-assistant',
    systemPrompt: '你是一个有帮助的助手',
    tools: ['fs_read', 'fs_write', 'todo_read', 'todo_write'],
    model: 'glm-4-air',
  });
}, {
  storeDir: './.kode',  // 所有用户数据存储在这里
});

// ✅ 配置 GLM 模型工厂
deps.modelFactory = (config) => new GLMProvider(
  'ef22d69d218e4cad8ae3c15bcc77d30d.eULl6aqOo8YEDKzG',
  'glm-4-air',
  'https://open.bigmodel.cn/api/paas/v4'
);
```

### 2. Agent 实例 - 每个用户/会话一个

**每个用户或会话有独立的 Agent 实例**：

```typescript
// api/chat.ts
import { Agent } from './src';

// ✅ Resume or Create 模式
async function getAgentForUser(userId: string) {
  const agentId = `user:${userId}`;  // 用 userId 作为 agentId
  
  // 检查是否已存在
  const exists = await deps.store.exists(agentId);
  
  if (exists) {
    // 恢复已有的 Agent
    return Agent.resumeFromStore(agentId, deps);
  }
  
  // 创建新 Agent
  return Agent.create({
    agentId,
    templateId: 'repo-assistant',
    sandbox: { 
      kind: 'local', 
      workDir: `./workspace/${userId}`,  // 每个用户独立工作目录
      enforceBoundary: true 
    },
  }, deps);
}
```

## 📋 API 调用方式

### 方式 1: Express API 示例（推荐）

```typescript
import express from 'express';
import { Agent } from './src';

const app = express();
app.use(express.json());

// ===== 初始化 Runtime（单例）=====
const deps = createRuntime(/* ... */);

// ===== Resume or Create Helper =====
async function resumeOrCreate(agentId: string) {
  const exists = await deps.store.exists(agentId);
  if (exists) {
    return Agent.resumeFromStore(agentId, deps);
  }
  
  return Agent.create({
    agentId,
    templateId: 'repo-assistant',
    sandbox: { kind: 'local', workDir: `./workspace/${agentId}` },
  }, deps);
}

// ===== API 端点 =====

// 1. 发送消息
app.post('/api/agents/:agentId/messages', async (req, res) => {
  const { agentId } = req.params;
  const { text } = req.body;
  
  const agent = await resumeOrCreate(agentId);
  
  // 绑定监控（可选）
  agent.on('error', (event) => {
    console.error('Agent error:', event.message);
  });
  
  await agent.send(text);
  
  res.status(202).json({ status: 'queued' });
});

// 2. 获取 Progress 流（SSE）
app.get('/api/agents/:agentId/stream', async (req, res) => {
  const { agentId } = req.params;
  const agent = await resumeOrCreate(agentId);
  
  // 设置 SSE headers
  res.setHeader('Content-Type', 'text/event-stream');
  res.setHeader('Cache-Control', 'no-cache');
  res.setHeader('Connection', 'keep-alive');
  res.flushHeaders();
  
  // 订阅事件流
  const iterator = agent.subscribe(['progress', 'monitor'])[Symbol.asyncIterator]();
  
  try {
    for await (const envelope of { [Symbol.asyncIterator]: () => iterator }) {
      // 发送 SSE 事件
      res.write(`data: ${JSON.stringify(envelope)}\n\n`);
      
      // 对话完成时结束流
      if (envelope.event.type === 'done') {
        break;
      }
    }
  } catch (error) {
    console.error('Stream error:', error);
  } finally {
    res.end();
  }
  
  // 客户端断开时清理
  req.on('close', () => {
    iterator.return?.();
  });
});

// 3. 获取 Agent 状态
app.get('/api/agents/:agentId/status', async (req, res) => {
  const { agentId } = req.params;
  const agent = await resumeOrCreate(agentId);
  
  const status = await agent.status();
  res.json(status);
});

// 4. 审批决策
app.post('/api/agents/:agentId/approve', async (req, res) => {
  const { agentId } = req.params;
  const { callId, decision, note } = req.body;
  
  const agent = await resumeOrCreate(agentId);
  await agent.decide(callId, decision, note);
  
  res.status(204).end();
});

app.listen(3000, () => {
  console.log('API server running on http://localhost:3000');
});
```

### 方式 2: Next.js API Route

```typescript
// pages/api/agents/[agentId]/stream.ts
import type { NextApiRequest, NextApiResponse } from 'next';
import { Agent } from '@/lib/kode-sdk';
import { deps } from '@/lib/runtime';

export default async function handler(
  req: NextApiRequest,
  res: NextApiResponse
) {
  const agentId = req.query.agentId as string;
  
  // Resume or Create
  const agent = await resumeOrCreate(agentId);
  
  // 绑定控制和监控
  agent.on('permission_required', (event) => {
    console.log('[Control] Approval needed:', event.call.name);
  });
  
  agent.on('tool_executed', (event) => {
    console.log('[Monitor] Tool executed:', event.call.name);
  });
  
  if (req.method === 'POST') {
    // 发送消息
    const { prompt } = req.body;
    await agent.send(prompt);
    res.status(202).json({ status: 'queued' });
    return;
  }
  
  if (req.method === 'GET') {
    // SSE 流
    res.setHeader('Content-Type', 'text/event-stream');
    res.setHeader('Cache-Control', 'no-cache');
    res.flushHeaders();
    
    for await (const envelope of agent.subscribe(['progress'])) {
      res.write(`data: ${JSON.stringify(envelope)}\n\n`);
      if (envelope.event.type === 'done') break;
    }
    
    res.end();
    return;
  }
  
  res.status(405).end();
}
```

## 🔑 多用户隔离策略

### 策略 1: 用户级隔离

```typescript
// 每个用户一个 Agent
const agentId = `user:${userId}`;

// 优点：
// - 保持长期对话上下文
// - 用户数据完全隔离
// - Todo、文件操作持久化

// 缺点：
// - 上下文可能过长
// - 需要定期清理或压缩
```

### 策略 2: 会话级隔离

```typescript
// 每个会话一个 Agent
const agentId = `session:${sessionId}`;

// 优点：
// - 上下文更清晰
// - 便于分叉和实验
// - 资源隔离更好

// 缺点：
// - 跨会话无法共享上下文
// - 需要管理会话生命周期
```

### 策略 3: 混合模式

```typescript
// 用户 + 会话组合
const agentId = `user:${userId}:session:${sessionId}`;

// 或者基于业务场景
const agentId = `project:${projectId}:task:${taskId}`;

// 优点：
// - 灵活性最高
// - 可以按需组织
// - 支持复杂业务场景
```

## 📊 多用户场景完整示例

### 完整的 Express 服务器

```typescript
// server.ts
import express from 'express';
import cors from 'cors';
import { Agent, AgentConfig, GLMProvider } from './src';
import { createRuntime } from './examples/shared/runtime';

// ===== 1. 创建全局 Runtime（单例）=====
const deps = createRuntime(({ templates, registerBuiltin }) => {
  registerBuiltin('fs', 'bash', 'todo');

  templates.register({
    id: 'chat-assistant',
    systemPrompt: '你是一个有帮助的AI助手，用中文回答问题。',
    tools: ['todo_read', 'todo_write', 'fs_read', 'fs_write'],
    model: 'glm-4-air',
    runtime: { 
      todo: { enabled: true, reminderOnStart: false } 
    },
  });
});

// 配置 GLM 模型
deps.modelFactory = (config) => new GLMProvider(
  'ef22d69d218e4cad8ae3c15bcc77d30d.eULl6aqOo8YEDKzG',
  'glm-4-air',
  'https://open.bigmodel.cn/api/paas/v4'
);

// ===== 2. Resume or Create Helper =====
async function resumeOrCreate(agentId: string): Promise<Agent> {
  const exists = await deps.store.exists(agentId);
  
  if (exists) {
    // 恢复已有 Agent
    const agent = await Agent.resumeFromStore(agentId, deps);
    bindMonitoring(agent);  // 重新绑定监控
    return agent;
  }
  
  // 创建新 Agent
  const agent = await Agent.create({
    agentId,
    templateId: 'chat-assistant',
    sandbox: { 
      kind: 'local', 
      workDir: `./workspace/${agentId}`,
      enforceBoundary: true 
    },
  }, deps);
  
  bindMonitoring(agent);
  return agent;
}

// ===== 3. 绑定监控和审批 =====
function bindMonitoring(agent: Agent) {
  // 监控工具执行
  agent.on('tool_executed', (event) => {
    console.log(`[${agent.agentId}] Tool executed:`, {
      tool: event.call.name,
      duration: event.call.durationMs,
      success: !event.call.isError,
    });
  });
  
  // 监控错误
  agent.on('error', (event) => {
    console.error(`[${agent.agentId}] Error:`, {
      phase: event.phase,
      message: event.message,
    });
  });
  
  // 处理审批请求
  agent.on('permission_required', (event) => {
    console.log(`[${agent.agentId}] Approval needed:`, event.call.name);
    // 这里可以推送到审批系统
  });
}

// ===== 4. 创建 API 路由 =====
const app = express();
app.use(cors());
app.use(express.json());

// 活跃的 Agent 缓存（可选优化）
const activeAgents = new Map<string, Agent>();

// API: 发送消息
app.post('/api/chat/:userId', async (req, res) => {
  try {
    const userId = req.params.userId;
    const { message, sessionId } = req.body;
    
    // 构建 agentId
    const agentId = sessionId 
      ? `user:${userId}:session:${sessionId}`
      : `user:${userId}`;
    
    // 获取或创建 Agent
    let agent = activeAgents.get(agentId);
    if (!agent) {
      agent = await resumeOrCreate(agentId);
      activeAgents.set(agentId, agent);
    }
    
    // 发送消息
    await agent.send(message);
    
    res.json({ 
      success: true, 
      agentId,
      message: '消息已发送' 
    });
  } catch (error) {
    res.status(500).json({ 
      success: false, 
      error: error.message 
    });
  }
});

// API: 获取流式响应（SSE）
app.get('/api/chat/:userId/stream', async (req, res) => {
  try {
    const userId = req.params.userId;
    const sessionId = req.query.sessionId as string;
    
    const agentId = sessionId 
      ? `user:${userId}:session:${sessionId}`
      : `user:${userId}`;
    
    // 获取或创建 Agent
    let agent = activeAgents.get(agentId);
    if (!agent) {
      agent = await resumeOrCreate(agentId);
      activeAgents.set(agentId, agent);
    }
    
    // 设置 SSE
    res.setHeader('Content-Type', 'text/event-stream');
    res.setHeader('Cache-Control', 'no-cache');
    res.setHeader('Connection', 'keep-alive');
    res.flushHeaders();
    
    // 订阅事件
    const iterator = agent.subscribe(['progress', 'monitor'])[Symbol.asyncIterator]();
    
    for await (const envelope of { [Symbol.asyncIterator]: () => iterator }) {
      res.write(`data: ${JSON.stringify(envelope)}\n\n`);
      
      if (envelope.event.type === 'done') {
        break;
      }
    }
    
    res.end();
    
    // 清理连接时的回调
    req.on('close', () => {
      iterator.return?.();
    });
  } catch (error) {
    console.error('Stream error:', error);
    res.status(500).end();
  }
});

// API: 获取用户的 Agent 状态
app.get('/api/chat/:userId/status', async (req, res) => {
  try {
    const userId = req.params.userId;
    const agentId = `user:${userId}`;
    
    const agent = await resumeOrCreate(agentId);
    const status = await agent.status();
    
    res.json({
      agentId,
      status,
      todos: await agent.getTodos(),
    });
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

// API: 审批工具调用
app.post('/api/chat/:userId/approve', async (req, res) => {
  try {
    const userId = req.params.userId;
    const { callId, decision, note } = req.body;
    
    const agentId = `user:${userId}`;
    const agent = activeAgents.get(agentId) || await resumeOrCreate(agentId);
    
    await agent.decide(callId, decision, note);
    
    res.json({ success: true });
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

// 启动服务器
app.listen(3000, () => {
  console.log('✅ 多用户 Kode-SDK 服务运行在 http://localhost:3000');
  console.log('📊 Runtime: 1 个（共享）');
  console.log('👥 Agent: 按需创建（每个用户独立）');
});
```

## 🎯 常见场景

### 场景 1: 聊天应用（多用户）

```typescript
// 用户 A 发消息
POST /api/chat/user-a/messages
Body: { "message": "你好" }

// 用户 B 发消息
POST /api/chat/user-b/messages
Body: { "message": "帮我写代码" }

// 两个用户各自有独立的 Agent 实例
// Agent(agentId: 'user:user-a')
// Agent(agentId: 'user:user-b')
```

### 场景 2: 多会话支持

```typescript
// 用户 A 的会话 1
const agentId1 = 'user:alice:session:session-1';

// 用户 A 的会话 2
const agentId2 = 'user:alice:session:session-2';

// 同一个用户可以有多个独立会话
// 每个会话有独立的上下文和 Todo
```

### 场景 3: 项目/任务级隔离

```typescript
// 项目 A 的代码审查 Agent
const agentId1 = 'project:proj-a:code-review';

// 项目 B 的文档生成 Agent
const agentId2 = 'project:proj-b:doc-gen';

// 基于业务逻辑组织 Agent
```

## 🔐 数据隔离和安全

### Store 层隔离

```typescript
// JSONStore 会为每个 agentId 创建独立文件
.kode/
├── user:123/
│   ├── messages.json
│   ├── tools.json
│   ├── todos.json
│   └── metadata.json
├── user:456/
│   ├── messages.json
│   └── ...
└── session:abc/
    └── ...
```

### Sandbox 隔离

```typescript
// 每个 Agent 独立的工作目录
workspace/
├── user:123/       # 用户 123 的文件
├── user:456/       # 用户 456 的文件
└── session:abc/    # 会话 abc 的文件

// 配置时指定
Agent.create({
  sandbox: {
    kind: 'local',
    workDir: `./workspace/${agentId}`,
    enforceBoundary: true,  // 强制边界，防止跨目录访问
  },
}, deps);
```

## 💡 性能优化建议

### 1. Agent 实例缓存

```typescript
// 缓存活跃的 Agent 实例，避免频繁从 Store 加载
const agentCache = new Map<string, { agent: Agent, lastAccess: number }>();

async function getAgent(agentId: string): Promise<Agent> {
  const cached = agentCache.get(agentId);
  
  if (cached) {
    cached.lastAccess = Date.now();
    return cached.agent;
  }
  
  const agent = await resumeOrCreate(agentId);
  agentCache.set(agentId, { agent, lastAccess: Date.now() });
  
  return agent;
}

// 定期清理不活跃的 Agent
setInterval(() => {
  const now = Date.now();
  const timeout = 30 * 60 * 1000;  // 30 分钟
  
  for (const [agentId, { lastAccess }] of agentCache.entries()) {
    if (now - lastAccess > timeout) {
      agentCache.delete(agentId);
      console.log(`Cleaned inactive agent: ${agentId}`);
    }
  }
}, 5 * 60 * 1000);  // 每 5 分钟清理一次
```

### 2. 使用 AgentPool

```typescript
import { AgentPool } from './src';

// AgentPool 内置了生命周期管理
const pool = new AgentPool({
  dependencies: deps,
  maxAgents: 100,  // 最大并发 Agent 数
});

// 使用 Pool
const agent = await pool.create({
  agentId: `user:${userId}`,
  templateId: 'chat-assistant',
  sandbox: { kind: 'local', workDir: `./workspace/user-${userId}` },
});

// Pool 会自动管理 Agent 生命周期
```

### 3. Store 优化

```typescript
// 对于高并发场景，使用 Redis Store
import { RedisCheckpointer } from './src';

const deps = createRuntime(/* ... */, {
  storeDir: './.kode',
  // 未来可切换到 Redis
});

// 或实现自定义 Store
class PostgresStore implements Store {
  // 实现 Store 接口
  // 数据存储在数据库中，支持更好的并发和查询
}
```

## 📈 扩展性考虑

### 水平扩展

```typescript
// 多个服务器实例共享同一个 Store
// 使用 Redis/PostgreSQL 作为共享存储

Server 1 ──┐
Server 2 ──┼──▶ Redis/PostgreSQL Store
Server 3 ──┘

// 注意事项：
// 1. Store 需要支持并发写入
// 2. 同一个 agentId 同时只能在一个实例中活跃
// 3. 使用分布式锁避免竞态
```

### 负载均衡

```typescript
// 基于 agentId 做一致性哈希
function getServerForAgent(agentId: string): string {
  const hash = hashCode(agentId);
  const serverIndex = hash % serverCount;
  return servers[serverIndex];
}

// 或使用粘性会话（Sticky Session）
// Nginx/HAProxy 配置：
// - 基于 userId 路由到固定服务器
// - 避免跨服务器迁移 Agent
```

## 🔍 监控和调试

### 监控指标

```typescript
// 统计活跃 Agent 数量
app.get('/api/metrics', (req, res) => {
  res.json({
    activeAgents: activeAgents.size,
    totalUsers: getUserCount(),
    runtime: {
      storeType: 'JSONStore',
      templateCount: deps.templateRegistry.list().length,
      toolCount: deps.toolRegistry.list().length,
    },
  });
});
```

### 调试日志

```typescript
// 为每个 Agent 添加详细日志
agent.on('state_changed', (event) => {
  console.log(`[${agent.agentId}] State: ${event.old} → ${event.new}`);
});

agent.on('token_usage', (event) => {
  console.log(`[${agent.agentId}] Tokens:`, {
    input: event.inputTokens,
    output: event.outputTokens,
  });
});
```

## ⚠️ 注意事项

### ✅ 正确做法

1. **Runtime 单例**: 全局只创建一次 `AgentDependencies`
2. **agentId 隔离**: 每个用户/会话使用唯一 agentId
3. **Resume or Create**: 每次请求检查是否已存在
4. **重新绑定事件**: Resume 后必须重新绑定 Control/Monitor 回调
5. **清理不活跃 Agent**: 定期清理缓存，避免内存泄漏

### ❌ 错误做法

1. ❌ **每个用户创建一个 Runtime**: 会导致资源浪费和数据冲突
2. ❌ **不使用 agentId 隔离**: 会导致用户数据混乱
3. ❌ **不重新绑定事件**: Resume 后事件监听会丢失
4. ❌ **共享同一个 Agent**: 多个用户使用同一个 agentId 会冲突
5. ❌ **忘记清理**: Agent 缓存无限增长导致内存问题

## 🎯 最佳实践总结

### 架构原则

```
✅ 单 Runtime，多 Agent
✅ 每个用户/会话独立 agentId
✅ Resume or Create 模式
✅ 状态持久化到 Store
✅ 事件驱动的异步架构
```

### 代码组织

```typescript
// ✅ 推荐结构
server.ts
├── 创建 Runtime（单例）
├── 定义 resumeOrCreate helper
├── 实现 API 路由
└── 启动服务器

// 每个请求：
1. 解析 userId/sessionId
2. 构建 agentId
3. resumeOrCreate(agentId)
4. 发送消息或订阅事件
5. 返回响应
```

### 资源管理

```typescript
// ✅ 生命周期管理
- 启动: 创建 Runtime（1次）
- 请求: 创建/恢复 Agent（按需）
- 清理: 定期清理不活跃 Agent
- 关闭: 优雅关闭所有 Agent
```

## 📚 相关文档

- [docs/api.md](./docs/api.md) - 完整 API 参考
- [docs/quickstart.md](./docs/quickstart.md) - 快速开始指南
- [docs/resume.md](./docs/resume.md) - Resume/Fork 详细说明
- [docs/playbooks.md](./docs/playbooks.md) - 典型场景脚本
- [examples/nextjs-api-route.ts](./examples/nextjs-api-route.ts) - Next.js 示例

## 🎊 总结

### 核心答案

**多用户场景下：**

1. ✅ **只需要 1 个 Runtime（依赖容器）** - 全局单例
2. ✅ **每个用户有独立的 Agent 实例** - 通过 agentId 区分
3. ✅ **数据自动隔离** - Store 按 agentId 分目录存储
4. ✅ **Resume or Create 模式** - 自动恢复已有会话

### 调用流程

```
用户请求 → 提取 userId/sessionId 
         → 构建 agentId 
         → resumeOrCreate(agentId) 
         → 发送消息/订阅事件 
         → 返回响应
```

### 性能特点

- 🚀 **高效**: Runtime 单例避免重复初始化
- 🔒 **安全**: agentId 隔离保证数据安全
- 📈 **可扩展**: 支持水平扩展（共享 Store）
- 💾 **持久化**: Agent 状态自动保存和恢复

**结论：Kode-SDK 的设计非常适合多用户场景！** ✨

