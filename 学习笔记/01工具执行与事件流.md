# 工具执行与事件流详解

## 概述

本文档详细说明 KODE SDK 中工具结果如何自动传递给 LLM，以及事件系统的三通道设计。

---

## 一、工具结果自动传递给 LLM 的完整流程

### 1.1 核心循环机制

工具结果的自动传递是通过 **"追加到 messages + 触发下一轮 runStep"** 实现的。

### 1.2 实际执行流程示例

假设用户发送："查一下北京天气，再计算 25+30"

```
用户: "查一下北京天气，再计算 25+30"
  ↓
① runStep() 调用 callModel()
  → 发送 messages 给 LLM
  ↓
② LLM 返回: tool_use = get_weather
  ↓
③ Agent 执行 (agent.ts:950-955)
  const toolBlocks = assistantBlocks.filter(block => block.type === 'tool_use')
  const outcomes = await this.executeTools(toolBlocks)
  // outcomes = [{ 
  //   type: 'tool_result', 
  //   tool_use_id: 'xxx', 
  //   content: {city: "北京", temp: 22} 
  // }]
  ↓
④ 将工具结果追加到对话历史 (agent.ts:955)
  this.messages.push({ role: 'user', content: outcomes })
  // messages 现在包含:
  // [...之前的对话, 
  //  {role: 'assistant', content: [tool_use]},
  //  {role: 'user', content: [tool_result]}  ← 工具结果在这里！
  // ]
  ↓
⑤ 继续处理 (agent.ts:960)
  this.ensureProcessing()
  // 触发下一轮 runStep()
  ↓
⑥ 新一轮 runStep() 调用 callModel()
  → 将包含工具结果的完整 messages 再次发送给 LLM
  ↓
⑦ LLM 看到天气结果，决定调用 add(25, 30)
  → 重复 ③-⑤
  ↓
⑧ 再次 runStep()，LLM 基于两个结果生成最终回答
  ↓
⑨ 没有 tool_use，发出 'done' 事件 (agent.ts:967-972)
```

### 1.3 关键代码位置

**文件**: `kode-sdk/src/core/agent.ts`

```typescript
// line 950-962: 工具结果自动传递的核心逻辑
const toolBlocks = assistantBlocks.filter((block) => block.type === 'tool_use');
if (toolBlocks.length > 0) {
  this.setBreakpoint('TOOL_PENDING');
  const outcomes = await this.executeTools(toolBlocks);
  if (outcomes.length > 0) {
    // 关键：将工具结果以 user 角色追加到消息历史
    this.messages.push({ role: 'user', content: outcomes });
    this.lastSfpIndex = this.messages.length - 1;
    this.stepCount++;
    await this.persistMessages();
    this.todoManager.onStep();
    // 关键：触发下一轮处理
    this.ensureProcessing();
    return;
  }
}
```

### 1.4 消息格式

工具结果被封装为标准的 `tool_result` 消息：

```typescript
{
  type: 'tool_result',
  tool_use_id: 'toolu_xxx',
  content: {
    // 工具返回的结果
    ok: true,
    data: { city: "北京", temp: 22 }
  }
}
```

如果工具执行失败：

```typescript
{
  type: 'tool_result',
  tool_use_id: 'toolu_xxx',
  content: {
    ok: false,
    error: "API 调用失败",
    _thrownError: true
  },
  is_error: true
}
```

---

## 二、事件系统的三通道设计

### 2.1 核心理念

> **默认只推必要事件，其余一律走回调**

将交互拆成三条独立通道：

```
Progress → 数据面（UI 渲染）
Control  → 审批面（人工决策）
Monitor  → 治理面（审计/告警）
```

### 2.2 Progress 通道：数据面

**用途**: 所有对用户可见的数据流

| 事件类型 | 说明 |
|---------|------|
| `text_chunk` | LLM 生成的文本增量 |
| `tool:start` | 工具开始执行 |
| `tool:end` | 工具执行完成（无论成功失败） |
| `tool:error` | 工具执行错误 |
| `done` | 当前轮处理完毕 |

**示例代码**:

```typescript
// examples/01-agent-inbox.ts:39-59
for await (const envelope of agent.subscribe(['progress'])) {
  switch (envelope.event.type) {
    case 'text_chunk':
      process.stdout.write(envelope.event.delta);
      break;
    case 'tool:start':
      console.log(`\n[tool] ${envelope.event.call.name} start`);
      break;
    case 'tool:end':
      console.log(`\n[tool] ${envelope.event.call.name} end`);
      break;
    case 'tool:error':
      console.warn(`\n[tool:error] ${envelope.event.error}`);
      break;
    case 'done':
      console.log('\n[progress] done at seq', envelope.bookmark?.seq);
      return;
  }
}
```

**最佳实践**:
- 使用 SSE/WebSocket 将 Progress 推送到前端
- 保存 `bookmark` / `cursor`，断线后以 `since` 续播
- UI 只负责展示，业务判断放到 Control/Monitor

### 2.3 Control 通道：审批面

**用途**: 处理需要人类决策的瞬间

| 事件类型 | 说明 |
|---------|------|
| `permission_required` | 工具执行需审批 |
| `permission_decided` | 审批结果广播 |

**示例代码**:

```typescript
// examples/01-agent-inbox.ts:62-66
agent.on('permission_required', async (event: ControlPermissionRequiredEvent) => {
  if (event.call.name === 'bash_run') {
    await event.respond('deny', { note: 'Demo inbox denies bash_run by default.' });
  }
  // 其他工具不会触发此逻辑，会正常执行
});
```

**重要说明**:
- 这个示例**只拒绝 `bash_run`**，不是拒绝所有工具
- 如果不监听 `permission_required`，所有工具都会自动执行
- 可以通过模板的 `requireApprovalTools` 配置哪些工具需要审批

**审批流程**:

```typescript
agent.on('permission_required', async (event) => {
  // 保存审批请求
  const ticketId = await approvalStore.create({
    agentId: agent.agentId,
    callId: event.call.id,
    tool: event.call.name,
    preview: event.call.inputPreview,
  });
  
  // 可以立即响应或等待 UI 决定
  // 选项1: 立即拒绝
  await event.respond('deny', { note: `Pending approval ${ticketId}` });
  
  // 选项2: 稍后通过 API 决定
  // await agent.decide(callId, 'allow' | 'deny', note);
});
```

### 2.4 Monitor 通道：治理面

**用途**: 平台治理、审计、告警

| 事件类型 | 说明 |
|---------|------|
| `tool_executed` | 工具执行完成，含耗时、审批信息 |
| `error` | 分类错误（model/tool/system） |
| `state_changed` | Agent 状态切换 |
| `todo_changed` | Todo 生命周期 |
| `file_changed` | FilePool 观察到外部改动 |

**示例代码**:

```typescript
// examples/01-agent-inbox.ts:69-75
agent.on('tool_executed', (event: MonitorToolExecutedEvent) => {
  console.log('[audit]', event.call.name, `${event.call.durationMs ?? 0}ms`);
});

agent.on('error', (event: MonitorErrorEvent) => {
  console.error('[monitor:error]', event.phase, event.message, event.detail || '');
});
```

**最佳实践**:
- 统一将 Monitor 事件发送到日志/监控平台
- 不要直接推给终端用户（造成噪音）
- 注意 `severity` 字段（info/warn/error）

### 2.5 subscribe vs on：如何选择

| 方式 | 特点 | 适用场景 |
|-----|------|---------|
| `agent.subscribe([...])` | 有序事件流、AsyncIterable | 前端/SSE/WebSocket |
| `agent.on(type, handler)` | 回调式监听 | 后台逻辑（审批、审计） |

**示例**:

```typescript
// 前端数据流
const stream = agent.subscribe(['progress', 'monitor']);
for await (const envelope of stream) {
  // 处理事件
}

// 后端治理
const off = agent.on('tool_executed', handler);
// 适当时机调用 off() 解除绑定
```

---

## 三、工具执行状态机

### 3.1 工具调用状态

```
PENDING           → 等待执行
AWAITING_APPROVAL → 等待审批
RUNNING           → 执行中
COMPLETED         → 执行成功
FAILED            → 执行失败
DENIED            → 审批拒绝
SEALED            → 自动封口（Resume 时未完成的调用）
```

### 3.2 状态转换

```
PENDING → AWAITING_APPROVAL → DENIED
       ↓                    ↘ RUNNING → COMPLETED
                                      ↘ FAILED
                                      
Resume 时未完成 → SEALED
```

### 3.3 自动封口机制

当 Agent Resume 时，未完成的工具调用会被自动封口：

```typescript
{
  ok: false,
  error: "工具执行过程中会话中断，系统已自动封口。",
  recommendations: [
    "检查工具可能产生的副作用",
    "确认外部系统状态后再重试"
  ],
  _autoSealed: true
}
```

---

## 四、实战示例分析

### 4.1 完整对话流程

**用户输入**: "列出 src 目录，找到所有 TODO，创建对应的 todo"

**执行流程**:

```
① Agent.send('列出 src 目录...')
   → 消息入队
   
② runStep()
   → callModel() 发送给 LLM
   
③ LLM 返回: tool_use = fs_glob
   → Progress: tool:start
   
④ executeTools([fs_glob])
   → 执行 fs_glob({ pattern: 'src/**/*' })
   → 返回文件列表
   → Progress: tool:end
   
⑤ messages.push({ role: 'user', content: [tool_result] })
   → ensureProcessing()
   
⑥ 新一轮 runStep()
   → LLM 看到文件列表，决定调用 fs_grep
   → Progress: tool:start
   
⑦ executeTools([fs_grep])
   → 执行 fs_grep({ pattern: 'TODO', files: [...] })
   → 返回匹配结果
   → Progress: tool:end
   
⑧ 新一轮 runStep()
   → LLM 看到 TODO 列表，决定调用 todo_write
   → 如果配置了审批: Control: permission_required
   
⑨ 审批通过后执行 todo_write
   → Monitor: tool_executed (审计日志)
   
⑩ 最终 runStep()
   → LLM 生成总结文本
   → Progress: text_chunk
   → Progress: done
```

### 4.2 事件时间线

```
Timeline:
│
├─ [Progress] text_chunk: "我来帮你..."
├─ [Progress] tool:start { call: { name: 'fs_glob' } }
├─ [Progress] tool:end { call: { name: 'fs_glob', durationMs: 150 } }
├─ [Monitor] tool_executed { name: 'fs_glob', ... }
│
├─ [Progress] tool:start { call: { name: 'fs_grep' } }
├─ [Progress] tool:end { call: { name: 'fs_grep', durationMs: 250 } }
├─ [Monitor] tool_executed { name: 'fs_grep', ... }
│
├─ [Control] permission_required { call: { name: 'todo_write' } }
├─ [Control] permission_decided { decision: 'allow' }
│
├─ [Progress] tool:start { call: { name: 'todo_write' } }
├─ [Progress] tool:end { call: { name: 'todo_write', durationMs: 80 } }
├─ [Monitor] tool_executed { name: 'todo_write', approval: {...} }
│
├─ [Progress] text_chunk: "已创建 3 个 todo..."
├─ [Progress] done { step: 4, reason: 'completed' }
└─
```

---

## 五、调试技巧

### 5.1 查看 Agent 状态

```typescript
const status = agent.status();
console.log({
  state: status.state,              // READY / WORKING / PAUSED
  lastSfpIndex: status.lastSfpIndex, // 最后一个 system-facing payload
  cursor: status.cursor,             // 当前事件游标
  stepCount: status.stepCount        // 执行步数
});
```

### 5.2 断点续播

```typescript
// 保存 bookmark
let lastBookmark;
for await (const envelope of agent.subscribe(['progress'])) {
  if (envelope.event.type === 'done') {
    lastBookmark = envelope.bookmark;
  }
}

// 断线后续播
const stream = agent.subscribe(['progress'], { since: lastBookmark });
```

### 5.3 监控卡顿

```typescript
agent.on('state_changed', (event) => {
  console.log(`State: ${event.from} → ${event.to}`);
  
  if (event.to === 'PAUSED') {
    // 检查是否卡在审批
    const status = agent.status();
    console.log('Pending permissions:', status.pendingPermissions);
  }
});
```

---

## 六、常见问题

### Q1: 工具结果会丢失吗？

**不会**。工具结果会：
1. 追加到 `this.messages`
2. 调用 `await this.persistMessages()` 持久化
3. 即使进程重启，Resume 后也能恢复

### Q2: 如果工具执行超时怎么办？

- Agent 会自动 abort 并标记为 `FAILED`
- 生成包含超时信息的 `tool_result`
- LLM 会看到超时错误并决定下一步

### Q3: 审批拒绝后会怎样？

- 工具调用标记为 `DENIED`
- 生成 `tool_result` 包含拒绝原因
- LLM 会看到拒绝信息并调整策略（或放弃）

### Q4: 如何配置哪些工具需要审批？

```typescript
templates.register({
  id: 'my-template',
  tools: ['fs_read', 'bash_run'],
  permission: {
    requireApprovalTools: ['bash_run']  // 只有 bash_run 需要审批
  }
});
```

### Q5: 为什么有时候 `done` 事件不触发？

可能原因：
- Agent 卡在 `AWAITING_APPROVAL` 状态
- 工具调用超时但未正确处理
- Progress 订阅被意外关闭

检查：
```typescript
const status = agent.status();
console.log(status.state, status.pendingPermissions);
```

---

## 七、参考文档

- **核心实现**: `kode-sdk/src/core/agent.ts` (runStep, executeTools)
- **事件系统**: `kode-sdk/docs/events.md`
- **快速开始**: `kode-sdk/docs/quickstart.md`
- **示例代码**: `kode-sdk/examples/01-agent-inbox.ts`
- **工具定义**: `kode-sdk/src/tools/tool.ts`

---

## 八、总结

### 关键要点

1. ✅ **工具结果自动传递**: 通过 `messages.push` + `ensureProcessing()` 实现循环
2. ✅ **三通道分离**: Progress（UI）、Control（审批）、Monitor（审计）
3. ✅ **断点续播**: bookmark/cursor 支持断线重连
4. ✅ **自动封口**: Resume 时未完成的调用会被安全封口
5. ✅ **事件驱动**: 所有关键节点都有对应事件

### 设计哲学

> **像同事一样协作**：Agent 不是"调用一次返回结果"的函数，而是"持续协作的同事"。工具结果的自动传递、事件的三通道分离，都是为了让 Agent 能像真正的团队成员一样工作。

---

**更新时间**: 2025-10-16
**适用版本**: KODE SDK v2.7+

