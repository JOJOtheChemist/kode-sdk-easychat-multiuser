# 存储结构优化 - 扁平化改造

> **日期**: 2025-10-21  
> **任务**: 优化 kode-sdk 存储路径，消除多层嵌套问题  
> **结果**: ✅ 完全成功

---

## 一、问题背景

在使用多用户多会话功能时，发现存储路径存在严重的嵌套问题：

### 旧的嵌套结构

```
.kode/
└── user1/
    └── concurrent_test_1/
        └── schedule-assistant/
            └── user1:concurrent_test_1:schedule-assistant/  ❌ 重复嵌套
                ├── runtime/
                │   ├── messages.json
                │   └── tool-calls.json
                └── events/
                    ├── progress.log
                    └── monitor.log
```

**问题分析**:
1. ❌ 路径嵌套 4-5 层，过于复杂
2. ❌ `user1:concurrent_test_1:schedule-assistant` 信息重复
3. ❌ 目录名包含冒号，不够清晰
4. ❌ 多余的 `schedule-assistant` 层级没有实际意义

### 期望的扁平结构

```
.kode/
├── user1/
│   ├── session1/          ✅ 会话1
│   │   ├── runtime/
│   │   └── events/
│   └── session2/          ✅ 会话2
│       ├── runtime/
│       └── events/
└── user2/
    ├── session1/          ✅ 会话1
    │   ├── runtime/
    │   └── events/
    └── session2/          ✅ 会话2
        ├── runtime/
        └── events/
```

**优化目标**:
- ✅ 只需 3 层目录（用户/会话/类型）
- ✅ 清晰的命名规范
- ✅ 易于理解和管理

---

## 二、问题根源分析

### 原因分析

经过代码追踪，发现问题出在三个地方的路径拼接：

#### 1. `server/routes/chat.ts` (第 76 行)

生成完整的 agentId：

```typescript
const agentIdForSession = sessionId 
  ? `${userId}:${sessionId}:${agentId}` 
  : agentId;

// 结果: "user1:concurrent_test_1:schedule-assistant"
```

#### 2. `server/services/agent-service.ts` (第 38-39 行)

旧代码将 agentId 转换为路径：

```typescript
// ❌ 旧代码
const agentIdForPath = agentId.replace(/:/g, '/');
const storePath = `./.kode/${agentIdForPath}`;

// 结果: .kode/user1/concurrent_test_1/schedule-assistant
```

#### 3. `src/infra/store.ts` (JSONStore)

JSONStore 在 baseDir 后自动添加 agentId 层：

```typescript
private getAgentDir(agentId: string): string {
  return path.join(this.baseDir, agentId);
}

private getRuntimePath(agentId: string, file: string): string {
  const dir = path.join(this.baseDir, agentId, 'runtime');
  return path.join(dir, file);
}
```

**最终路径拼接过程**:
```
baseDir:  .kode/user1/concurrent_test_1/schedule-assistant
agentId:  user1:concurrent_test_1:schedule-assistant
---------------------------------------------------------
结果:     .kode/user1/concurrent_test_1/schedule-assistant/
          user1:concurrent_test_1:schedule-assistant/runtime/  ❌
```

---

## 三、解决方案

### 核心思路

利用 JSONStore 自动添加 agentId 的特性，调整路径分配：

- **baseDir**: 只到用户层 `.kode/userId`
- **agentId**: 使用 sessionId（会话标识）
- **最终路径**: JSONStore 自动生成 `.kode/userId/sessionId/runtime/`

### 修改代码

**文件**: `/Users/yeya/FlutterProjects/kode-sdk/kode-sdk/server/services/agent-service.ts`

```typescript
console.log(`🆕 [创建] 初始化 Agent: ${agentId}`);

// 🔥 优化存储结构：userId/sessionId/（扁平化，避免多层嵌套）
// agentId 格式: userId:sessionId:agentType (例如: user1:concurrent_test_1:schedule-assistant)
// JSONStore 会在 baseDir 后自动添加 agentId 作为子目录
// 所以：baseDir=.kode/userId, agentId=sessionId
// 最终路径：.kode/userId/sessionId/runtime/ 和 .kode/userId/sessionId/events/
const parts = agentId.split(':');
let storePath: string;
let storeAgentId: string;

if (parts.length === 3) {
  // 多用户多会话模式: user1:session1:agent-type
  const [userId, sessionId, agentType] = parts;
  storePath = `./.kode/${userId}`;  // baseDir 只到用户层
  storeAgentId = sessionId;  // sessionId 作为 agentId，JSONStore 会自动添加这一层
  console.log(`📁 [存储] 用户: ${userId}, 会话: ${sessionId}, 最终路径: ${storePath}/${storeAgentId}/`);
} else {
  // 兼容模式: 原始单层 agentId
  storePath = `./.kode`;
  storeAgentId = agentId;
  console.log(`📁 [存储] 兼容模式，Agent: ${agentId}, 最终路径: ${storePath}/${agentId}/`);
}

const store = new JSONStore(storePath);
```

**关键改动**:

| 项目 | 修改前 | 修改后 |
|------|--------|--------|
| storePath | `.kode/user1/session1/agent-type` | `.kode/user1` |
| storeAgentId | `runtime` (固定值) | `session1` (会话ID) |
| 最终路径 | `.kode/user1/session1/agent-type/runtime/runtime/` ❌ | `.kode/user1/session1/runtime/` ✅ |

### 同步修改 Agent 创建

```typescript
// 检查是否存在历史数据（使用内部存储ID）
const exists = await deps.store.exists(storeAgentId);
let agent: Agent;

if (exists) {
  console.log(`📂 [恢复] 从 Store 恢复 Agent: ${agentId} (存储ID: ${storeAgentId})`);
  agent = await Agent.resumeFromStore(storeAgentId, deps);
  console.log(`✅ [恢复] Agent 恢复成功，消息历史已加载`);
} else {
  console.log(`🔧 [创建] 创建新 Agent: ${agentId} (存储ID: ${storeAgentId})`);
  agent = await Agent.create(
    {
      agentId: storeAgentId, // 使用简化的存储ID
      templateId: agentConfig.templateId,
      sandbox: { kind: 'local', workDir: config.agent.workDir },
      exposeThinking: true,
      metadata: {
        toolTimeoutMs: config.agent.toolTimeoutMs,
        maxToolConcurrency: config.agent.maxToolConcurrency,
      },
    },
    deps
  );
  console.log(`✅ [创建] Agent 创建完成`);
}
```

---

## 四、测试验证

### 测试步骤

1. **清除旧数据**
   ```bash
   cd /Users/yeya/FlutterProjects/kode-sdk/kode-sdk
   rm -rf .kode/user*
   ```

2. **重启服务器**
   ```bash
   bash restart-backend.sh
   ```

3. **运行测试脚本**
   ```bash
   node /Users/yeya/FlutterProjects/kode-sdk/多用户学习笔记/concurrent-test-1.js
   node /Users/yeya/FlutterProjects/kode-sdk/多用户学习笔记/concurrent-test-2.js
   ```

### 测试结果

#### ✅ 目录结构验证

```bash
$ find .kode -type d | grep -E "(user1|user2)" | sort

.kode/user1
.kode/user1/concurrent_test_1
.kode/user1/concurrent_test_1/events
.kode/user1/concurrent_test_1/runtime
.kode/user2
.kode/user2/concurrent_test_2
.kode/user2/concurrent_test_2/events
.kode/user2/concurrent_test_2/runtime
```

**结构图**:
```
.kode/
├── user1/
│   └── concurrent_test_1/        ✅ 会话1
│       ├── events/
│       │   ├── monitor.log
│       │   └── progress.log
│       ├── runtime/
│       │   ├── messages.json
│       │   └── tool-calls.json
│       └── meta.json
└── user2/
    └── concurrent_test_2/        ✅ 会话2
        ├── events/
        │   ├── monitor.log
        │   └── progress.log
        ├── runtime/
        │   ├── messages.json
        │   └── tool-calls.json
        └── meta.json
```

#### ✅ 功能验证

| 测试项 | 结果 | 说明 |
|-------|------|------|
| 测试1 (user1创建日程) | ✅ 成功 | 13秒，创建记录#13066 |
| 测试2 (user2查询日程) | ✅ 成功 | 11秒，智能查询明日日程 |
| 用户隔离 | ✅ 正常 | user1 和 user2 数据完全隔离 |
| 会话隔离 | ✅ 正常 | 不同 sessionId 独立存储 |
| 数据持久化 | ✅ 正常 | messages 和 tool-calls 正确保存 |
| 事件流 | ✅ 正常 | progress 和 monitor 事件正常记录 |

#### ✅ 服务器日志验证

**用户1创建会话**:
```
🆕 [创建] 初始化 Agent: user1:concurrent_test_1:schedule-assistant
📁 [存储] 用户: user1, 会话: concurrent_test_1, 最终路径: ./.kode/user1/concurrent_test_1/
🔧 [创建] 创建新 Agent: user1:concurrent_test_1:schedule-assistant (存储ID: concurrent_test_1)
✅ [创建] Agent 创建完成
```

**用户2创建会话**:
```
🆕 [创建] 初始化 Agent: user2:concurrent_test_2:schedule-assistant
📁 [存储] 用户: user2, 会话: concurrent_test_2, 最终路径: ./.kode/user2/concurrent_test_2/
🔧 [创建] 创建新 Agent: user2:concurrent_test_2:schedule-assistant (存储ID: concurrent_test_2)
✅ [创建] Agent 创建完成
```

---

## 五、关键优势

### 1. 清晰的层级结构

```
用户层 → 会话层 → 数据类型层
 ↓        ↓          ↓
user1  session1   runtime/events
```

### 2. 易于管理

- **查看某用户的所有会话**: `ls .kode/user1/`
- **查看某会话的消息**: `cat .kode/user1/session1/runtime/messages.json`
- **删除某会话**: `rm -rf .kode/user1/session1/`
- **备份某用户**: `tar -czf user1.tar.gz .kode/user1/`

### 3. 支持多场景

| 场景 | agentId 格式 | 存储路径 |
|------|-------------|---------|
| 多用户多会话 | `user1:session1:agent-type` | `.kode/user1/session1/` ✅ |
| 单用户多会话 | `user1:session2:agent-type` | `.kode/user1/session2/` ✅ |
| 兼容模式 | `simple-agent-id` | `.kode/simple-agent-id/` ✅ |

### 4. 性能友好

- ✅ 减少目录嵌套深度
- ✅ 文件系统更高效
- ✅ 更容易索引和搜索

---

## 六、迁移指南

### 如果有旧数据需要迁移

**步骤 1**: 备份旧数据
```bash
cd /Users/yeya/FlutterProjects/kode-sdk/kode-sdk
tar -czf kode-backup-$(date +%Y%m%d).tar.gz .kode/
```

**步骤 2**: 手动迁移（如果需要）
```bash
# 旧路径示例
.kode/user1/session1/agent-type/user1:session1:agent-type/runtime/messages.json

# 迁移到新路径
mkdir -p .kode/user1/session1/runtime/
cp .kode/user1/session1/agent-type/user1:session1:agent-type/runtime/messages.json \
   .kode/user1/session1/runtime/messages.json
```

**步骤 3**: 验证数据
```bash
# 检查新路径下的文件
find .kode/user1 -type f
```

**步骤 4**: 清理旧数据
```bash
# 确认无误后删除旧目录
rm -rf .kode/user1/session1/agent-type/
```

### 自动迁移脚本（可选）

如果需要批量迁移，可以创建脚本：

```bash
#!/bin/bash
# migrate-storage.sh

for user_dir in .kode/*/; do
  user=$(basename "$user_dir")
  for session_dir in "$user_dir"*/; do
    session=$(basename "$session_dir")
    for agent_dir in "$session_dir"*/; do
      # 查找深层嵌套的数据
      old_runtime="$agent_dir"*/runtime/
      old_events="$agent_dir"*/events/
      
      if [ -d "$old_runtime" ]; then
        echo "迁移: $old_runtime → $session_dir/runtime/"
        mkdir -p "$session_dir/runtime/"
        cp -r "$old_runtime"* "$session_dir/runtime/"
      fi
      
      if [ -d "$old_events" ]; then
        echo "迁移: $old_events → $session_dir/events/"
        mkdir -p "$session_dir/events/"
        cp -r "$old_events"* "$session_dir/events/"
      fi
    done
  done
done
```

---

## 七、最佳实践

### 1. 命名规范

- **用户ID**: 使用小写字母和数字，如 `user1`, `alice`, `bob123`
- **会话ID**: 有意义的标识符，如 `morning_chat`, `project_discussion`, `session_20251021`
- **避免**: 特殊字符、空格、中文（可能导致跨平台问题）

### 2. 会话管理

```typescript
// ✅ 推荐：使用时间戳+描述
const sessionId = `chat_${Date.now()}_project`;

// ✅ 推荐：使用 UUID
const sessionId = `session_${crypto.randomUUID().slice(0, 8)}`;

// ❌ 避免：过长的ID
const sessionId = `very-long-session-id-with-lots-of-information`;
```

### 3. 定期清理

```bash
# 清理30天前的旧会话
find .kode -type d -name "session_*" -mtime +30 -exec rm -rf {} \;

# 归档重要会话
tar -czf archive/user1_important_session.tar.gz .kode/user1/important_session/
```

### 4. 监控存储空间

```bash
# 查看各用户占用空间
du -sh .kode/*/

# 查看总占用
du -sh .kode/
```

---

## 八、相关文档

- [01多用户学习笔记.md](./01多用户学习笔记.md)
- [02yeya与nuo用户并发调用实战.md](./02yeya与nuo用户并发调用实战.md)
- [05服务器启动与并发测试成功记录.md](./05服务器启动与并发测试成功记录.md)

---

## 九、总结

通过这次存储结构优化，我们成功地：

✅ **简化了目录结构** - 从 5 层减少到 3 层  
✅ **提高了可读性** - 清晰的用户/会话/数据分层  
✅ **保持了功能** - 所有多用户多会话功能正常  
✅ **提升了性能** - 更扁平的结构，更快的访问  
✅ **易于维护** - 更直观的管理和备份  

这是一次非常成功的重构！🎉

**修改文件**: 
- `/Users/yeya/FlutterProjects/kode-sdk/kode-sdk/server/services/agent-service.ts`

**影响范围**:
- 所有新创建的用户会话
- 兼容旧的单层 agentId 模式

**下一步建议**:
- 可以考虑添加会话列表管理功能
- 实现会话归档和恢复
- 添加存储空间监控告警

