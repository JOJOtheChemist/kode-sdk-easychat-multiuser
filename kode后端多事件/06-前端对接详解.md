# KODE SDK前端对接详解 - 笔记 #6

## 前端对接架构概览

KODE SDK提供了完整的前端对接方案，基于**HTTP REST API + SSE（Server-Sent Events）**架构。

### 核心组件
1. **后端API服务器** - Express.js服务器，提供REST API和SSE流
2. **前端客户端** - HTML/JavaScript客户端，通过API与后端通信
3. **事件流系统** - 实时双向通信，支持流式输出

## 前端对接方式

### 1. API接口设计

#### 创建会话
```http
POST /api/conversations
Content-Type: application/json

Response:
{
  "conversationId": "conv_1234567890",
  "agentId": "agt_conv_1234567890", 
  "templateId": "chat-assistant",
  "createdAt": "2025-10-14T17:45:00.000Z",
  "status": "ready"
}
```

#### 发送消息
```http
POST /api/conversations/{conversationId}/messages
Content-Type: application/json

Request Body:
{
  "content": "用户输入的消息"
}

Response:
{
  "messageId": "msg_1234567890",
  "status": "queued"
}
```

#### 获取会话历史
```http
GET /api/conversations/{conversationId}/history

Response:
{
  "messages": [
    {
      "id": "user-123",
      "kind": "text",
      "role": "user", 
      "content": "用户消息"
    },
    {
      "id": "assistant-124",
      "kind": "text",
      "role": "assistant",
      "content": "AI回复"
    }
  ]
}
```

### 2. SSE实时事件流

#### 连接事件流
```javascript
const eventSource = new EventSource(
  `http://localhost:3000/api/conversations/${conversationId}/events`
);
```

#### 支持的事件类型
```javascript
// 文本流式输出
eventSource.addEventListener('text_chunk', (e) => {
  const { event } = JSON.parse(e.data);
  appendTextChunk(event.delta); // 追加文本片段
});

// 文本结束
eventSource.addEventListener('text_chunk_end', (e) => {
  const { event } = JSON.parse(e.data);
  finalizeTextMessage(event.text); // 完成文本消息
});

// 工具调用开始
eventSource.addEventListener('tool:start', (e) => {
  const { event } = JSON.parse(e.data);
  addToolCall(event.call, 'executing'); // 显示工具执行状态
});

// 工具调用结束
eventSource.addEventListener('tool:end', (e) => {
  const { event } = JSON.parse(e.data);
  updateToolCall(event.call); // 更新工具完成状态
});

// 对话完成
eventSource.addEventListener('done', (e) => {
  console.log('对话完成');
  removeTypingIndicator();
});
```

## 前端实现示例

### 完整的前端代码结构
```html
<!DOCTYPE html>
<html>
<head>
  <title>KODE SDK 对话 Demo</title>
  <style>
    /* 现代化UI样式 */
    .container { /* 对话容器 */ }
    .messages { /* 消息显示区域 */ }
    .message { /* 单条消息样式 */ }
    .tool-call { /* 工具调用显示 */ }
    .typing-indicator { /* 输入中指示器 */ }
  </style>
</head>
<body>
  <div class="container">
    <div class="header">KODE SDK 对话 Demo</div>
    <div class="status">
      <div class="status-dot" id="statusDot"></div>
      <span id="statusText">未连接</span>
    </div>
    <div class="messages" id="messages">
      <!-- 消息动态插入 -->
    </div>
    <div class="input-area">
      <input type="text" id="messageInput" placeholder="输入消息..." />
      <button onclick="sendMessage()">发送</button>
    </div>
  </div>

  <script>
    let conversationId = null;
    let eventSource = null;

    // 初始化连接
    async function init() {
      // 1. 创建会话
      const response = await fetch('/api/conversations', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' }
      });
      const data = await response.json();
      conversationId = data.conversationId;
      
      // 2. 连接SSE
      connectSSE();
    }

    // 连接SSE事件流
    function connectSSE() {
      eventSource = new EventSource(
        `/api/conversations/${conversationId}/events`
      );
      
      // 事件监听...
    }

    // 发送消息
    async function sendMessage() {
      const content = messageInput.value.trim();
      
      // 1. 显示用户消息
      addUserMessage(content);
      
      // 2. 发送到后端
      await fetch(`/api/conversations/${conversationId}/messages`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ content })
      });
      
      // 3. 显示输入中指示器
      addTypingIndicator();
    }

    // UI更新函数
    function addUserMessage(content) { /* 添加用户消息 */ }
    function addToolCall(call, status) { /* 添加工具调用显示 */ }
    function appendTextChunk(delta) { /* 追加文本片段 */ }
    function removeTypingIndicator() { /* 移除输入指示器 */ }
  </script>
</body>
</html>
```

## 后端配置

### Express服务器配置
```typescript
import express from 'express';
import cors from 'cors';
import { Agent, createRuntime } from '@kode/sdk';

const app = express();
app.use(cors());
app.use(express.json());

// 创建运行时依赖
const deps = createRuntime();
const agents = new Map<string, Agent>();

// 创建会话
app.post('/api/conversations', async (req, res) => {
  const conversationId = `conv_${Date.now()}`;
  
  const agent = await Agent.create({
    agentId: `agt_${conversationId}`,
    templateId: 'chat-assistant',
    sandbox: { 
      kind: 'local', 
      workDir: './workspace',
      enforceBoundary: false 
    }
  }, deps);
  
  agents.set(conversationId, agent);
  
  res.json({
    conversationId,
    agentId: agent.agentId,
    status: 'ready'
  });
});

// SSE事件流
app.get('/api/conversations/:id/events', async (req, res) => {
  const agent = agents.get(req.params.id);
  
  // 设置SSE headers
  res.setHeader('Content-Type', 'text/event-stream');
  res.setHeader('Cache-Control', 'no-cache');
  res.setHeader('Connection', 'keep-alive');
  
  // 订阅事件
  const iterator = agent.subscribe(['progress', 'monitor'])[Symbol.asyncIterator]();
  
  for await (const envelope of iterator) {
    const { event } = envelope;
    
    // 发送SSE事件
    res.write(`event: ${event.type}\n`);
    res.write(`data: ${JSON.stringify({ event })}\n\n`);
    
    if (event.type === 'done') {
      res.end();
      break;
    }
  }
});
```

### 运行时配置
```typescript
export function createRuntime(): AgentDependencies {
  const store = new JSONStore('./.kode-demo-data');
  const templates = new AgentTemplateRegistry();
  const tools = new ToolRegistry();
  
  // 注册工具
  [...builtin.fs(), ...builtin.bash(), ...builtin.todo()].forEach(tool => {
    tools.register(tool.name, () => tool);
  });
  
  // 注册模板
  templates.register({
    id: 'chat-assistant',
    systemPrompt: '你是一个友好的AI助手...',
    tools: ['fs_read', 'fs_write', 'bash_run', 'todo_read', 'todo_write'],
    model: 'glm-4.5-air'
  });
  
  return {
    store,
    templateRegistry: templates,
    toolRegistry: tools,
    sandboxFactory: new SandboxFactory(),
    modelFactory: (config) => new GLMProvider(apiKey, model)
  };
}
```

## 部署和启动

### 1. 安装依赖
```bash
npm install express cors
```

### 2. 启动服务器
```bash
npx ts-node demo/server.ts
# 或
npm run demo
```

### 3. 访问前端
```
http://localhost:3000
```

### 4. 健康检查
```bash
curl http://localhost:3000/health
```

## 特性优势

### ✅ 实时流式输出
- 支持文本流式显示
- 工具调用状态实时更新
- 输入中指示器

### ✅ 完整的事件系统
- 文本流事件（text_chunk）
- 工具生命周期（tool:start/end）
- 状态变更（done）

### ✅ 会话管理
- 会话创建和恢复
- 历史消息查询
- Agent状态管理

### ✅ 现代化UI
- 响应式设计
- 动画效果
- 工具调用可视化

### ✅ 错误处理
- 连接状态监控
- 错误事件处理
- 自动重连机制

## 扩展功能

### 1. 多用户支持
- 用户认证集成
- 会话隔离
- 权限管理

### 2. 文件上传
- 文件拖拽上传
- 进度显示
- 文件预览

### 3. 工具调用审批
- 审批流程UI
- 实时审批状态
- 批量审批

### 4. 监控面板
- Agent状态监控
- 性能指标
- 错误统计

---
*创建时间：2025-10-14*
*测试状态：前端对接分析完成*